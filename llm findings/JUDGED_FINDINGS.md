# Judged Findings Report -- Skeptical Code Audit Judge

## Methodology

Each ConsolidatedFinding from the Master Bug Ledger was subjected to five adversarial checks: **evidence**, **plausibility**, **contradiction**, **verification plan**, and **fix safety**. Verdicts are assigned conservatively -- a finding must earn its status through concrete evidence, not volume of reports.

## Summary Statistics

- Input findings judged: **645**
- CERTIFIED: **155**
- PLAUSIBLE: **364**
- SPECULATIVE: **116**
- REJECTED: **10**

Post-judging confidence distribution:
- high: **155**
- medium: **335**
- low: **155**

## Verdict Table (sorted by priority_score descending)

| cid | verdict | conf_after | severity | priority | key evidence? | what's missing | minimal verification | safest fix |
|---|---|---|---|---:|---|---|---|---|
| CF-001 | CERTIFIED | high | S0 | 10.00 | file:1, sym:4, snippet:5 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_scheduler" "net/tquic/multipath/tquic_scheduler.c"; make M=net/tquic W=1 (+1 more) | Add an explicit check: `cwnd_avail = (path->cc.cwnd > path->cc.bytes_in_flight) ? path->cc.cwnd - path->cc.bytes_in_flig |
| CF-003 | CERTIFIED | high | S0 | 10.00 | file:1, sym:5, lines:2, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_verify_client_cert" "net/tquic/crypto/cert_verify.c"; sed -n '2450,2450p' net/tquic/crypto/cert_verify.c | Add a `bool is_server` parameter to the internal `verify_chain()` call path, or refactor so that client cert verificatio |
| CF-004 | CERTIFIED | high | S0 | 10.00 | file:1, sym:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "h3_connection_destroy" "net/tquic/http3/http3_stream.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/ht | Collect stream pointers into a local list under the spinlock, release the spinlock, then close each stream outside the l |
| CF-005 | CERTIFIED | high | S0 | 10.00 | file:1, sym:9, snippet:4 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "change" "net/tquic/crypto/key_update.c"; make M=net/tquic W=1 (+1 more) | Use a proper typed structure with a named field, or use `container_of()` macro. Never use raw byte offsets to access str |
| CF-006 | CERTIFIED | high | S0 | 10.00 | file:1, sym:5 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "free" "net/tquic/http3/http3_stream.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/http3/http3_str | Add `refcount_inc(&stream->refcount)` in `h3_stream_lookup()` and require all callers to call a corresponding `h3_stream |
| CF-007 | CERTIFIED | high | S0 | 10.00 | file:1, sym:6, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "pr_debug" "net/tquic/crypto/cert_verify.c"; make M=net/tquic W=1 (+1 more) | Either implement OCSP response verification or remove the early return so that the "no OCSP available" path is taken, wh |
| CF-008 | CERTIFIED | high | S0 | 10.00 | file:1, sym:6 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "allocation" "net/tquic/diag/path_metrics.c"; make M=net/tquic W=1 (+1 more) | Cap the allocation at a fixed reasonable maximum (e.g., `min(conn->num_paths, TQUIC_MAX_PATHS) * NLMSG_DEFAULT_SIZE`), a |
| CF-009 | CERTIFIED | high | S0 | 10.00 | file:1, sym:5 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "either" "net/tquic/http3/qpack_dynamic.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/http3/qpack_ | Either (a) increment the entry's refcount before dropping the lock, or (b) copy the name/value data into a local buffer  |
| CF-010 | CERTIFIED | high | S0 | 10.00 | file:1, sym:7, lines:4, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "comparison" "net/tquic/crypto/cert_verify.c"; sed -n '1628,1628p' net/tquic/crypto/cert_verify.c (+3 more) | Use `crypto_memneq()` consistently for all comparisons, or use `memcmp()` consistently for non-secret data. The key poin |
| CF-011 | CERTIFIED | high | S0 | 10.00 | file:1, sym:3, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "label" "net/tquic/crypto/handshake.c"; sed -n '238,238p' net/tquic/crypto/handshake.c (+3 more) | Add explicit bounds check: `if (label_len + context_len + 10 > sizeof(hkdf_label)) return -EINVAL;` before any writes to |
| CF-012 | CERTIFIED | high | S0 | 10.00 | file:4, sym:20, lines:8, snippet:12 | Kernel log / stack trace / error output demonstrating the issue | rg -n "dispatcher" "net/tquic/tquic_input.c"; sed -n '2303,2310p' net/tquic/tquic_input.c (+3 more) | Add a flag to `tquic_rx_ctx` that records when a length-less STREAM frame is processed, and assert in the dispatcher tha |
| CF-014 | CERTIFIED | high | S0 | 10.00 | file:1, sym:1, lines:3, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_process_certificate" "net/tquic/crypto/handshake.c"; sed -n '1778,1778p' net/tquic/crypto/handshake.c (+ | Check `certs_len >= 3` before `certs_len -= 3`, and `certs_len >= 2` before `certs_len -= 2`. Alternatively, track posit |
| CF-015 | CERTIFIED | high | S0 | 10.00 | file:1, sym:3, lines:1, snippet:3 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_session_ticket" "net/tquic/crypto/handshake.c"; sed -n '76,77p' net/tquic/crypto/handshake.c (+3 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-023 | CERTIFIED | high | S0 | 10.00 | file:2, sym:8, lines:3, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "__skb_dequeue" "net/tquic/napi.c"; sed -n '460,465p' net/tquic/napi.c (+4 more) | Use the same batch-splice pattern as `tquic_napi_poll()`: splice the queue to a local list under a single lock acquisiti |
| CF-024 | CERTIFIED | high | S0 | 10.00 | file:1, lines:2, snippet:2 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '850,850p' net/quic/tquic/masque/capsule.c; sed -n '894,894p' net/quic/tquic/masque/capsule.c (+2 more) | Add overflow check: ```c if (cap->length > SIZE_MAX - CAPSULE_MAX_HEADER_SIZE)     return -EOVERFLOW; ```  --- Risk: Pro |
| CF-028 | CERTIFIED | high | S0 | 10.00 | file:1, sym:2, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_gso_ctx" "net/quic/tquic/tquic_output.c"; sed -n '1487,1487p' net/quic/tquic/tquic_output.c (+2 more) | Validate cumulative bytes written against SKB tailroom before each `skb_put_data`/`skb_put` call, or check `skb_tailroom |
| CF-029 | CERTIFIED | high | S0 | 10.00 | file:1, sym:2, lines:1, snippet:3 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_output" "net/quic/tquic/tquic_output.c"; sed -n '1851,1851p' net/quic/tquic/tquic_output.c (+3 more) | Use `check_mul_overflow` and `check_add_overflow`: ```c size_t alloc_size; if (check_mul_overflow((size_t)gso->gso_size, |
| CF-030 | CERTIFIED | high | S0 | 10.00 | file:1, sym:1, lines:5, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_parse_long_header" "net/tquic/core/connection.c"; sed -n '1932,1932p' net/tquic/core/connection.c (+4 more) | Replace the ad-hoc parsing with calls to the existing safe header parser `tquic_parse_long_header()`, or add proper boun |
| CF-033 | CERTIFIED | high | S0 | 10.00 | file:1, sym:2, lines:5, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_ku_derive_keys" "net/tquic/crypto/key_update.c"; sed -n '878,878p' net/tquic/crypto/key_update.c (+4 more) | Copy the secrets into local variables under the lock, then derive from the local copies (the pattern already used correc |
| CF-034 | CERTIFIED | high | S0 | 10.00 | file:1, sym:1, lines:2, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_build_ch_extensions" "net/tquic/crypto/handshake.c"; sed -n '1224,1234p' net/tquic/crypto/handshake.c (+ | Check for u32 overflow in the accumulation loop. Validate that the total extension length fits in a u16.  --- Risk: Prot |
| CF-037 | CERTIFIED | high | S0 | 10.00 | file:1, sym:1, lines:2, snippet:4 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_output" "net/quic/tquic/tquic_output.c"; sed -n '1356,1356p' net/quic/tquic/tquic_output.c (+3 more) | Add `BUILD_BUG_ON(TQUIC_MAX_HEADER_SIZE > 64)` or use `min(header_len, 64)` as a defense.  --- Risk: Protocol correctnes |
| CF-038 | CERTIFIED | high | S0 | 10.00 | file:1, sym:4, lines:5, snippet:5 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_timer_update_pto" "net/quic/tquic/tquic_timer.c"; sed -n '975,1029p' net/quic/tquic/tquic_timer.c (+4 more) | Standardize ALL uses of `rs->lock` and `pns->lock` to use `spin_lock_bh` Risk: Locking/ordering changes can cause deadlo |
| CF-044 | CERTIFIED | high | S0 | 10.00 | file:1, sym:3, lines:5, snippet:3 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_rx_ctx" "net/tquic/tquic_input.c"; sed -n '565,571p' net/tquic/tquic_input.c (+3 more) | Add a bounds check before decoding the packet number: ```c if (ctx.offset + pkt_num_len > len)     return -EINVAL; ``` R |
| CF-045 | CERTIFIED | high | S0 | 10.00 | file:1, sym:6, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "sockaddr_storage" "net/quic/tquic/tquic_input.c"; sed -n '242,243p' net/quic/tquic/tquic_input.c (+4 more) | Take a reference on the path before releasing the lock: `tquic_path_get(found)` and require callers to call `tquic_path_ |
| CF-046 | CERTIFIED | high | S0 | 10.00 | file:5, sym:18, lines:5, snippet:4 | Kernel log / stack trace / error output demonstrating the issue | rg -n "cache" "net/tquic/tquic_output.c"; sed -n '1806,1826p' net/tquic/tquic_output.c (+4 more) | 1. Use a slab cache (`kmem_cache`) for `tquic_pending_frame` structs (fixed size, high churn). 2. Eliminate the intermed |
| CF-047 | CERTIFIED | high | S0 | 10.00 | file:1, sym:4, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_decrypt_packet" "net/tquic/crypto/tls.c"; sed -n '622,622p' net/tquic/crypto/tls.c (+4 more) | Use separate AEAD transform handles for TX and RX, each with the key set once during key installation (not per-packet).  |
| CF-048 | CERTIFIED | high | S0 | 10.00 | file:1, lines:2, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '633,633p' net/quic/tquic/core/priority.c; sed -n '637,637p' net/quic/tquic/core/priority.c (+2 more) | Implement proper Structured Field Dictionary parsing per RFC 8941. Validate the priority field value format strictly. Ri |
| CF-050 | CERTIFIED | high | S0 | 10.00 | file:1, sym:3, lines:3, snippet:3 | Kernel log / stack trace / error output demonstrating the issue | rg -n "quic_packet" "net/quic/tquic/core/quic_packet.c"; sed -n '1248,1248p' net/quic/tquic/core/quic_packet.c (+3 more) | Replace `tquic_stream_create_internal` with `tquic_stream_open_incoming` which validates peer's MAX_STREAMS limit.  ---  |
| CF-051 | CERTIFIED | high | S0 | 10.00 | file:1, sym:9, lines:1, snippet:3 | Kernel log / stack trace / error output demonstrating the issue | rg -n "read_once" "net/tquic/tquic_socket.c"; sed -n '568,568p' net/tquic/tquic_socket.c (+3 more) | This is acceptable for poll() semantics (spurious wakeups are allowed), but document the intentional lockless access. Ri |
| CF-053 | CERTIFIED | high | S0 | 10.00 | file:1, lines:1, snippet:3 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '1195,1195p' net/tquic/core/connection.c; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/core/connecti | Add `if (ciphertext_len > sizeof(plaintext)) return -EINVAL;` before the memcpy. Risk: Fixes in parser/crypto/lifetime c |
| CF-054 | CERTIFIED | high | S0 | 10.00 | file:1, sym:1, lines:2, snippet:3 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_cid" "net/tquic/core/connection.c"; sed -n '2450,2450p' net/tquic/core/connection.c (+4 more) | Add bounds validation: ```c if (offset >= len) goto err_free; dcid_len = data[offset++]; if (dcid_len > TQUIC_MAX_CID_LE |
| CF-055 | CERTIFIED | high | S0 | 10.00 | file:1, sym:5, lines:10, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_process_stream_frame" "net/quic/tquic/tquic_input.c"; sed -n '944,944p' net/quic/tquic/tquic_input.c (+4 mo | Add a comment explaining why `_bh` is not needed in the receive path. Risk: Locking/ordering changes can cause deadlocks |
| CF-056 | CERTIFIED | high | S0 | 10.00 | file:1, sym:7, lines:2, snippet:4 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_path" "net/tquic/tquic_migration.c"; sed -n '1395,1395p' net/tquic/tquic_migration.c (+4 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-058 | CERTIFIED | high | S0 | 10.00 | file:1, sym:8, lines:1, snippet:5 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_handshake" "net/tquic/crypto/handshake.c"; sed -n '762,762p' net/tquic/crypto/handshake.c (+3 more) | Add bounds checking throughout `tquic_hs_build_ch_extensions`. Every write to `p` must verify `p + N <= buf + buf_len` b |
| CF-059 | CERTIFIED | high | S0 | 10.00 | file:1, sym:7, lines:1, snippet:3 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_conn_set_state" "net/tquic/tquic_input.c"; sed -n '1308,1308p' net/tquic/tquic_input.c (+3 more) | Use the state machine: call `tquic_conn_set_state(conn, TQUIC_CONN_CLOSED, TQUIC_REASON_PEER_CLOSE)` instead. Risk: Lock |
| CF-060 | CERTIFIED | high | S0 | 10.00 | file:1, sym:2, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_stream" "net/quic/tquic/core/quic_packet.c"; sed -n '1198,1198p' net/quic/tquic/core/quic_packet.c (+3 more | Cap `len` to a reasonable maximum (e.g., 16384 or the connection's max_stream_data) before allocation.  --- Risk: Lockin |
| CF-061 | CERTIFIED | high | S0 | 10.00 | file:1, sym:6, lines:5, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_crypto_init_versioned" "net/quic/tquic/core/connection.c"; sed -n '2518,2518p' net/quic/tquic/core/connecti | Create incremental error labels: ``` err_free_crypto:     tquic_crypto_free(conn->crypto_state);     conn->crypto_state  |
| CF-065 | CERTIFIED | high | S0 | 10.00 | file:1, lines:3, snippet:2 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '842,842p' net/quic/tquic/crypto/handshake.c; sed -n '849,849p' net/quic/tquic/crypto/handshake.c (+2 more) | Use `check_mul_overflow` or cap `new_alloc` more conservatively: ```c u32 new_alloc; if (check_mul_overflow(new_len, 2U, |
| CF-068 | CERTIFIED | high | S0 | 10.00 | file:2, sym:8, lines:4, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "memcmp" "net/tquic/tquic_input.c"; sed -n '245,245p' net/tquic/tquic_input.c (+3 more) | - Compare by `ss_family`, then compare only the relevant address+port fields for that family. Risk: Fixes in parser/cryp |
| CF-069 | CERTIFIED | high | S0 | 10.00 | file:1, sym:4, lines:4, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_cid" "net/tquic/core/connection.c"; sed -n '961,961p' net/tquic/core/connection.c (+3 more) | Calculate required size upfront and validate against `sizeof(packet)`.  --- Risk: Protocol correctness fixes can shift t |
| CF-002 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "enabled" "net/tquic/crypto/handshake.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/crypto/handsha | Add a running `offset` tracker and validate `offset + needed_bytes <= buf_len` before every write operation. Return `-EN |
| CF-013 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:12, snippet:3 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_sock" "net/tquic/tquic_socket.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tquic_socket.c" (+2 | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-016 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_process_server_hello" "net/tquic/crypto/handshake.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "ne | Add `if (p >= end) return -EINVAL;` before reading compression. Risk: Fixes in parser/crypto/lifetime code may alter pac |
| CF-017 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:9, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_shutdown" "net/tquic/tquic_socket.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tquic_socket.c" | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-018 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_varint_len" "net/tquic/tquic_output.c"; make M=net/tquic W=1 (+1 more) | Add explicit check: `if (len == 0) return -EOVERFLOW;` Risk: Protocol correctness fixes can shift timing/state-machine b |
| CF-019 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:7, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_path" "net/tquic/multipath/tquic_scheduler.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/mu | Use a separate flag variable to track whether the path was found, or use `list_for_each_entry_rcu()` with a found flag c |
| CF-020 | PLAUSIBLE | medium | S0 | 10.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Validate each character is an ASCII digit before arithmetic. Validate month (1-12), day (1-31), hour (0-23), minute (0-5 |
| CF-021 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_quic_proxy_register_conn" "net/tquic/masque/quic_proxy.c"; make M=net/tquic W=1 (+1 more) | Set `require_auth = true` by default. Implement mandatory authentication (PSK, certificate, or token-based) in `tquic_qu |
| CF-022 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:5, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "blest_get_path" "net/tquic/multipath/sched_blest.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/multip | Add `spin_lock_irqsave(&sd->lock, flags)` to `blest_path_removed()`, `blest_ack_received()`, and `blest_loss_detected()` |
| CF-025 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:11, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "resolve_target" "net/tquic/masque/connect_udp.c"; make M=net/tquic W=1 (+1 more) | Add address validation after `in4_pton`/`in6_pton` succeeds. Block at minimum: `ipv4_is_loopback()`, `ipv4_is_multicast( |
| CF-026 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "spin_lock_irqsave" "net/tquic/multipath/sched_ecf.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/multi | Wrap all accesses to `sd->paths[]` and `sd->current_path_id` in `spin_lock_irqsave(&sd->lock, flags)` Risk: Locking/orde |
| CF-027 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_cong_on_ecn" "net/tquic/tquic_input.c"; make M=net/tquic W=1 (+1 more) | Store the previous ECN counts per path (in `struct tquic_ecn_tracking`) and only call `tquic_cong_on_ecn()` with the del |
| CF-031 | PLAUSIBLE | medium | S0 | 10.00 | file:1, snippet:2 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | The function must return `-EKEYREVOKED` or a similar error when `TQUIC_REVOKE_HARD_FAIL` is set and revocation status ca |
| CF-032 | PLAUSIBLE | medium | S0 | 10.00 | file:2, sym:2, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_tunnel" "net/tquic/masque/connect_udp.c"; make M=net/tquic W=1 (+1 more) | Store a reference to the correct network namespace (`struct net *`) at connection establishment time (via `sock_net(sk)` |
| CF-035 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "pr_warn_once" "net/tquic/lb/quic_lb.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/lb/quic_lb.c" ( | Log a `pr_warn_once()` when plaintext mode is selected. Consider requiring `CAP_NET_ADMIN` to create plaintext configs,  |
| CF-036 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:5, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "ipv4_is_linklocal_169" "net/tquic/tquic_tunnel.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tquic_tu | Add checks for `ipv4_is_private_10()`, `ipv4_is_private_172()`, `ipv4_is_private_192()`, `ipv4_is_linklocal_169()`, and  |
| CF-039 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_nf" "net/tquic/tquic_nf.c"; make M=net/tquic W=1 (+1 more) | Register hooks via `pernet_operations` so each namespace gets its own hooks, or verify this is intentionally init_net-on |
| CF-040 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:5, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "netif_rx" "net/tquic/masque/connect_ip.c"; make M=net/tquic W=1 (+1 more) | Add source and destination address validation in `connect_ip_validate_ip_header()` or a new function called before `neti |
| CF-041 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_proto" "net/tquic/tquic_proto.c"; make M=net/tquic W=1 (+1 more) | Consider requiring `CAP_NET_ADMIN` for bonding/multipath features, or at minimum for creating tunnels and MASQUE proxies |
| CF-042 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:2, lines:5 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_socket" "net/tquic/tquic_socket.c"; sed -n '771,771p' net/tquic/tquic_socket.c (+3 more) | Add `ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN)` checks for privileged options.  --- Risk: Fixes in parser/crypto/ |
| CF-049 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "qpack_decoder" "net/quic/tquic/http3/qpack_decoder.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/quic/t | Replace stack buffers with heap allocation (kmalloc with GFP_ATOMIC). The value_buf alone at 8192 bytes is dangerously l |
| CF-052 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "crypto_memneq" "net/tquic/core/connection.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/core/conn | Use `crypto_memneq()` for the hash comparison, or accept the current design as adequate given AEAD authentication. Risk: |
| CF-057 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "ipv6_addr_v4mapped" "net/tquic/tquic_tunnel.c"; make M=net/tquic W=1 (+1 more) | Add checks for `ipv6_addr_v4mapped()`, `ipv6_addr_is_isatap()`, private RFC 1918 ranges within mapped addresses, and the |
| CF-062 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_conn_server_accept" "net/quic/tquic/core/connection.c"; make M=net/tquic W=1 (+1 more) | Change to `return ret;` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop |
| CF-063 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:4, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_send_connection_close" "net/quic/tquic/tquic_output.c"; make M=net/tquic W=1 (+1 more) | Add `if (header_len < 0) { kfree_skb(skb); kfree(buf); return header_len; }` before the `skb_put_data` calls.  --- Risk: |
| CF-064 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_stream_sendmsg" "net/quic/tquic/tquic_stream.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/quic/t | Stream objects need reference counting. The stream_sock should hold a reference to the stream. Only when both the tree r |
| CF-066 | PLAUSIBLE | medium | S0 | 10.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Use the network namespace from the QUIC connection's socket (`sock_net(conn->sk)`) instead of `&init_net`. Pass the corr |
| CF-067 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:2, snippet:3 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "capsule_alloc" "net/tquic/masque/capsule.c"; make M=net/tquic W=1 (+1 more) | Validate `parser->header.length <= CAPSULE_MAX_PAYLOAD_SIZE` immediately after header decode succeeds, before calling `c |
| CF-070 | PLAUSIBLE | medium | S0 | 10.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/quic/tquic/http3/webtransport.c"; make M=net/tquic W=1 (+1 more) | Use heap allocation (kmalloc/kzalloc) for this buffer.  --- Risk: Fixes in parser/crypto/lifetime code may alter packet  |
| CF-071 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:1, lines:3, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_xsk_create" "net/tquic/af_xdp.c"; sed -n '367,367p' net/tquic/af_xdp.c (+3 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-072 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:4, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_connection" "net/tquic/tquic_input.c"; sed -n '397,407p' net/tquic/tquic_input.c (+3 more) | Hold a reference to the socket (`sock_hold(sk)`) under the lock, then call `sk_state_change`, then release the reference |
| CF-073 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:3, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_cong_on_ack" "net/quic/tquic/tquic_input.c"; sed -n '737,737p' net/quic/tquic/tquic_input.c (+2 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-074 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:11, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "copies" "net/tquic/tquic_socket.c"; sed -n '246,246p' net/tquic/tquic_socket.c (+3 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-075 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:7, lines:6, snippet:2 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_udp_recv" "net/quic/tquic/tquic_input.c"; sed -n '3079,3079p' net/quic/tquic/tquic_input.c (+3 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-076 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:1, lines:3, snippet:2 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_remove_header_protection" "net/tquic/tquic_input.c"; sed -n '2529,2529p' net/tquic/tquic_input.c (+3 more) | Move the `pkt_num_len` extraction to AFTER `tquic_remove_header_protection()`: ```c ret = tquic_remove_header_protection |
| CF-077 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:1, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "quic_over_tcp" "net/tquic/transport/quic_over_tcp.c"; sed -n '1225,1225p' net/tquic/transport/quic_over_tcp.c (+3 | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-078 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:1, lines:5, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_netlink" "net/tquic/tquic_netlink.c"; sed -n '427,427p' net/tquic/tquic_netlink.c (+4 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-079 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:2, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "ip_local_out" "net/tquic/tquic_output.c"; sed -n '1730,1736p' net/tquic/tquic_output.c (+2 more) | Save `skb->len` in a local variable before calling `ip_local_out()`: ```c u32 pkt_len = skb->len; ret = ip_local_out(&in |
| CF-080 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:11, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "could" "net/tquic/tquic_migration.c"; sed -n '1098,1098p' net/tquic/tquic_migration.c (+2 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-081 | PLAUSIBLE | medium | S0 | 10.00 | file:4, sym:4, lines:4, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_stream" "net/quic/tquic/core/priority.c"; sed -n '497,524p' net/quic/tquic/core/priority.c (+4 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-082 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:3, lines:4, snippet:3 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "atomic_set" "net/quic/tquic/bond/tquic_failover.c"; sed -n '198,229p' net/quic/tquic/bond/tquic_failover.c (+4 mo | Either protect these operations with a per-path spinlock, or use `atomic_inc_return()` Risk: Locking/ordering changes ca |
| CF-083 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:1, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_conn_get" "net/quic/tquic/tquic_stream.c"; sed -n '680,680p' net/quic/tquic/tquic_stream.c (+3 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-084 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:7, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_offload_key_install" "net/tquic/offload/smartnic.c"; sed -n '264,264p' net/tquic/offload/smartnic.c (+4 mor | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-085 | PLAUSIBLE | medium | S0 | 10.00 | file:1, sym:3, lines:5, snippet:2 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "sock" "net/tquic/tquic_socket.c"; sed -n '230,230p' net/tquic/tquic_socket.c (+4 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-086 | PLAUSIBLE | medium | S0 | 10.00 | file:1, lines:2, snippet:2 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue (+1 more) | sed -n '1730,1730p' net/tquic/tquic_output.c; sed -n '1681,1681p' net/tquic/tquic_output.c (+2 more) | Use `sock_net(conn->sk)` instead of `&init_net`. The correct network namespace was already computed at line 1681 in the  |
| CF-043 | SPECULATIVE | low | S0 | 10.00 | sym:10 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+2 more) | rg -rn "tquic_sock_bind" net/tquic/; rg -rn "spin_lock\\|mutex_lock" net/tquic/ (+2 more) | Invoke appropriate `security_socket_*` hooks in TQUIC socket operations. At minimum: - `security_socket_create()` in `tq |
| CF-136 | CERTIFIED | high | S1 | 7.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Define `#define TQUIC_STREAM_SIZE_UNKNOWN U64_MAX` and use it consistently. Risk: Protocol correctness fixes can shift t |
| CF-137 | CERTIFIED | high | S1 | 7.00 | file:1, sym:4, lines:1, snippet:4 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_ct_memcmp" "net/tquic/security/quic_exfil.c"; sed -n '394,394p' net/tquic/security/quic_exfil.c (+3 more) | Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Wat |
| CF-138 | CERTIFIED | high | S1 | 7.00 | file:1, sym:4 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "decoder" "net/tquic/crypto/cert_verify.c"; make M=net/tquic W=1 (+1 more) | Consider using the kernel's built-in ASN.1 decoder (`lib/asn1_decoder.c`) and the x509 certificate parser (`crypto/asymm |
| CF-139 | CERTIFIED | high | S1 | 7.00 | file:1, sym:5, lines:2, snippet:3 | Kernel log / stack trace / error output demonstrating the issue | rg -n "corrupted" "net/tquic/security/quic_exfil.c"; sed -n '71,71p' net/tquic/security/quic_exfil.c (+3 more) | Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Wat |
| CF-140 | CERTIFIED | high | S1 | 7.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "h3_request_send_headers" "net/tquic/http3/http3_request.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic | Either hold the lock during the entire send operation, or re-validate state after acquiring any needed resources. Risk:  |
| CF-141 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "h3_connection_send_settings" "net/tquic/http3/http3_stream.c"; make M=net/tquic W=1 (+1 more) | Use proper QUIC variable-length integer encoding for the frame length, or validate that `settings_len <= 255` before the |
| CF-142 | CERTIFIED | high | S1 | 7.00 | file:1, sym:5, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "crypto_free_sync_skcipher" "net/tquic/lb/quic_lb.c"; make M=net/tquic W=1 (+1 more) | Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Wat |
| CF-143 | CERTIFIED | high | S1 | 7.00 | file:1, sym:8, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "capable" "net/tquic/tquic_tunnel.c"; make M=net/tquic W=1 (+1 more) | Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Wat |
| CF-144 | CERTIFIED | high | S1 | 7.00 | file:1, sym:5 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "export" "net/tquic/diag/path_metrics.c"; make M=net/tquic W=1 (+1 more) | Add `.policy` with `GENL_ADMIN_PERM` flag or explicit `CAP_NET_ADMIN` check in each handler. Risk: Fixes in parser/crypt |
| CF-145 | CERTIFIED | high | S1 | 7.00 | file:1, sym:4 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "changes" "net/tquic/crypto/tls.c"; make M=net/tquic W=1 (+1 more) | Set the key once when it changes (at key installation time), not on every packet. Store the AEAD transform with the key  |
| CF-146 | CERTIFIED | high | S1 | 7.00 | file:1, sym:6 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "crypto_alloc_aead" "net/tquic/crypto/zero_rtt.c"; make M=net/tquic W=1 (+1 more) | Pre-allocate the AEAD transform during `tquic_zero_rtt_init()` or `tquic_zero_rtt_attempt()` and reuse it for the lifeti |
| CF-147 | CERTIFIED | high | S1 | 7.00 | file:1, sym:5 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "blocks" "net/tquic/http3/qpack_decoder.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/http3/qpack_deco | Track total blocked stream memory and enforce a per-connection limit (e.g., 1MB total blocked stream data). Risk: Lockin |
| CF-148 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "qpack_encoder" "net/tquic/http3/qpack_encoder.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/http3 | Validate that `known_received_count + value <= insert_count` (the total entries ever inserted) and that the addition doe |
| CF-149 | CERTIFIED | high | S1 | 7.00 | file:1, sym:4 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "derivation" "net/tquic/crypto/key_update.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/crypto/key_upd | Use a state flag (e.g., `keys_installing`) that prevents concurrent use during the derivation window. Set the flag under |
| CF-150 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "verification" "net/tquic/crypto/cert_verify.c"; make M=net/tquic W=1 (+1 more) | Parse the RSA-PSS AlgorithmIdentifier parameters to extract the actual hash algorithm. Risk: Fixes in parser/crypto/life |
| CF-151 | CERTIFIED | high | S1 | 7.00 | file:1, sym:4, lines:5, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "consumed" "net/tquic/crypto/handshake.c"; sed -n '995,1045p' net/tquic/crypto/handshake.c (+3 more) | Zeroize these secrets using `memzero_explicit()` as soon as they have been consumed (after key derivation and ticket iss |
| CF-152 | CERTIFIED | high | S1 | 7.00 | file:1, sym:6, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "data_sent" "net/tquic/core/stream.c"; make M=net/tquic W=1 (+1 more) | Add TQUIC_STREAM_SEND and TQUIC_STREAM_RECV as valid transitions from OPEN. Risk: Protocol correctness fixes can shift t |
| CF-153 | CERTIFIED | high | S1 | 7.00 | file:1, sym:9, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "context" "net/tquic/security/quic_exfil.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/security/quic_e | Missing fix suggestion in source text. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if n |
| CF-154 | CERTIFIED | high | S1 | 7.00 | file:1, sym:5, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "connections" "net/tquic/tquic_netlink.c"; make M=net/tquic W=1 (+1 more) | Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Wat |
| CF-155 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "context_destroy" "net/tquic/http3/webtransport.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/http | Use a safe iteration pattern: move items to a local list under the lock, release the lock, then process the local list.  |
| CF-156 | CERTIFIED | high | S1 | 7.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "capsule" "net/tquic/http3/webtransport.c"; make M=net/tquic W=1 (+1 more) | Enforce a maximum capsule buffer size (e.g., 64KB or configurable via socket option) and reject connections that exceed  |
| CF-157 | CERTIFIED | high | S1 | 7.00 | file:2, sym:1, lines:2, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "quic_offload" "net/quic/tquic/quic_offload.c"; sed -n '429,429p' net/quic/tquic/quic_offload.c (+3 more) | Cast to `u32` before shift: ```c version = ((u32)data[1] << 24) \| ((u32)data[2] << 16) \|           ((u32)data[3] << 8) |
| CF-160 | CERTIFIED | high | S1 | 7.00 | file:1, sym:2, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_set_alpn" "net/tquic/crypto/handshake.c"; sed -n '2964,2964p' net/tquic/crypto/handshake.c (+2 more) | Validate ALPN total length fits in u16 in `tquic_hs_set_alpn()`. Add a reasonable cap on `alpn_count`.  --- Risk: Fixes  |
| CF-163 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_hkdf_expand_label" "net/tquic/crypto/handshake.c"; sed -n '762,762p' net/tquic/crypto/handshake.c (+2 mo | ```c if (context_len > 255)     return -EINVAL; ```  --- Risk: Fixes in parser/crypto/lifetime code may alter packet acc |
| CF-165 | CERTIFIED | high | S1 | 7.00 | file:1, sym:3, lines:2, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_process_new_session_ticket" "net/tquic/crypto/handshake.c"; sed -n '2609,2609p' net/tquic/crypto/handsha | Track whether `hs->session_ticket` is owned or borrowed. Only free owned tickets. Risk: Fixes in parser/crypto/lifetime  |
| CF-166 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1, lines:4, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_process_server_hello" "net/tquic/crypto/handshake.c"; sed -n '1423,1423p' net/tquic/crypto/handshake.c ( | Add `if (p >= end) return -EINVAL;` before `session_id_len = *p++;`.  --- Risk: Fixes in parser/crypto/lifetime code may |
| CF-169 | CERTIFIED | high | S1 | 7.00 | file:2, sym:5, lines:4, snippet:3 | Kernel log / stack trace / error output demonstrating the issue | rg -n "lock_sock" "net/quic/tquic/tquic_socket.c"; sed -n '95,95p' net/quic/tquic/tquic_socket.c (+4 more) | Remove the inner `spin_lock_bh(&sk->sk_lock.slock)` calls in `tquic_accept()`. The `lock_sock()` already provides suffic |
| CF-173 | CERTIFIED | high | S1 | 7.00 | file:1, lines:1, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '913,916p' net/tquic/crypto/zero_rtt.h; make M=net/tquic W=1 (+1 more) | Increase `TQUIC_REPLAY_BLOOM_BITS` to at least `(1 << 20)` (1M bits = 128KB) for production use, or make it configurable |
| CF-174 | CERTIFIED | high | S1 | 7.00 | file:1, sym:3, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_bonding_destroy" "net/quic/tquic/bond/tquic_bonding.c"; sed -n '174,174p' net/quic/tquic/bond/tquic_bonding | Add a "destroying" flag to `bc` checked after relock, or use refcounting on `bc`. Risk: Locking/ordering changes can cau |
| CF-177 | CERTIFIED | high | S1 | 7.00 | file:2, sym:8, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "read_once" "net/tquic/tquic_output.c"; sed -n '1121,1132p' net/tquic/tquic_output.c (+3 more) | For the single-path fast path, use `READ_ONCE(conn->active_path)` without the lock. Only take the lock when a scheduler  |
| CF-178 | CERTIFIED | high | S1 | 7.00 | file:2, sym:7, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "operations" "net/tquic/tquic_output.c"; sed -n '2058,2072p' net/tquic/tquic_output.c (+3 more) | Merge the two critical sections into one: check flow control credit and begin stream iteration under the same `conn->loc |
| CF-179 | CERTIFIED | high | S1 | 7.00 | file:2, sym:7, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "first" "net/tquic/tquic_input.c"; sed -n '251,258p' net/tquic/tquic_input.c (+3 more) | Use a hash table (rhashtable) for path-by-address lookup. For single-path connections, cache the last-used path and chec |
| CF-180 | CERTIFIED | high | S1 | 7.00 | file:2, sym:3, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "does" "net/tquic/tquic_output.c"; sed -n '1950,1951p' net/tquic/tquic_output.c (+3 more) | Use a stack buffer like `tquic_send_ack()` does (line 1877: `u8 buf_stack[128]`). A 256-byte stack allocation is safe in |
| CF-183 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1, lines:3, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_input" "net/tquic/tquic_input.c"; sed -n '702,707p' net/tquic/tquic_input.c (+3 more) | Validate that ECN counts are monotonically increasing from previous values. Store previous ECN counts per-path and only  |
| CF-184 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1, lines:3, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "eku_hkdf_extract" "net/tquic/crypto/extended_key_update.c"; sed -n '821,821p' net/tquic/crypto/extended_key_updat | Either (a) hold the KU lock around `hash_tfm` access, or (b) copy `hash_tfm` under the KU lock and use the copy (though  |
| CF-190 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1, lines:2, snippet:3 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_socket" "net/quic/tquic/tquic_socket.c"; sed -n '1317,1317p' net/quic/tquic/tquic_socket.c (+3 more) | Add `if (identity_len > len) return -EINVAL;` before the copy_to_user call.  --- Risk: Protocol correctness fixes can sh |
| CF-191 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_input" "net/tquic/tquic_input.c"; sed -n '2249,2253p' net/tquic/tquic_input.c (+2 more) | The GRO coalesce function needs to know the actual CID length. Pass it via skb metadata or look it up from connection st |
| CF-192 | CERTIFIED | high | S1 | 7.00 | file:1, sym:2, lines:2, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_gro_receive_internal" "net/quic/tquic/tquic_input.c"; sed -n '2306,2306p' net/quic/tquic/tquic_input.c (+4  | After the loop, set `gro->held_count = skb_queue_len(&gro->hold_queue)` instead of hard-coding 0. Risk: Locking/ordering |
| CF-195 | CERTIFIED | high | S1 | 7.00 | file:4, sym:8, lines:3, snippet:3 | Kernel log / stack trace / error output demonstrating the issue | rg -n "atomic64_inc" "net/tquic/tquic_offload.c"; sed -n '235,253p' net/tquic/tquic_offload.c (+2 more) | Use per-CPU counters for GRO statistics, aggregate on read. Risk: Protocol correctness fixes can shift timing/state-mach |
| CF-200 | CERTIFIED | high | S1 | 7.00 | file:2, sym:4, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_skb_zerocopy_iter_stream" "net/tquic/tquic_zerocopy.c"; sed -n '315,318p' net/tquic/tquic_zerocopy.c (+3 mo | Add a retry counter (e.g., max 3 retries) and return an error after exhausting retries. Alternatively, adjust the chunk  |
| CF-202 | CERTIFIED | high | S1 | 7.00 | file:3, sym:8, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "acquisitions" "net/tquic/io_uring.c"; sed -n '804,838p' net/tquic/io_uring.c (+4 more) | If get/put are guaranteed to be called from different contexts (producer vs consumer), replace the spinlock with a lockl |
| CF-205 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1, lines:3, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "memzero_explicit" "net/tquic/crypto/key_update.c"; sed -n '435,435p' net/tquic/crypto/key_update.c (+3 more) | Replace all `memset(..., 0, ...)` clearing key material with `memzero_explicit()`. Risk: Fixes in parser/crypto/lifetime |
| CF-206 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "kfree_sensitive" "net/quic/tquic/crypto/handshake.c"; sed -n '1280,1280p' net/quic/tquic/crypto/handshake.c (+3 m | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-211 | CERTIFIED | high | S1 | 7.00 | file:1, lines:2, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '590,601p' net/tquic/core/packet.c; sed -n '619,619p' net/tquic/core/packet.c (+2 more) | Add `if (hdr->payload_len < hdr->pn_len) return -EPROTO;` before the subtraction. Risk: Protocol correctness fixes can s |
| CF-213 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "current_cred" "net/tquic/crypto/cert_verify.c"; sed -n '2772,2808p' net/tquic/crypto/cert_verify.c (+3 more) | Add `capable(CAP_NET_ADMIN)` check in the write handler. Consider using 0600 permissions. Risk: Fixes in parser/crypto/l |
| CF-217 | CERTIFIED | high | S1 | 7.00 | file:4, sym:11, lines:7, snippet:4 | Kernel log / stack trace / error output demonstrating the issue | rg -n "atomic64_add" "net/tquic/napi.c"; sed -n '307,308p' net/tquic/napi.c (+2 more) | Remove the `tquic_napi_global_stats` atomic counters entirely. Use `tquic_napi_aggregate_pcpu_stats()` (already implemen |
| CF-218 | CERTIFIED | high | S1 | 7.00 | file:1, lines:1, snippet:3 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '590,590p' net/quic/tquic/fec/reed_solomon.c; make M=net/tquic W=1 (+1 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-220 | CERTIFIED | high | S1 | 7.00 | file:1, lines:2, snippet:2 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '1379,1379p' net/tquic/core/connection.c; sed -n '1401,1401p' net/tquic/core/connection.c (+3 more) | Allocate `packet`, `token`, and `pseudo_packet` on the heap using `kmalloc`.  --- Risk: Fixes in parser/crypto/lifetime  |
| CF-225 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "atomic_inc_return" "net/quic/tquic/security_hardening.c"; sed -n '280,280p' net/quic/tquic/security_hardening.c ( | Use `atomic_inc_return()` and check the result instead of separate read + increment. Risk: Locking/ordering changes can  |
| CF-226 | CERTIFIED | high | S1 | 7.00 | file:1, lines:3, snippet:2 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '1160,1160p' net/tquic/crypto/zero_rtt.c; sed -n '1143,1143p' net/tquic/crypto/zero_rtt.c (+3 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-231 | CERTIFIED | high | S1 | 7.00 | file:1, sym:4, lines:4, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "alloc_skb" "net/tquic/tquic_input.c"; sed -n '944,944p' net/tquic/tquic_input.c (+4 more) | Move the `sk_rmem_alloc` check BEFORE the `alloc_skb()` call to avoid the allocation entirely when the buffer is full. A |
| CF-233 | CERTIFIED | high | S1 | 7.00 | file:1, sym:1, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_stream_recv_data" "net/quic/tquic/core/stream.c"; sed -n '697,699p' net/quic/tquic/core/stream.c (+2 more) | Add overflow check before the addition: `if (skb->len > U64_MAX - offset) return -EOVERFLOW;`  --- Risk: Protocol correc |
| CF-236 | CERTIFIED | high | S1 | 7.00 | file:1, sym:4, lines:4, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_stream_socket_create" "net/quic/tquic/tquic_stream.c"; sed -n '213,231p' net/quic/tquic/tquic_stream.c (+4  | Set `sk_user_data` to NULL before calling `tquic_sock_map_fd`, or set it only after successful fd allocation. Fix the `s |
| CF-237 | CERTIFIED | high | S1 | 7.00 | file:1, sym:2, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_zerocopy_sendmsg" "net/quic/tquic/tquic_zerocopy.c"; sed -n '360,360p' net/quic/tquic/tquic_zerocopy.c (+2  | On the error path, dequeue and free all SKBs added during this call, or commit the partial send as successful (return `c |
| CF-240 | CERTIFIED | high | S1 | 7.00 | file:1, lines:1, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '1140,1160p' net/quic/tquic/crypto/zero_rtt.c; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/quic/tquic/cry | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-089 | PLAUSIBLE | medium | S0 | 7.00 | file:1, sym:4, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_failover_ctx" "net/tquic/bond/tquic_failover.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-092 | PLAUSIBLE | low | S0 | 7.00 | file:4, sym:6, lines:4 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_cid_hash_add" "net/tquic/core/connection.c"; sed -n '2696,2696p' net/tquic/core/connection.c (+3 more) | - Pick exactly one authoritative CID demux table for RX and ensure connection creation inserts the SCID/DCIDs into it. - |
| CF-095 | PLAUSIBLE | medium | S0 | 7.00 | file:2, sym:5, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_conn_set_state" "net/tquic/core/connection.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/core/c | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-096 | PLAUSIBLE | medium | S0 | 7.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_conn_set_state" "net/tquic/tquic_input.c"; make M=net/tquic W=1 (+1 more) | All state transitions MUST go through `tquic_conn_set_state()`, and the function should assert/acquire `conn->lock` inte |
| CF-097 | PLAUSIBLE | medium | S0 | 7.00 | file:1, sym:2, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "attempt_rs_recovery" "net/tquic/fec/fec_decoder.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-098 | PLAUSIBLE | low | S0 | 7.00 | file:1, sym:4, lines:2 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "hashtable" "net/tquic/tquic_main.c"; sed -n '145,145p' net/tquic/tquic_main.c (+3 more) | - Either wire up insertion consistently at connection establishment, or delete `tquic_conn_table` and all iteration user |
| CF-099 | PLAUSIBLE | low | S0 | 7.00 | file:1, sym:2, lines:3 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_hp_unprotect" "net/tquic/tquic_input.c"; sed -n '2528,2528p' net/tquic/tquic_input.c (+3 more) | - Treat `tquic_hp_unprotect()` as authoritative for `pn_len` and (short header) `key_phase`. - After HP removal, recompu |
| CF-100 | PLAUSIBLE | medium | S0 | 7.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+3 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-101 | PLAUSIBLE | medium | S0 | 7.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "coupled_cc_increase" "net/tquic/bond/cong_coupled.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-102 | PLAUSIBLE | medium | S0 | 7.00 | file:2, snippet:2 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+3 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-104 | PLAUSIBLE | low | S0 | 7.00 | file:1, sym:5, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "rcu_read_unlock" "net/quic/tquic/bond/tquic_bpm.c"; sed -n '1876,1898p' net/quic/tquic/bond/tquic_bpm.c (+3 more) | Use `list_for_each_entry_safe()` is NOT sufficient here since the iteration continues after relock. Instead, collect pat |
| CF-106 | PLAUSIBLE | medium | S0 | 7.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+3 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-110 | PLAUSIBLE | low | S0 | 7.00 | file:1, sym:1, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_decode_pkt_num" "net/tquic/tquic_input.c"; sed -n '2572,2572p' net/tquic/tquic_input.c (+2 more) | - Track `largest_pn` per PN space (Initial/Handshake/Application) and pass it into `tquic_decode_pkt_num()`. Risk: Proto |
| CF-112 | PLAUSIBLE | medium | S0 | 7.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "qpack_dynamic" "net/quic/tquic/http3/qpack_dynamic.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-113 | PLAUSIBLE | low | S0 | 7.00 | file:1, lines:2 | Code snippet proving the vulnerable pattern; Function/struct symbol name at the fault site (+3 more) | sed -n '1090,1090p' net/tquic/security/quic_exfil.c; sed -n '270,270p' net/tquic/security/quic_exfil.c (+2 more) | - Never store function pointers in `skb->cb`. - Use a wrapper object (`struct { struct sk_buff *skb; void (*send_fn)(... |
| CF-115 | PLAUSIBLE | medium | S0 | 7.00 | file:2, snippet:2 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+3 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-118 | PLAUSIBLE | medium | S0 | 7.00 | file:1, sym:3, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_connection" "net/tquic/multipath/tquic_scheduler.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-119 | PLAUSIBLE | low | S0 | 7.00 | file:4, sym:10, lines:4 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "assertions" "Users/justinadams/Downloads/tquic-kernel/include/net/tquic.h"; sed -n '1965,1965p' Users/justinadams | - Make `tquic_conn_destroy()` private/internal (not a general-purpose public API). Enforce that all external callers use |
| CF-120 | PLAUSIBLE | low | S0 | 7.00 | file:2, sym:6, lines:2 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "call_rcu" "net/tquic/core/quic_connection.c"; sed -n '355,355p' net/tquic/tquic_cid.c (+4 more) | - Decide on a correct concurrency model:   - Option A: Use rhashtable in the intended RCU mode.     - Lookups under `rcu |
| CF-122 | PLAUSIBLE | medium | S0 | 7.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "olia_cc_increase" "net/tquic/bond/cong_coupled.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-125 | PLAUSIBLE | medium | S0 | 7.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "should" "net/tquic/tquic_tunnel.c"; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-127 | PLAUSIBLE | medium | S0 | 7.00 | file:1, sym:2, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "udp_tunnel_xmit_skb" "net/tquic/tquic_udp.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tquic_udp | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-128 | PLAUSIBLE | low | S0 | 7.00 | file:1, sym:8, lines:2 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "cancel_work_sync" "net/tquic/tquic_timer.c"; sed -n '848,848p' net/tquic/tquic_timer.c (+4 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-129 | PLAUSIBLE | medium | S0 | 7.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_timer_state" "net/tquic/tquic_timer.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tquic_tim | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-131 | PLAUSIBLE | medium | S0 | 7.00 | file:1, sym:5, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_path_find_by_addr" "net/tquic/tquic_migration.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-132 | PLAUSIBLE | medium | S0 | 7.00 | file:1, sym:4, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_cong_get_default_name" "net/tquic/cong/tquic_cong.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/t | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-134 | PLAUSIBLE | low | S0 | 7.00 | file:6, sym:18, lines:9 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "evidence" "net/tquic/Makefile"; sed -n '18,18p' net/tquic/Makefile (+4 more) | - Pick exactly one allocator strategy per object type (`tquic_connection`, `tquic_path`, `tquic_stream`) and enforce it  |
| CF-158 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:7, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "kfree_rcu" "net/tquic/tquic_cid.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tquic_cid.c" (+2 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-159 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_conn_retire_cid" "net/tquic/core/connection.c"; make M=net/tquic W=1 (+1 more) | Call `rhashtable_remove_fast()` when retiring a local CID. Risk: Protocol correctness fixes can shift timing/state-machi |
| CF-161 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:2, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_setup_psk" "net/tquic/crypto/handshake.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/cry | Either document clearly that `tquic_hs_setup_psk` takes ownership (and the caller must not free), or make `tquic_hs_setu |
| CF-162 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_generate_client_hello" "net/tquic/crypto/handshake.c"; sed -n '1320,1320p' net/tquic/crypto/handshake.c  | Validate `buf_len` against the minimum required size at function entry.  --- Risk: Fixes in parser/crypto/lifetime code  |
| CF-164 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, snippet:3 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_process_encrypted_extensions" "net/tquic/crypto/handshake.c"; make M=net/tquic W=1 (+1 more) | ```c if (ext_data_len >= 3 && proto_len > 0 && 3 + proto_len <= ext_data_len) { ```  --- Risk: Fixes in parser/crypto/li |
| CF-167 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_setup_psk" "net/tquic/crypto/handshake.c"; make M=net/tquic W=1 (+1 more) | Use `u64` for `age` and validate the time difference before multiplication. Also validate `lifetime` against RFC 8446 ma |
| CF-168 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_recvmsg" "net/tquic/tquic_socket.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tquic_socket.c"  | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-170 | PLAUSIBLE | medium | S1 | 7.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Use `check_add_overflow` and `check_mul_overflow` for safe arithmetic.  --- Risk: Protocol correctness fixes can shift t |
| CF-171 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "skb_set_owner_r" "net/quic/tquic/core/stream.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/quic/tquic/c | Use `skb_set_owner_r()` for receive buffers and let the destructor handle accounting, consistent with the tquic_stream.c |
| CF-172 | PLAUSIBLE | medium | S1 | 7.00 | file:1, snippet:2 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Return `u64` or `u32` with saturation: ```c return (u32)min_t(u64, inflight, U32_MAX); ```  --- Risk: Protocol correctne |
| CF-175 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:5, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "kfree_rcu" "net/tquic/tquic_cid.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tquic_cid.c" (+2 mo | The caller should be in an RCU read-side section, and connections should be freed via `kfree_rcu()`. Alternatively, take |
| CF-176 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_decode_packet_type" "net/tquic/core/packet.c"; make M=net/tquic W=1 (+1 more) | Read the version field (bytes 1-4) and use `tquic_decode_packet_type()` for version-aware type detection.  --- Risk: Pro |
| CF-181 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "quic_proxy_capsules" "net/tquic/masque/quic_proxy_capsules.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "ne | Either copy the packet data into a separately allocated buffer, or declare `capsule->packet` as `const u8 *` and ensure  |
| CF-182 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_socket" "net/quic/tquic/tquic_socket.c"; make M=net/tquic W=1 (+1 more) | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-185 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:2, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_key_update_get_current_keys" "net/tquic/crypto/extended_key_update.c"; make M=net/tquic W=1 (+1 more) | Add and use a function to retrieve the current traffic secret (not the derived key) from `tquic_key_update_state`. Deriv |
| CF-186 | PLAUSIBLE | medium | S1 | 7.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-187 | PLAUSIBLE | medium | S1 | 7.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | After the loop, iterate remaining entries and free any `repair_bufs[i]` that were not successfully adopted by a `repair_ |
| CF-188 | PLAUSIBLE | medium | S1 | 7.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Validate `target_fec_rate <= 100` before this calculation.  --- Risk: Locking/ordering changes can cause deadlocks or th |
| CF-189 | PLAUSIBLE | medium | S1 | 7.00 | file:1, snippet:2 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | ```c new_rate = (u32)((u64)sched->loss_count * 1000 Risk: Protocol correctness fixes can shift timing/state-machine beha |
| CF-193 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "h3_control_recv_frame" "net/quic/tquic/http3/http3_request.c"; make M=net/tquic W=1 (+1 more) | Implement actual parsing and processing for each frame type in this handler.  --- Risk: Protocol correctness fixes can s |
| CF-194 | PLAUSIBLE | medium | S1 | 7.00 | file:2, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "atomic64_inc_return" "net/tquic/tquic_output.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tquic_outp | If the TX path is always serialized by `conn->lock`, replace with a plain `u64` increment. If not always locked, documen |
| CF-196 | PLAUSIBLE | medium | S1 | 7.00 | file:2, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "userspace" "net/tquic/io_uring.c"; make M=net/tquic W=1 (+1 more) | Use buffer IDs (indices) rather than raw kernel addresses. Store the base address separately in a kernel-only structure  |
| CF-197 | PLAUSIBLE | medium | S1 | 7.00 | file:2, sym:6, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "buffer" "net/tquic/tquic_output.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tquic_output.c" (+2 mor | Use a per-connection pre-allocated scratch buffer (protected by `conn->lock` which is already held in the send path), or |
| CF-198 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "spin_lock" "net/quic/tquic/http3/http3_stream.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic/http | Use `spin_lock_bh` consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not val |
| CF-199 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:6, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "ipv6_addr_v4mapped" "net/tquic/tquic_tunnel.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tquic_tunne | Add checks for all private ranges. Use `ipv4_is_private_10()`, `ipv4_is_private_172()`, `ipv4_is_private_192()` (or the  |
| CF-201 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:2, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "check_add_overflow" "net/tquic/masque/connect_udp.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/m | Use `check_add_overflow()` or manually check for overflow: `if (total_len + iov[i].iov_len < total_len) return -EOVERFLO |
| CF-203 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "quic_lb" "net/tquic/lb/quic_lb.c"; make M=net/tquic W=1 (+1 more) | All LB configuration interfaces should require `CAP_NET_ADMIN`.  --- Risk: Fixes in parser/crypto/lifetime code may alte |
| CF-207 | PLAUSIBLE | medium | S1 | 7.00 | file:2, sym:1, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_input" "net/tquic/core/frame.c"; sed -n '358,364p' net/tquic/core/frame.c (+2 more) | Add validation: `if (first_ack_range > largest_ack) return -EPROTO;` Risk: Protocol correctness fixes can shift timing/s |
| CF-208 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:5, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_path_find_by_addr" "net/tquic/tquic_socket.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-209 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_nf" "net/quic/tquic/tquic_nf.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/quic/tquic/tquic_nf.c" | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-210 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_forward" "net/tquic/tquic_forward.c"; make M=net/tquic W=1 (+1 more) | Require `CAP_NET_ADMIN` to enable packet forwarding.  --- Risk: Fixes in parser/crypto/lifetime code may alter packet ac |
| CF-212 | PLAUSIBLE | medium | S1 | 7.00 | file:1, snippet:2 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Clamp `ecn_ce_count` to a reasonable maximum before multiplication: ```c ecn_ce_count = min_t(u64, ecn_ce_count, U32_MAX |
| CF-214 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_timer" "net/quic/tquic/tquic_timer.c"; make M=net/tquic W=1 (+1 more) | ```c u32 shift = min_t(u32, rs->pto_count, 30); pto_duration *= (1ULL << shift); ```  --- Risk: Protocol correctness fix |
| CF-215 | PLAUSIBLE | medium | S1 | 7.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-216 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:3, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "proxied_conn_put" "net/tquic/masque/quic_proxy.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/masque/q | Hold a reference count on each connection while it is in the `to_remove` list (which appears to be partially done via `p |
| CF-221 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_encode_packet_type" "net/tquic/core/connection.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tqui | Use `tquic_encode_packet_type()` for the header byte and `cpu_to_be32(conn->version)` for the version field. Risk: Fixes |
| CF-222 | PLAUSIBLE | medium | S1 | 7.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Use a mutex instead of a spinlock, or use `spin_lock_bh`. Better yet, allocate a per-connection AEAD instance to avoid g |
| CF-223 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:3, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_cid" "net/tquic/core/connection.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/core/connection.c | Copy the CID data into a caller-provided buffer while holding the lock, rather than returning a pointer to shared data.  |
| CF-224 | PLAUSIBLE | medium | S1 | 7.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Construct the algorithm name dynamically from `cert->signature.hash_algo`, e.g., `"pkcs1pad(rsa,sha384)"` or `"pkcs1pad( |
| CF-227 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "spin_lock" "net/quic/tquic/offload/smartnic.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic/offloa | Audit all call sites. If any are reachable from softirq context, change to `spin_lock_bh`. Risk: Locking/ordering change |
| CF-228 | PLAUSIBLE | medium | S1 | 7.00 | file:2, sym:10, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "cpus" "net/tquic/napi.h"; sed -n '112,143p' net/tquic/napi.h (+3 more) | Add `____cacheline_aligned_in_smp` between the RX-side fields (`rx_queue`, `rx_queue_len`, `lock`) and the poll-side fie |
| CF-229 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:2, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_zero_rtt_ticket" "net/tquic/crypto/zero_rtt.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/c | `ticket_store_remove_locked` should only remove from the tree/list. The actual free should happen via `tquic_zero_rtt_pu |
| CF-230 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:4, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_tunnel" "net/tquic/tquic_tunnel.c"; make M=net/tquic W=1 (+1 more) | Check `capable(CAP_NET_ADMIN)` first. If the caller lacks the capability, return `-EPERM` immediately rather than silent |
| CF-232 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_stream_count_by_type" "net/quic/tquic/tquic_stream.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic | Maintain per-type counters in the connection structure, incrementing/decrementing on stream creation/destruction. Risk:  |
| CF-234 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_stream_send_allowed" "net/quic/tquic/core/stream.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/t | Add underflow guards: ```c if (stream->send_offset >= stream->max_send_data) { blocked; return 0; } stream_limit = strea |
| CF-235 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_stream_sendfile" "net/quic/tquic/core/stream.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/quic/t | Read into each page individually, or allocate a contiguous buffer. The current code only works correctly when `chunk <=  |
| CF-238 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_input" "net/tquic/core/connection.c"; make M=net/tquic W=1 (+1 more) | Use `get_random_bytes(&first_byte, 1); first_byte \|= 0x80;` similar to the function in `tquic_input.c:523`. Risk: Proto |
| CF-239 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "quic_proxy" "net/tquic/masque/quic_proxy.c"; make M=net/tquic W=1 (+1 more) | Use `jhash()` or `siphash()` with a per-proxy random key initialized at proxy creation time. SipHash is specifically des |
| CF-241 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:2, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_connect" "net/tquic/tquic_socket.c"; sed -n '260,274p' net/tquic/tquic_socket.c (+2 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-242 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_cong_on_ack" "net/tquic/tquic_input.c"; sed -n '736,738p' net/tquic/tquic_input.c (+2 more) | Cap `first_ack_range` to a reasonable value (e.g., the maximum number of packets in flight) before the multiplication. A |
| CF-243 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:4, lines:4, snippet:2 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_input" "net/quic/tquic/tquic_input.c"; sed -n '642,642p' net/quic/tquic/tquic_input.c (+3 more) | Limit ACK frames per packet to 1 (which RFC 9000 already expects) Risk: Fixes in parser/crypto/lifetime code may alter p |
| CF-244 | PLAUSIBLE | medium | S1 | 7.00 | file:2, sym:1, lines:3, snippet:2 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_output_packet" "net/tquic/tquic_output.c"; sed -n '1248,1250p' net/tquic/tquic_output.c (+4 more) | Save `skb->len` before calling `tquic_output_packet()`. Risk: Fixes in parser/crypto/lifetime code may alter packet acce |
| CF-245 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_migration" "net/tquic/tquic_migration.c"; sed -n '1261,1261p' net/tquic/tquic_migration.c (+4 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-246 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:2, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_weighted_select_path" "net/tquic/multipath/tquic_scheduler.c"; sed -n '817,817p' net/tquic/multipath/tquic_ | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-247 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_process_mp_new_connection_id_frame" "net/tquic/tquic_input.c"; sed -n '2027,2038p' net/tquic/tquic_input.c  | Add encryption level checks for all multipath frame types. They should only be accepted in 1-RTT packets (and possibly 0 |
| CF-248 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:3, lines:3, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_process_packet" "net/quic/tquic/tquic_input.c"; sed -n '723,723p' net/quic/tquic/tquic_input.c (+4 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-249 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:5, lines:7, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_process_retire_connection_id_frame" "net/quic/tquic/tquic_input.c"; sed -n '1045,1045p' net/quic/tquic/tqui | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-250 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, lines:2, snippet:2 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_output" "net/tquic/tquic_output.c"; sed -n '1681,1681p' net/tquic/tquic_output.c (+3 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-251 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:2, lines:5, snippet:2 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_output_packet" "net/tquic/tquic_output.c"; sed -n '1413,1413p' net/tquic/tquic_output.c (+3 more) | Store a reference to `conn` in `tquic_pacing_state` and pass it through. Risk: Protocol correctness fixes can shift timi |
| CF-252 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:5, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_mp_sched_notify_sent" "net/tquic/multipath/tquic_scheduler.c"; sed -n '2158,2164p' net/tquic/multipath/tqui | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-253 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:3, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_net_close_connection" "net/tquic/tquic_diag.c"; sed -n '153,153p' net/tquic/tquic_diag.c (+4 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-254 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:4, lines:4, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "cancel_work_sync" "net/tquic/tquic_tunnel.c"; sed -n '469,469p' net/tquic/tquic_tunnel.c (+4 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-255 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:8, lines:3, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_path" "net/tquic/tquic_timer.c"; sed -n '483,483p' net/tquic/tquic_timer.c (+4 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-256 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:1, lines:4, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_nic_unregister" "net/tquic/offload/smartnic.c"; sed -n '253,253p' net/tquic/offload/smartnic.c (+4 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-257 | PLAUSIBLE | medium | S1 | 7.00 | file:1, sym:4, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "socket" "net/tquic/tquic_socket.c"; sed -n '660,660p' net/tquic/tquic_socket.c (+4 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-087 | SPECULATIVE | low | S0 | 7.00 | sym:1, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_hs_process_server_hello" net/tquic/; make M=net/tquic W=1 (+1 more) | Add `if (p + 2 > end) return -EINVAL;` before the cipher suite read.  --- Risk: Protocol correctness fixes can shift tim |
| CF-088 | SPECULATIVE | low | S0 | 7.00 | sym:2, snippet:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_process_packet" net/tquic/; make M=net/tquic W=1 (+1 more) | Add a bounds check before decoding the packet number: ```c if (ctx.offset + pkt_num_len > len)     return -EINVAL; ```   |
| CF-090 | SPECULATIVE | low | S0 | 7.00 | sym:2, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "ns_capable" net/tquic/; make M=net/tquic W=1 (+1 more) | Replace `&init_net` with `current->nsproxy->net_ns` consistently, and use `ns_capable()` instead of `capable()` to check |
| CF-091 | SPECULATIVE | low | S0 | 7.00 | lines:1 | Concrete source file path (e.g., net/tquic/...); Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-093 | SPECULATIVE | low | S0 | 7.00 | sym:1, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_hs_verify_client_cert" net/tquic/; make M=net/tquic W=1 (+1 more) | `tquic_hs_verify_client_cert` must call `verify_chain(ctx, false)` instead of delegating to the server verification func |
| CF-094 | SPECULATIVE | low | S0 | 7.00 | sym:1, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_input" net/tquic/; make M=net/tquic W=1 (+1 more) | Hold a reference to the socket (`sock_hold(sk)`) under the lock, then call `sk_state_change`, then release the reference |
| CF-103 | SPECULATIVE | low | S0 | 7.00 | snippet:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Use `sock_net(conn->sk)` to enumerate only devices visible in the connection's namespace.  --- Risk: Protocol correctnes |
| CF-105 | SPECULATIVE | low | S0 | 7.00 | sym:2, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_bpm_path_set_state" net/tquic/; rg -rn "spin_lock\\|mutex_lock" net/tquic/ (+2 more) | Use `list_for_each_entry_safe()` is NOT sufficient here since the iteration continues after relock. Instead, collect pat |
| CF-107 | SPECULATIVE | low | S0 | 7.00 | snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | The tunnel must inherit the network namespace from the QUIC connection's socket: `sock_net(tunnel->conn->sk)`.  --- Risk |
| CF-108 | SPECULATIVE | low | S0 | 7.00 | lines:2, snippet:1 | Concrete source file path (e.g., net/tquic/...); Function/struct symbol name at the fault site (+3 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-109 | SPECULATIVE | low | S0 | 7.00 | sym:2, snippet:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_remove_header_protection" net/tquic/; make M=net/tquic W=1 (+1 more) | Move the `pkt_num_len` extraction to AFTER `tquic_remove_header_protection()`: ```c ret = tquic_remove_header_protection |
| CF-111 | SPECULATIVE | low | S0 | 7.00 | lines:1, snippet:1 | Concrete source file path (e.g., net/tquic/...); Function/struct symbol name at the fault site (+3 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-114 | SPECULATIVE | low | S0 | 7.00 | sym:1, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "quic_conn" net/tquic/; make M=net/tquic W=1 (+1 more) | Propagate `sock_net(quic_conn->sk)` to the TCP socket creation.  --- Risk: Protocol correctness fixes can shift timing/s |
| CF-116 | SPECULATIVE | low | S0 | 7.00 | snippet:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Cast to `u64` before multiplication: ```c rate = (u64)count * 1000 Risk: Protocol correctness fixes can shift timing/sta |
| CF-117 | SPECULATIVE | low | S0 | 7.00 | lines:1, snippet:1 | Concrete source file path (e.g., net/tquic/...); Function/struct symbol name at the fault site (+3 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-121 | SPECULATIVE | low | S0 | 7.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "skb_copy_bits" "net/tquic/tquic_input.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tquic_input.c | - Linearize the skb before any parsing/decryption that assumes contiguity, or use `skb_copy_bits()` into a contiguous bu |
| CF-123 | SPECULATIVE | low | S0 | 7.00 | sym:2, snippet:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "ip_local_out" net/tquic/; make M=net/tquic W=1 (+1 more) | Save `skb->len` in a local variable before calling `ip_local_out()`: ```c u32 pkt_len = skb->len; ret = ip_local_out(&in |
| CF-124 | SPECULATIVE | low | S0 | 7.00 | sym:2, snippet:3 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "atomic_inc_return" net/tquic/; rg -rn "spin_lock\\|mutex_lock" net/tquic/ (+2 more) | Either protect these operations with a per-path spinlock, or use `atomic_inc_return()` Risk: Locking/ordering changes ca |
| CF-126 | SPECULATIVE | low | S0 | 7.00 | snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Must use `sock_net(conn->sk)` or propagate the caller's namespace. The tunnel struct should store a `struct net *` refer |
| CF-130 | SPECULATIVE | low | S0 | 7.00 | file:1, sym:6 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "tquic_migrate_auto" "net/tquic/tquic_migration.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tqui | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-133 | SPECULATIVE | low | S0 | 7.00 | sym:3, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_path_put" net/tquic/; make M=net/tquic W=1 (+1 more) | Implement reference counting on `tquic_path` objects. The lookup function should atomically increment the refcount under |
| CF-135 | SPECULATIVE | low | S0 | 7.00 | sym:1, snippet:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_output" net/tquic/; make M=net/tquic W=1 (+1 more) | Use `sock_net(conn->sk)` instead of `&init_net`. The correct network namespace was already computed at line 1681 in the  |
| CF-204 | SPECULATIVE | low | S1 | 7.00 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+2 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Require `CAP_NET_ADMIN` to enable MASQUE proxy functionality.  --- Risk: Fixes in parser/crypto/lifetime code may alter  |
| CF-219 | SPECULATIVE | low | S1 | 7.00 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+2 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Select retry integrity key/nonce based on `conn->version`. Risk: Fixes in parser/crypto/lifetime code may alter packet a |
| CF-262 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:8, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "kfree_rcu" "net/tquic/tquic_netlink.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tquic_netlink.c" (+ | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-265 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:4, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_bonding_ctx" "net/tquic/bond/tquic_bonding.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/bond/t | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-266 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_bpm" "net/tquic/bond/tquic_bpm.c"; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-267 | PLAUSIBLE | low | S1 | 4.90 | sym:1, lines:1, snippet:1 | Concrete source file path (e.g., net/tquic/...); Kernel log / stack trace / error output demonstrating the issue (+2 mor | rg -rn "tquic_nf" net/tquic/; make M=net/tquic W=1 (+1 more) | Use `siphash` with a per-boot random key (from `net_get_random_once`) instead of `jhash` with seed 0. This is the standa |
| CF-268 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:8, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_path_remove_and_free" "net/tquic/tquic_netlink.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tq | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-269 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_bonding_on_loss_detected" "net/tquic/bond/tquic_bonding.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-270 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_failover" "net/tquic/bond/tquic_failover.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-271 | PLAUSIBLE | medium | S1 | 4.90 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+3 more) | rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/fec/fec_decoder.c"; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-272 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_cong_data_cache" "net/tquic/cong/cong_data.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/cong/c | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-274 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "h3_stream" "net/quic/tquic/http3/http3_request.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic/htt | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-276 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_failover_timeout_work" "net/tquic/bond/tquic_failover.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/t | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-279 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:5, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_migration_state" "net/tquic/tquic_migration.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/t | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-280 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:4, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "sockaddr_in6" "net/tquic/tquic_migration.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tquic_migr | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-283 | PLAUSIBLE | low | S1 | 4.90 | file:1, sym:3, lines:4 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_process_frames" "net/quic/tquic/tquic_input.c"; sed -n '1900,1914p' net/quic/tquic/tquic_input.c (+3 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-284 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_pm_discover_addresses" "net/tquic/pm/path_manager.c"; make M=net/tquic W=1 (+1 more) | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-285 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_path_handle_response" "net/tquic/pm/path_validation.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tqu | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-286 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "qpack_encoder" "net/quic/tquic/http3/qpack_encoder.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-287 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:1, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_fec_decode_repair_frame" "net/tquic/fec/fec_decoder.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-289 | PLAUSIBLE | medium | S1 | 4.90 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+3 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-292 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_stateless_reset" "net/tquic/tquic_stateless_reset.c"; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-294 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_bonding_update_state" "net/tquic/bond/tquic_bonding.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tqu | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-295 | PLAUSIBLE | low | S1 | 4.90 | file:2, sym:2, lines:4 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_sched" "net/tquic/multipath/tquic_scheduler.c"; sed -n '40,40p' net/tquic/multipath/tquic_scheduler.c (+3 m | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-297 | PLAUSIBLE | low | S1 | 4.90 | file:1, sym:2, lines:2 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_stream_check_flow_control" "net/quic/tquic/tquic_stream.c"; sed -n '690,690p' net/quic/tquic/tquic_stream.c | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-298 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_stream_ext" "net/quic/tquic/core/stream.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic/core | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-299 | PLAUSIBLE | low | S1 | 4.90 | file:1, sym:1, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_udp_recv" "net/tquic/tquic_input.c"; sed -n '2916,2932p' net/tquic/tquic_input.c (+2 more) | Only check for stateless reset AFTER regular decryption fails (RFC 9000 Section 10.3.1 recommends this order). The check |
| CF-301 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "sock_net" "net/tquic/cong/tquic_cong.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/cong/tquic_con | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-302 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:5, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "refcount_set" "net/tquic/tquic_zerocopy.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tquic_zeroc | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-303 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_path" "net/tquic/tquic_migration.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tquic_migrat | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-305 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_loss_tracker" "net/tquic/cong/tquic_cong.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/cong/tqu | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-306 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:4, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_connect" "net/tquic/tquic_socket.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tquic_socket | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-307 | PLAUSIBLE | medium | S1 | 4.90 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_select_weighted" "net/tquic/bond/bonding.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-258 | SPECULATIVE | low | S1 | 4.90 | sym:3, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_output_packet" net/tquic/; make M=net/tquic W=1 (+1 more) | Save `skb->len` before calling `tquic_output_packet()`.  --- Risk: Protocol correctness fixes can shift timing/state-mac |
| CF-259 | SPECULATIVE | low | S1 | 4.90 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-260 | SPECULATIVE | low | S1 | 4.90 | sym:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | rg -rn "tquic_zero_rtt_derive_secret" net/tquic/; make M=net/tquic W=1 (+1 more) | The ClientHello hash must be included in the key derivation. Use `tquic_zero_rtt_derive_secret` (which does accept `clie |
| CF-261 | SPECULATIVE | low | S1 | 4.90 | file:1, sym:4 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "copy_from_sockptr" "net/tquic/tquic_socket.c"; make M=net/tquic W=1 (+1 more) | - Move `copy_from_sockptr(&val, ...)` inside the integer-valued cases only. Risk: Protocol correctness fixes can shift t |
| CF-263 | SPECULATIVE | low | S1 | 4.90 | sym:1, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_input" net/tquic/; make M=net/tquic W=1 (+1 more) | Cap `first_ack_range` to a reasonable value (e.g., the maximum number of packets in flight) before the multiplication. A |
| CF-264 | SPECULATIVE | low | S1 | 4.90 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-273 | SPECULATIVE | low | S1 | 4.90 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "h3_request_send_headers" "net/quic/tquic/http3/http3_request.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/ | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-275 | SPECULATIVE | low | S1 | 4.90 | file:3, sym:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "ktime_get" "net/tquic/napi.c"; make M=net/tquic W=1 (+1 more) | Read the timestamp once at the start of packet processing and pass it through the context. The `tquic_rx_ctx` struct alr |
| CF-277 | SPECULATIVE | low | S1 | 4.90 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "attempt_xor_recovery" "net/tquic/fec/fec_decoder.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-278 | SPECULATIVE | low | S1 | 4.90 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "qpack_header_list_add" "net/quic/tquic/http3/qpack.c"; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-281 | SPECULATIVE | low | S1 | 4.90 | sym:2, snippet:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_input" net/tquic/; make M=net/tquic W=1 (+1 more) | Add encryption level checks for all multipath frame types. They should only be accepted in 1-RTT packets (and possibly 0 |
| CF-282 | SPECULATIVE | low | S1 | 4.90 | file:3, sym:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "already" "net/tquic/tquic_output.c"; make M=net/tquic W=1 (+1 more) | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-288 | SPECULATIVE | low | S1 | 4.90 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "generate_rs_repair" "net/tquic/fec/fec_encoder.c"; make M=net/tquic W=1 (+1 more) | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-290 | SPECULATIVE | low | S1 | 4.90 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-291 | SPECULATIVE | low | S1 | 4.90 | sym:4 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | rg -rn "tquic_path_remove" net/tquic/; rg -rn "spin_lock\\|mutex_lock" net/tquic/ (+2 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-293 | SPECULATIVE | low | S1 | 4.90 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-296 | SPECULATIVE | low | S1 | 4.90 | sym:3, snippet:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_output_packet" net/tquic/; make M=net/tquic W=1 (+1 more) | Store a reference to `conn` in `tquic_pacing_state` and pass it through. Risk: Protocol correctness fixes can shift timi |
| CF-300 | SPECULATIVE | low | S1 | 4.90 | sym:2, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_udp_recv" net/tquic/; make M=net/tquic W=1 (+1 more) | Only check for stateless reset AFTER regular decryption fails (RFC 9000 Section 10.3.1 recommends this order). The check |
| CF-304 | SPECULATIVE | low | S1 | 4.90 | file:1, sym:5 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "plan" "net/tquic/test/packet_test.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/test/packet_test.c" ( | - Add tests that build a packet with header protection applied, run HP unprotect, and then validate pn_len and key_phase |
| CF-308 | SPECULATIVE | low | S1 | 4.90 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "weighted_get_path" "net/tquic/multipath/sched_weighted.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/ | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-309 | CERTIFIED | high | S2 | 4.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "detected" "net/tquic/crypto/zero_rtt.c"; make M=net/tquic W=1 (+1 more) | This is an inherent limitation of bloom filters. Document this as a known limitation. Consider augmenting with a small e |
| CF-310 | CERTIFIED | high | S2 | 4.00 | file:1, sym:4, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "alloc_skb" "net/tquic/security/quic_exfil.c"; make M=net/tquic W=1 (+1 more) | Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Wat |
| CF-311 | CERTIFIED | high | S2 | 4.00 | file:1, sym:1, lines:2 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_eku_request" "net/tquic/crypto/extended_key_update.c"; sed -n '440,440p' net/tquic/crypto/extended_key_upda | Keep the lock held through request allocation and insertion, or use an atomic increment for the request ID. Risk: Lockin |
| CF-312 | CERTIFIED | high | S2 | 4.00 | file:1, sym:2, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "memzero_explicit" "net/tquic/crypto/header_protection.c"; make M=net/tquic W=1 (+1 more) | Ensure `memzero_explicit()` is called on the mask buffer in all return paths, including error paths. Risk: Fixes in pars |
| CF-313 | CERTIFIED | high | S2 | 4.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "client" "net/tquic/http3/http3_conn.c"; make M=net/tquic W=1 (+1 more) | Maintain a running counter of push entries instead of counting on demand. Risk: Fixes in parser/crypto/lifetime code may |
| CF-314 | CERTIFIED | high | S2 | 4.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "frames" "net/tquic/http3/http3_frame.c"; make M=net/tquic W=1 (+1 more) | Consider reducing the default limit to 1MB or making it configurable. Most HTTP/3 frames (HEADERS, SETTINGS, GOAWAY) sho |
| CF-315 | CERTIFIED | high | S2 | 4.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "processing" "net/tquic/http3/http3_frame.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/http3/http3_fr | Ensure the input buffer is exclusively owned during parsing, or perform length validation inline during the single-pass  |
| CF-316 | CERTIFIED | high | S2 | 4.00 | file:1, sym:4 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "buffer" "net/tquic/crypto/cert_verify.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/crypto/cert_v | Validate that `cert->tbs + cert->tbs_len <= data + total_len` before computing `remaining`. Risk: Fixes in parser/crypto |
| CF-318 | CERTIFIED | high | S2 | 4.00 | file:1, sym:4, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "bandwidth" "net/tquic/tquic_migration.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tquic_migrati | Reorder operations to divide before multiplying, or cap intermediate values. Risk: Fixes in parser/crypto/lifetime code  |
| CF-319 | CERTIFIED | high | S2 | 4.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_stateless_reset_generate_token" "net/tquic/tquic_stateless_reset.c"; make M=net/tquic W=1 (+1 more) | Pre-allocate a per-CPU or global HMAC transform and reuse it. Risk: Fixes in parser/crypto/lifetime code may alter packe |
| CF-320 | CERTIFIED | high | S2 | 4.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "crypto_aead_setkey" "net/tquic/crypto/hw_offload.c"; make M=net/tquic W=1 (+1 more) | Set the key once during context initialization and only re-set on key update. Risk: Fixes in parser/crypto/lifetime code |
| CF-321 | CERTIFIED | high | S2 | 4.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "buffer" "net/tquic/diag/qlog.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/diag/qlog.c" (+2 more) | Either implement a true lock-free ring buffer (using `smp_store_release`/`smp_load_acquire` pairs) or document the locki |
| CF-322 | CERTIFIED | high | S2 | 4.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "json" "net/tquic/diag/qlog.c"; make M=net/tquic W=1 (+1 more) | Implement JSON string escaping for all string values emitted in qlog JSON output. Risk: Protocol correctness fixes can s |
| CF-323 | CERTIFIED | high | S2 | 4.00 | file:2, sym:5 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "chain" "net/tquic/http3/qpack_encoder.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/http3/qpack_e | Allocate these buffers dynamically with `kmalloc(GFP_ATOMIC)` or use a pre-allocated per-connection buffer. Risk: Fixes  |
| CF-324 | CERTIFIED | high | S2 | 4.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "decoder" "net/tquic/http3/qpack.c"; make M=net/tquic W=1 (+1 more) | Replace with a 256-entry lookup table or state-machine-based decoder (standard approach for HPACK/QPACK Huffman). Risk:  |
| CF-325 | CERTIFIED | high | S2 | 4.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "behavior" "net/tquic/http3/qpack.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/http3/qpack.c" (+2 | Add a check: `if (shift > 62) return -H3_ERR_QPACK_DECOMPRESSION_FAILED;` Risk: Fixes in parser/crypto/lifetime code may |
| CF-326 | CERTIFIED | high | S2 | 4.00 | file:1, sym:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "isdigit" "net/tquic/crypto/cert_verify.c"; make M=net/tquic W=1 (+1 more) | Add `isdigit()` checks for all time component characters before conversion. Risk: Fixes in parser/crypto/lifetime code m |
| CF-327 | CERTIFIED | high | S2 | 4.00 | file:1, sym:4 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "kfree" "net/tquic/crypto/handshake.c"; make M=net/tquic W=1 (+1 more) | Use `kfree_sensitive()` or call `memzero_explicit()` on the transcript buffer before freeing. Risk: Fixes in parser/cryp |
| CF-328 | CERTIFIED | high | S2 | 4.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "none" "net/tquic/tquic_tunnel.c"; make M=net/tquic W=1 (+1 more) | Missing fix suggestion in source text. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify  |
| CF-348 | CERTIFIED | high | S2 | 4.00 | file:1, sym:2, lines:3, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_proc" "net/quic/tquic/tquic_proc.c"; sed -n '414,414p' net/quic/tquic/tquic_proc.c (+4 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-351 | CERTIFIED | high | S2 | 4.00 | file:1, sym:4, lines:5, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "definition" "net/tquic/tquic_socket.c"; sed -n '840,840p' net/tquic/tquic_socket.c (+3 more) | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-352 | CERTIFIED | high | S2 | 4.00 | file:1, lines:1, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '2513,2513p' net/quic/tquic/core/transport_params.c; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/quic/tqu | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-353 | CERTIFIED | high | S2 | 4.00 | file:1, lines:1, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '370,370p' net/tquic/core/frame.c; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-361 | CERTIFIED | high | S2 | 4.00 | file:1, lines:1, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '2319,2319p' net/tquic/crypto/cert_verify.c; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-362 | CERTIFIED | high | S2 | 4.00 | file:1, lines:1, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '502,502p' net/tquic/core/connection.c; make M=net/tquic W=1 (+1 more) | Perform the sequence number increment inside the spinlock, or use atomic operations.  --- Risk: Locking/ordering changes |
| CF-363 | CERTIFIED | high | S2 | 4.00 | file:2, sym:4, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "spin_lock_bh" "net/tquic/tquic_input.c"; sed -n '917,934p' net/tquic/tquic_input.c (+3 more) | Consider RCU-protected RB-tree for read-side lookups, or use a lockless hash table for the common case of looking up an  |
| CF-367 | CERTIFIED | high | S2 | 4.00 | file:1, lines:2, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '897,897p' net/quic/tquic/bond/cong_coupled.c; sed -n '949,949p' net/quic/tquic/bond/cong_coupled.c (+2 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-370 | CERTIFIED | high | S2 | 4.00 | file:1, sym:1, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_proc" "net/quic/tquic/tquic_proc.c"; sed -n '572,589p' net/quic/tquic/tquic_proc.c (+3 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-372 | CERTIFIED | high | S2 | 4.00 | file:2, lines:1, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '111,115p' net/tquic/fec/fec_encoder.c; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/fec/fec_encoder | Use slab caches for symbol structs and data buffers. Pre-allocate symbol arrays per block. Risk: Fixes in parser/crypto/ |
| CF-373 | CERTIFIED | high | S2 | 4.00 | file:2, sym:4, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "list_add_tail" "net/tquic/fec/fec_encoder.c"; sed -n '275,283p' net/tquic/fec/fec_encoder.c (+3 more) | Remove `block->lock` when the block is only accessed under `enc->lock`, or redesign to avoid nesting. Risk: Locking/orde |
| CF-374 | CERTIFIED | high | S2 | 4.00 | file:1, lines:1, snippet:2 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '576,576p' net/quic/tquic/fec/fec_encoder.c; make M=net/tquic W=1 (+1 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-383 | CERTIFIED | high | S2 | 4.00 | file:1, sym:1, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_zero_rtt_derive_keys" "net/tquic/crypto/zero_rtt.c"; sed -n '662,662p' net/tquic/crypto/zero_rtt.c (+3 more | Add `if (ret) memzero_explicit(keys, sizeof(*keys));` before the `out:` label, or zeroize in the `out:` path when `ret ! |
| CF-400 | CERTIFIED | high | S2 | 4.00 | file:2, sym:5, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "__skb_dequeue" "net/tquic/tquic_output.c"; sed -n '1396,1421p' net/tquic/tquic_output.c (+3 more) | Dequeue a batch of packets under a single lock hold, then send them all without the lock. Risk: Locking/ordering changes |
| CF-404 | CERTIFIED | high | S2 | 4.00 | file:1, sym:1, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hp_key" "net/tquic/crypto/header_protection.c"; sed -n '164,164p' net/tquic/crypto/header_protection.c (+4  | Pre-allocate the `skcipher_request` in the `tquic_hp_key` structure during key setup. Use a per-CPU or per-connection pr |
| CF-405 | CERTIFIED | high | S2 | 4.00 | file:1, lines:2, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '708,708p' net/tquic/crypto/hw_offload.c; sed -n '703,703p' net/tquic/crypto/hw_offload.c (+2 more) | Allocate a single buffer sized for the largest packet in the batch, or use a pre-allocated per-CPU bounce buffer. Altern |
| CF-409 | CERTIFIED | high | S2 | 4.00 | file:1, sym:2, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_dbg" "net/tquic/tquic_socket.c"; sed -n '1202,1202p' net/tquic/tquic_socket.c (+2 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-410 | CERTIFIED | high | S2 | 4.00 | file:1, sym:3, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "sk_buff" "net/quic/tquic/tquic_udp.c"; sed -n '1303,1303p' net/quic/tquic/tquic_udp.c (+3 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-417 | CERTIFIED | high | S2 | 4.00 | file:2, sym:3, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "add_key" "net/tquic/offload/smartnic.c"; sed -n '326,328p' net/tquic/offload/smartnic.c (+3 more) | Use a per-connection lock or a mutex (key operations are not in the data path and can sleep). Risk: Locking/ordering cha |
| CF-421 | CERTIFIED | high | S2 | 4.00 | file:4, sym:2, lines:3, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_sysctl" "net/tquic/transport/tcp_fallback.c"; sed -n '843,843p' net/tquic/transport/tcp_fallback.c (+3 more | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-427 | CERTIFIED | high | S2 | 4.00 | file:1, sym:2, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_conn_create" "net/quic/tquic/core/quic_connection.c"; sed -n '495,501p' net/quic/tquic/core/quic_connection | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-438 | CERTIFIED | high | S2 | 4.00 | file:2, sym:4, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "atomic_t" "net/tquic/tquic_zerocopy.c"; sed -n '58,59p' net/tquic/tquic_zerocopy.c (+3 more) | Change to `refcount_t` and use `refcount_inc()` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance l |
| CF-317 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "del_timer_sync" "net/tquic/diag/path_metrics.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/diag/p | Use `del_timer_sync()` in `tquic_metrics_unsubscribe_conn()` to ensure the timer callback has completed before freeing t |
| CF-330 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, lines:2 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "additional_addr_add" "net/tquic/core/additional_addresses.c"; sed -n '188,188p' net/tquic/core/additional_address | Keep the lock held across the check-and-insert operation, or use a two-phase approach with lock re-check after allocatio |
| CF-331 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Check denominator and use u64 for multiplication.  --- Risk: Protocol correctness fixes can shift timing/state-machine b |
| CF-332 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/crypto/handshake.c"; make M=net/tquic W=1 (+1 more) | Add a `u32 buf_len` parameter or document the 8-byte minimum requirement.  --- Risk: Fixes in parser/crypto/lifetime cod |
| CF-333 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-334 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "kmem_cache_create" "net/tquic/core/stream.c"; make M=net/tquic W=1 (+1 more) | Use a global slab cache shared across all stream managers, or include a unique identifier in the cache name. Risk: Proto |
| CF-335 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "ring_index" "net/tquic/core/receive_timestamps.c"; make M=net/tquic W=1 (+1 more) | Add a guard: `if (size == 0) return 0;` and use modular arithmetic: `return ((idx % (s32)size) + size) % size;` Risk: Fi |
| CF-336 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "lock_sock" "net/tquic/tquic_socket.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tquic_socket.c" (+2  | Access the accept queue under `lock_sock()` alone without the additional spinlock. Risk: Locking/ordering changes can ca |
| CF-337 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_cong" "net/quic/tquic/cong/tquic_cong.c"; make M=net/tquic W=1 (+1 more) | Clamp `ecn_ce_count` to a realistic maximum before multiplication.  --- Risk: Protocol correctness fixes can shift timin |
| CF-338 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_fc_conn_data_sent" "net/tquic/core/flow_control.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/c | Provide a combined `tquic_fc_conn_try_send()` that atomically checks and commits. Risk: Locking/ordering changes can cau |
| CF-339 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_derive_early_secrets" "net/tquic/crypto/handshake.c"; make M=net/tquic W=1 (+1 more) | Move `memzero_explicit` after the binder key is no longer needed, or into an error/cleanup path.  --- Risk: Fixes in par |
| CF-340 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_hs_generate_client_hello" "net/tquic/crypto/handshake.c"; make M=net/tquic W=1 (+1 more) | Add `memzero_explicit(hkdf_label, sizeof(hkdf_label));` before return.  --- Risk: Fixes in parser/crypto/lifetime code m |
| CF-341 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_process_certificate_verify" "net/tquic/crypto/handshake.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcp | Compute the required size dynamically: `content_size = 64 + 33 + 1 + hash_len` and validate it fits, or allocate dynamic |
| CF-342 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_process_certificate" "net/tquic/crypto/handshake.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net | ```c if (cert_len > TLS_CERT_MAX_LEN)     return -EINVAL; ```  --- Risk: Fixes in parser/crypto/lifetime code may alter  |
| CF-343 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_process_server_hello" "net/tquic/crypto/handshake.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tq | Move to file scope alongside the other static const arrays (like `tls12_downgrade_sentinel`). Risk: Locking/ordering cha |
| CF-344 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_migrate_validate_all_additional" "net/tquic/tquic_migration.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock"  | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-345 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:4, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_dump_ctx" "net/tquic/tquic_netlink.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-346 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_path_compute_score" "net/tquic/tquic_migration.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-347 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_path_is_degraded" "net/tquic/tquic_migration.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-349 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_process_stream_frame" "net/tquic/tquic_input.c"; make M=net/tquic W=1 (+1 more) | When FIN is received, record `stream->final_size = offset + length`. On subsequent data, verify `offset + length <= stre |
| CF-350 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_sendmsg_datagram" "net/tquic/tquic_socket.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-355 | PLAUSIBLE | medium | S2 | 4.00 | file:2, sym:4 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "count" "net/tquic/napi.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/napi.c" (+2 more) | Remove `rx_queue_len` atomic. Use `skb_queue_len(&tn->rx_queue)` when the length is needed (it reads `qlen` from the que |
| CF-356 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-357 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Use 64-bit seeds (siphash instead of jhash) and rotate seeds during bucket rotation, hashing any remaining entries into  |
| CF-358 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:5, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "delayed_work" "net/tquic/bond/tquic_bpm.c"; make M=net/tquic W=1 (+1 more) | Add a `struct tquic_connection *conn` reference with proper refcounting, and verify all work items are cancelled during  |
| CF-359 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-360 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-364 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-365 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-366 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_connection" "net/tquic/core/connection.c"; make M=net/tquic W=1 (+1 more) | Check `conn->state` and early-return for DRAINING/CLOSED states. Risk: Protocol correctness fixes can shift timing/state |
| CF-368 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "quic_exfil" "net/tquic/security/quic_exfil.c"; make M=net/tquic W=1 (+1 more) | Fill decoy packets with cryptographically random data, or better yet, use the same encryption layer as real packets so d |
| CF-369 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-371 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_exfil_ctx_set_level" "net/tquic/security/quic_exfil.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net | Acquire `ctx->lock` around the destroy/init sequence, or use RCU to swap in a new configuration atomically. Risk: Fixes  |
| CF-375 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "gaussian_random" "net/tquic/security/quic_exfil.c"; make M=net/tquic W=1 (+1 more) | If Gaussian jitter is required, use a proper implementation. For kernel context where floating-point is unavailable, con |
| CF-376 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "h3_stream_recv_data" "net/quic/tquic/http3/http3_request.c"; make M=net/tquic W=1 (+1 more) | Validate that `ret >= 2` (minimum varint frame header) before calling the parser, or zero-initialize `frame_hdr`.  --- R |
| CF-377 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "h3_stream_recv_headers" "net/quic/tquic/http3/http3_request.c"; make M=net/tquic W=1 (+1 more) | Add: `if (payload_len > H3_MAX_FRAME_PAYLOAD_SIZE) return -EMSGSIZE;`  --- Risk: Protocol correctness fixes can shift ti |
| CF-378 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "quic_crypto" "net/tquic/core/quic_crypto.c"; make M=net/tquic W=1 (+1 more) | Pass the known local CID length to the unprotection function. The receiver knows the length of its own CIDs.  --- Risk:  |
| CF-379 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:4 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "get_random_bytes" "net/tquic/tquic_stateless_reset.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tqui | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-380 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-381 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-384 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Use `KMEM_CACHE` macro or create caches at module init time (shared across all connections), not per-connection. Or use  |
| CF-385 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/lb/quic_lb.c"; make M=net/tquic W=1 (+1 more) | Use a separate byte position for the round number that does not conflict with data, or XOR the round number rather than  |
| CF-386 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Detect counter wrap and refuse to generate nonces, or use a larger state that combines counter with additional randomnes |
| CF-387 | PLAUSIBLE | medium | S2 | 4.00 | file:2, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "bbrv3_update_bw" "net/tquic/cong/bbrv3.c"; make M=net/tquic W=1 (+1 more) | Pass the timestamp from the caller rather than calling `ktime_get_ns()` again. Risk: Protocol correctness fixes can shif |
| CF-388 | PLAUSIBLE | medium | S2 | 4.00 | file:2, sym:4, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "area" "net/tquic/io_uring.c"; make M=net/tquic W=1 (+1 more) | Use `io_alloc_async_data()` or embed the async data in the `io_kiocb` command data area (the `io_kiocb_to_cmd()` pattern |
| CF-389 | PLAUSIBLE | medium | S2 | 4.00 | file:2, sym:6, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "alloc_skb" "net/tquic/tquic_zerocopy.c"; make M=net/tquic W=1 (+1 more) | Batch skb allocation using `alloc_skb_with_frags()` or `napi_alloc_skb()` for bulk allocation. Use the path MTU instead  |
| CF-390 | PLAUSIBLE | medium | S2 | 4.00 | file:2, sym:6, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "chunks" "net/tquic/tquic_zerocopy.c"; make M=net/tquic W=1 (+1 more) | Use larger chunks (up to GSO segment size) and coalesce page fragments into fewer skbs. Risk: Protocol correctness fixes |
| CF-391 | PLAUSIBLE | medium | S2 | 4.00 | sym:8, lines:2, snippet:1 | Concrete source file path (e.g., net/tquic/...); Kernel log / stack trace / error output demonstrating the issue | rg -rn "tquic_add_stats" net/tquic/; make M=net/tquic W=1 (+1 more) | Acceptable overhead if using per-CPU counters. Verify the macro implementation uses `this_cpu_add` rather than atomics.  |
| CF-392 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hyst_state_names" "net/tquic/bond/tquic_failover.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tq | Use `ARRAY_SIZE(tquic_hyst_state_names)` bounds check before indexing. Risk: Fixes in parser/crypto/lifetime code may al |
| CF-393 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_connect_ip_inject_packet" "net/tquic/masque/connect_ip.c"; make M=net/tquic W=1 (+1 more) | Set `skb->dev` to the tunnel's virtual network device (`iface->net_device` from the tunnel's interface structure).  ---  |
| CF-394 | PLAUSIBLE | medium | S2 | 4.00 | file:2, sym:4 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "line" "net/tquic/napi.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/napi.c" (+2 more) | Remove the redundant `rx_queue_len` atomic (as noted above). This reduces to the minimum of one lock acquisition per enq |
| CF-395 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "rcu_assign_pointer" "net/tquic/pm/nat_keepalive.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/pm/nat_ | Access `state->config` under `state->lock`, or use `rcu_dereference()`/`rcu_assign_pointer()` for RCU-protected access.  |
| CF-396 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_nl_cmd_path_dump" "net/tquic/tquic_netlink.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tq | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-397 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_pm_nl_add_path" "net/tquic/pm/pm_netlink.c"; make M=net/tquic W=1 (+1 more) | Ensure all PM netlink ops have `.flags = GENL_ADMIN_PERM` in the `genl_ops` array, or add explicit `capable(CAP_NET_ADMI |
| CF-398 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "http_datagram_flow" "net/tquic/masque/http_datagram.c"; make M=net/tquic W=1 (+1 more) | Add a configurable `max_flows` limit to the manager and reject new flow creation when the limit is reached.  --- Risk: F |
| CF-399 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_token" "net/tquic/tquic_token.c"; make M=net/tquic W=1 (+1 more) | Implement a token replay cache (e.g., a bloom filter or hash set of recently seen token nonces) similar to the 0-RTT ant |
| CF-401 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Return a sentinel value or use an error pointer pattern (pass pn by reference, return error code).  --- Risk: Protocol c |
| CF-402 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-403 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Rename the inner loop variable. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against |
| CF-407 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_socket" "net/quic/tquic/tquic_socket.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic/tquic_s | Use `READ_ONCE(tsk->accept_queue_len)`. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if  |
| CF-408 | PLAUSIBLE | medium | S2 | 4.00 | file:3, snippet:2 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-411 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_connect_ip_request_address" "net/tquic/masque/connect_ip.c"; make M=net/tquic W=1 (+1 more) | Change the return type to `s64` or return 0 for success and pass the request_id through an output pointer parameter.  -- |
| CF-412 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Use `siphash` instead of `jhash` for address validation hashing.  --- Risk: Fixes in parser/crypto/lifetime code may alt |
| CF-413 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/crypto/cert_verify.c"; make M=net/tquic W=1 (+1 more) | Reject SAN DNS names containing NUL bytes (0x00). Add: `if (memchr(p + 1 + hdr_len, 0, content_len)) continue;`  --- Ris |
| CF-414 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_scheduler" "net/tquic/multipath/tquic_scheduler.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/m | Move the state check inside the spinlock-protected region. Risk: Locking/ordering changes can cause deadlocks or through |
| CF-415 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Pass the connection's `sock_net(conn->sk)` to the security event reporting function.  --- Risk: Fixes in parser/crypto/l |
| CF-416 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-418 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-419 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Use `scnprintf` consistently (returns actual bytes written, not hypothetical) or check `if (len >= buflen) return;` afte |
| CF-420 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_stateless_reset_get_static_key" "net/tquic/tquic_stateless_reset.c"; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-422 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_sysctl" "net/tquic/tquic_sysctl.c"; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-423 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:2 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Register a proper sysctl table with `proc_dointvec_minmax` handlers and range limits, or add range validation in the acc |
| CF-424 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Use `crypto_memneq` for the comparison.  --- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logi |
| CF-425 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:3, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "memzero_explicit" "net/tquic/tquic_token.c"; make M=net/tquic W=1 (+1 more) | Zeroize `old_key->key` with `memzero_explicit()` and set `old_key->valid = false` inside this function, making the API s |
| CF-426 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:6, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "init_work" "net/quic/tquic/tquic_cid.c"; make M=net/tquic W=1 (+1 more) | Call `del_timer_sync(&pool->rotation_timer)` before `kfree(pool)`.  --- Risk: Protocol correctness fixes can shift timin |
| CF-428 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_fc_reserve_credit" "net/quic/tquic/core/flow_control.c"; make M=net/tquic W=1 (+1 more) | Implement actual atomic reservation by deducting credit in reserve and adding back in release.  --- Risk: Protocol corre |
| CF-429 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "kfree_sensitive" "net/quic/tquic/tquic_handshake.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic/t | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-430 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_output_flush" "net/quic/tquic/tquic_output.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic/t | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-431 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_retry" "net/quic/tquic/tquic_retry.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic/tquic_ret | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-432 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_stream_memory_pressure" "net/quic/tquic/core/stream.c"; make M=net/tquic W=1 (+1 more) | Add `tquic_stream_ext_free(mgr, stream->ext);` before `kfree(stream);`.  --- Risk: Protocol correctness fixes can shift  |
| CF-433 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_stream_trigger_output" "net/quic/tquic/tquic_stream.c"; make M=net/tquic W=1 (+1 more) | Add underflow guard: `inflight = (path->stats.tx_bytes > path->stats.acked_bytes) ? path->stats.tx_bytes - path->stats.a |
| CF-434 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_stream_write" "net/quic/tquic/core/stream.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic/co | Copy data to a pre-allocated buffer outside the lock, then enqueue under the lock. Or use a mutex instead of spinlock fo |
| CF-435 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_path" "net/tquic/core/connection.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/core/connection. | Limit pending challenges to a reasonable maximum (e.g., 10).  --- Risk: Locking/ordering changes can cause deadlocks or  |
| CF-436 | PLAUSIBLE | medium | S2 | 4.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Check that the VN version list does NOT contain the version the client originally tried.  --- Risk: Protocol correctness |
| CF-439 | PLAUSIBLE | medium | S2 | 4.00 | file:1, lines:1, snippet:3 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue (+1 more) | sed -n '271,271p' net/quic/tquic/tquic_migration.c; make M=net/tquic W=1 (+1 more) | Use `atomic64_add_return` to atomically check-and-add, or serialize under a spinlock Risk: Locking/ordering changes can  |
| CF-440 | PLAUSIBLE | medium | S2 | 4.00 | file:1, lines:2, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue (+1 more) | sed -n '186,186p' net/tquic/crypto/cert_verify.c; sed -n '155,155p' net/tquic/crypto/cert_verify.c (+2 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-441 | PLAUSIBLE | medium | S2 | 4.00 | file:1, lines:1, snippet:2 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue (+1 more) | sed -n '3172,3173p' net/tquic/tquic_input.c; make M=net/tquic W=1 (+1 more) | Instead of silently truncating, reject the coalesced packet entirely when the claimed length exceeds remaining data: ``` |
| CF-442 | PLAUSIBLE | medium | S2 | 4.00 | file:1, lines:4, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue (+1 more) | sed -n '1008,1015p' net/quic/tquic/tquic_netlink.c; sed -n '993,993p' net/quic/tquic/tquic_netlink.c (+2 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-443 | PLAUSIBLE | medium | S2 | 4.00 | file:1, lines:1, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue (+1 more) | sed -n '285,285p' net/quic/tquic/fec/fec_decoder.c; make M=net/tquic W=1 (+1 more) | Use a bitmap or hash set for symbol ID dedup within blocks Risk: Locking/ordering changes can cause deadlocks or through |
| CF-444 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, lines:3, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "edf_select_path" "net/tquic/sched/deadline_scheduler.c"; sed -n '591,591p' net/tquic/sched/deadline_scheduler.c ( | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-445 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:2, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "timespec64" "net/tquic/tquic_input.c"; sed -n '1471,1471p' net/tquic/tquic_input.c (+3 more) | Use a typed union or dedicated struct for `skb->cb` usage, documented per frame type. Risk: Protocol correctness fixes c |
| CF-446 | PLAUSIBLE | medium | S2 | 4.00 | file:1, lines:4, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue (+1 more) | sed -n '1623,1623p' net/quic/tquic/tquic_input.c; sed -n '1652,1652p' net/quic/tquic/tquic_input.c (+2 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-447 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_fc_stream_can_send" "net/quic/tquic/core/flow_control.c"; sed -n '291,292p' net/quic/tquic/core/flow_contro | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-448 | PLAUSIBLE | medium | S2 | 4.00 | file:1, lines:1, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue (+1 more) | sed -n '768,768p' net/quic/tquic/tquic_socket.c; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-449 | PLAUSIBLE | medium | S2 | 4.00 | file:1, lines:2, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue (+1 more) | sed -n '942,942p' net/quic/tquic/tquic_socket.c; sed -n '942,951p' net/quic/tquic/tquic_socket.c (+3 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-450 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_recv_datagram" "net/tquic/tquic_output.c"; sed -n '2706,2743p' net/tquic/tquic_output.c (+3 more) | Add a retry counter to prevent excessive looping: ```c int retries = 0; ... retry:     if (++retries > 3) return -EAGAIN |
| CF-451 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:6, lines:4, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_sched_ops" "net/quic/tquic/tquic_socket.c"; sed -n '848,848p' net/quic/tquic/tquic_socket.c (+4 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-452 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:4, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "rcu_assign_pointer" "net/tquic/tquic_migration.c"; sed -n '848,848p' net/tquic/tquic_migration.c (+3 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-453 | PLAUSIBLE | medium | S2 | 4.00 | file:1, sym:1, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_dbg" "net/tquic/tquic_input.c"; sed -n '473,477p' net/tquic/tquic_input.c (+2 more) | Either remove the per-version debug line or cap the number of logged versions. Risk: Protocol correctness fixes can shif |
| CF-329 | SPECULATIVE | low | S2 | 4.00 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+2 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Perform the size check and push atomically under a lock, or use an atomic counter with compare-and-swap. Risk: Locking/o |
| CF-354 | SPECULATIVE | low | S2 | 4.00 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+2 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Use a separate periodic cleanup timer rather than inline cleanup, or maintain a time-ordered list for efficient expirati |
| CF-382 | SPECULATIVE | low | S2 | 4.00 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+2 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-406 | SPECULATIVE | low | S2 | 4.00 | sym:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+2 more) | rg -rn "tquic_input" net/tquic/; make M=net/tquic W=1 (+1 more) | Split path stats into `____cacheline_aligned` RX and TX sections, or use per-CPU counters for path stats. Risk: Protocol |
| CF-437 | SPECULATIVE | low | S2 | 4.00 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+2 more) | rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/quic/tquic/http3/webtransport.c"; make M=net/tquic W=1 (+1 more) | Audit all callers of session-returning functions and ensure every get has a matching put.  --- Risk: Fixes in parser/cry |
| CF-455 | PLAUSIBLE | medium | S2 | 2.80 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+3 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-458 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "mul_u64_u64_div" "net/tquic/bond/cong_coupled.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-460 | PLAUSIBLE | low | S2 | 2.80 | file:1, lines:1 | Code snippet proving the vulnerable pattern; Function/struct symbol name at the fault site (+3 more) | sed -n '374,374p' net/quic/tquic/masque/connect_udp.c; make M=net/tquic W=1 (+1 more) | Add per-connection and per-client tunnel limits (e.g., max 16 tunnels per connection) Risk: Fixes in parser/crypto/lifet |
| CF-461 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_path_anti_amplification_sent" "net/tquic/tquic_migration.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "ne | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-464 | PLAUSIBLE | low | S2 | 2.80 | file:1, lines:1 | Code snippet proving the vulnerable pattern; Function/struct symbol name at the fault site (+3 more) | sed -n '299,299p' net/tquic/sched/deadline_aware.c; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-465 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_cong_data_on_ack" "net/tquic/cong/cong_data.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/cong/ | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-468 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "h3_parse_settings_frame" "net/quic/tquic/http3/http3_frame.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-470 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_cong_data_compute_hmac" "net/tquic/cong/cong_data.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/t | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-471 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_calc_path_quality" "net/tquic/bond/bonding.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-474 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:1, snippet:2 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "update_loss_rate" "net/tquic/fec/fec_scheduler.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-475 | PLAUSIBLE | low | S2 | 2.80 | file:1, sym:1, lines:5 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_handshake" "net/quic/tquic/tquic_handshake.c"; sed -n '605,605p' net/quic/tquic/tquic_handshake.c (+3 more) | Enforce a hard cap on `ch_len` and `resp_len` (e.g., 16KB max for any single handshake message) Risk: Fixes in parser/cr |
| CF-476 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_fec_receive_repair" "net/tquic/fec/fec_decoder.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/fe | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-477 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_migration" "net/tquic/tquic_migration.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tquic_migra | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-481 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:5, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "put_unaligned" "net/tquic/bond/bonding.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-482 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:4, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_sched_default" "net/tquic/sched/scheduler.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-484 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_lost_packet" "net/tquic/cong/persistent_cong.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-487 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:6, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_napi_subsys_exit" "net/quic/tquic/tquic_main.c"; make M=net/tquic W=1 (+1 more) | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-491 | PLAUSIBLE | low | S2 | 2.80 | file:1, sym:3, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_tunnel_create_tproxy" "net/tquic/tquic_tunnel.c"; sed -n '592,592p' net/tquic/tquic_tunnel.c (+3 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-492 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "hrtimer_cancel" "net/tquic/tquic_input.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tquic_input. | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-493 | PLAUSIBLE | low | S2 | 2.80 | file:2, sym:6, lines:3 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_net_close_all_connections" "net/tquic/tquic_proto.c"; sed -n '171,171p' net/tquic/tquic_proto.c (+4 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-494 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:5, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "call_rcu" "net/tquic/tquic_nf.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tquic_nf.c" (+2 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-495 | PLAUSIBLE | medium | S2 | 2.80 | file:1, sym:4, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "sk_buff" "net/tquic/tquic_zerocopy.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tquic_zerocopy.c | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-499 | PLAUSIBLE | medium | S2 | 2.80 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+3 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-456 | SPECULATIVE | low | S2 | 2.80 | sym:1, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_zero_rtt_keys" net/tquic/; make M=net/tquic W=1 (+1 more) | Allocate the AEAD transform once during key derivation and store it in `tquic_zero_rtt_keys`. Reuse for all packets.  -- |
| CF-457 | SPECULATIVE | low | S2 | 2.80 | sym:8 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | rg -rn "aggregate_init" net/tquic/; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-459 | SPECULATIVE | low | S2 | 2.80 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "tquic_path_handle_challenge" "net/quic/tquic/pm/path_validation.c"; make M=net/tquic W=1 (+1 more) | Check `tquic_path_anti_amplification_check` before queuing response; charge response bytes to `bytes_sent` Risk: Fixes i |
| CF-462 | SPECULATIVE | low | S2 | 2.80 | snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-463 | SPECULATIVE | low | S2 | 2.80 | sym:1, snippet:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_input" net/tquic/; make M=net/tquic W=1 (+1 more) | Instead of silently truncating, reject the coalesced packet entirely when the claimed length exceeds remaining data: ``` |
| CF-466 | SPECULATIVE | low | S2 | 2.80 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-467 | SPECULATIVE | low | S2 | 2.80 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "tquic_cong" "net/tquic/cong/tquic_cong.h"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-469 | SPECULATIVE | low | S2 | 2.80 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "h3_parser_advance" "net/quic/tquic/http3/http3_frame.h"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/quic | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-472 | SPECULATIVE | low | S2 | 2.80 | sym:1, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_input" net/tquic/; make M=net/tquic W=1 (+1 more) | Use a typed union or dedicated struct for `skb->cb` usage, documented per frame type.  --- Risk: Protocol correctness fi |
| CF-473 | SPECULATIVE | low | S2 | 2.80 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "tquic_fec_should_send_repair" "net/tquic/fec/fec_scheduler.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tq | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-478 | SPECULATIVE | low | S2 | 2.80 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "rtnl_lock" "net/tquic/pm/path_manager.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/pm/path_manager.c | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-479 | SPECULATIVE | low | S2 | 2.80 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-480 | SPECULATIVE | low | S2 | 2.80 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-483 | SPECULATIVE | low | S2 | 2.80 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-485 | SPECULATIVE | low | S2 | 2.80 | file:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Consider proactive cookie validation when pre-handshake memory exceeds 50% of budget, independent of rate limit triggers |
| CF-486 | SPECULATIVE | low | S2 | 2.80 | sym:2, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_gro_flush" net/tquic/; make M=net/tquic W=1 (+1 more) | After the loop, set `held_count = skb_queue_len(&gro->hold_queue)`.  --- Risk: Protocol correctness fixes can shift timi |
| CF-488 | SPECULATIVE | low | S2 | 2.80 | sym:1, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -n "tquic_main" "err_netlink:"; make M=net/tquic W=1 (+1 more) | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-489 | SPECULATIVE | low | S2 | 2.80 | sym:2, snippet:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_recv_datagram" net/tquic/; make M=net/tquic W=1 (+1 more) | Add a retry counter to prevent excessive looping: ```c int retries = 0; ... Risk: Protocol correctness fixes can shift t |
| CF-490 | SPECULATIVE | low | S2 | 2.80 | file:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-496 | SPECULATIVE | low | S2 | 2.80 | sym:1, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_input" net/tquic/; make M=net/tquic W=1 (+1 more) | Either remove the per-version debug line or cap the number of logged versions.  --- Risk: Protocol correctness fixes can |
| CF-497 | SPECULATIVE | low | S2 | 2.80 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-498 | SPECULATIVE | low | S2 | 2.80 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-500 | SPECULATIVE | low | S2 | 2.80 | snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-454 | REJECTED | low | S1 | 2.80 | NONE | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+5 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-501 | CERTIFIED | high | S3 | 1.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_crypto_batch_encrypt" "net/tquic/crypto/hw_offload.c"; make M=net/tquic W=1 (+1 more) | Perform in-place encryption if the caller's buffer has sufficient space (the `data_buf_len` check already exists), or pr |
| CF-502 | CERTIFIED | high | S3 | 1.00 | file:17, sym:11 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "csprng" "net/tquic/crypto/cert_verify.c"; make M=net/tquic W=1 (+1 more) | Move the chain length check to the beginning of the loop iteration. Risk: Fixes in parser/crypto/lifetime code may alter |
| CF-503 | CERTIFIED | high | S3 | 1.00 | file:1, sym:6, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "module_author" "net/tquic/security/quic_exfil.c"; sed -n '1684,1686p' net/tquic/security/quic_exfil.c (+2 more) | Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Wat |
| CF-504 | CERTIFIED | high | S3 | 1.00 | file:2, sym:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "h3_varint_decode" "net/tquic/http3/http3_request.c"; make M=net/tquic W=1 (+1 more) | Move to a shared helper (e.g., in `http3_frame.c` or a common header as inline functions). Risk: Protocol correctness fi |
| CF-506 | CERTIFIED | high | S3 | 1.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "inconsistent" "net/tquic/crypto/key_update.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/crypto/key_u | Add a generation counter or sequence number to the key update so the timeout handler can detect if a response arrived be |
| CF-507 | CERTIFIED | high | S3 | 1.00 | file:1, sym:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "memzero_explicit" "net/tquic/lb/quic_lb.c"; make M=net/tquic W=1 (+1 more) | Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Wat |
| CF-508 | CERTIFIED | high | S3 | 1.00 | file:1, sym:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_cert_verify_mode" "net/tquic/crypto/cert_verify.c"; make M=net/tquic W=1 (+1 more) | Log a prominent warning when verification mode is set to NONE. Consider requiring a special flag to disable verification |
| CF-510 | CERTIFIED | high | S3 | 1.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "export_symbol_gpl" "net/tquic/tquic_netlink.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/tquic_n | Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Wat |
| CF-511 | CERTIFIED | high | S3 | 1.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "read_once" "net/tquic/crypto/hw_offload.c"; make M=net/tquic W=1 (+1 more) | Use `u64_stats_sync` infrastructure for proper 64-bit stats on 32-bit architectures. Risk: Fixes in parser/crypto/lifeti |
| CF-512 | CERTIFIED | high | S3 | 1.00 | file:1, sym:4 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "capable" "net/tquic/crypto/cert_verify.c"; make M=net/tquic W=1 (+1 more) | Add `capable(CAP_NET_ADMIN)` check at the start of `tquic_proc_trusted_cas_write()`. Risk: Fixes in parser/crypto/lifeti |
| CF-513 | CERTIFIED | high | S3 | 1.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "behavior" "net/tquic/diag/qlog.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/diag/qlog.c" (+2 more) | Copy the entry to a local kernel buffer under the lock, then `copy_to_user` from the local buffer. Risk: Locking/orderin |
| CF-514 | CERTIFIED | high | S3 | 1.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_eku_derive_keys" "net/tquic/crypto/extended_key_update.c"; make M=net/tquic W=1 (+1 more) | Actually use the `mixed_secret` as input to the subsequent key derivation rather than the standard derivation path. Risk |
| CF-515 | CERTIFIED | high | S3 | 1.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "crypto_memneq" "net/tquic/security/quic_exfil.c"; make M=net/tquic W=1 (+1 more) | Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Wat |
| CF-538 | CERTIFIED | high | S3 | 1.00 | file:1, lines:2, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue | sed -n '637,637p' net/tquic/crypto/tls.c; sed -n '694,694p' net/tquic/crypto/tls.c (+2 more) | Ensure the encrypt/decrypt paths are only called from process context (e.g., in a workqueue), or use async completion ca |
| CF-551 | CERTIFIED | high | S3 | 1.00 | file:1, sym:3, lines:5, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_crypto_ctx_destroy" "net/tquic/crypto/tls.c"; sed -n '392,423p' net/tquic/crypto/tls.c (+3 more) | Verify that path_id allocation is monotonically increasing per connection and never reuses IDs within a key phase. Risk: |
| CF-553 | CERTIFIED | high | S3 | 1.00 | file:1, sym:2, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_netlink" "net/tquic/tquic_netlink.c"; sed -n '274,274p' net/tquic/tquic_netlink.c (+2 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-558 | CERTIFIED | high | S3 | 1.00 | file:1, sym:2, lines:2, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_bonding_get_state" "net/quic/tquic/bond/tquic_bonding.c"; sed -n '526,526p' net/quic/tquic/bond/tquic_bondi | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-564 | CERTIFIED | high | S3 | 1.00 | file:1, sym:1, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_stream" "net/quic/tquic/tquic_stream.c"; sed -n '1409,1410p' net/quic/tquic/tquic_stream.c (+2 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-566 | CERTIFIED | high | S3 | 1.00 | file:1, sym:2, lines:5, snippet:1 | Kernel log / stack trace / error output demonstrating the issue | rg -n "copies" "net/quic/tquic/tquic_ipv6.c"; sed -n '171,211p' net/quic/tquic/tquic_ipv6.c (+3 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-516 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "ktime_get" "net/tquic/core/connection.c"; make M=net/tquic W=1 (+1 more) | Only set it in CONNECTED, or rename the CONNECTING one to `handshake_start_time`. Risk: Protocol correctness fixes can s |
| CF-517 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_socket" "net/tquic/tquic_socket.c"; make M=net/tquic W=1 (+1 more) | Add a comment: `/* ret is negative errno, sk_err needs positive */` Risk: Protocol correctness fixes can shift timing/st |
| CF-518 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_cid_compare" "net/tquic/core/connection.c"; make M=net/tquic W=1 (+1 more) | Remove if truly unused, or remove the `__maybe_unused` annotation. Risk: Protocol correctness fixes can shift timing/sta |
| CF-519 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:11, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "release_sock" "net/tquic/tquic_cid.c"; sed -n '516,516p' net/tquic/tquic_cid.c (+2 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-520 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_debug" "net/quic/tquic/tquic_debug.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-521 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hs_cleanup" "net/tquic/crypto/handshake.c"; make M=net/tquic W=1 (+1 more) | Add `memzero_explicit` calls for all remaining sensitive fields.  --- Risk: Fixes in parser/crypto/lifetime code may alt |
| CF-522 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "get_random_bytes" "net/tquic/crypto/handshake.c"; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-523 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_hs_get_handshake_secrets" "net/tquic/crypto/handshake.c"; make M=net/tquic W=1 (+1 more) | Document the minimum buffer size requirement or add a `buf_len` parameter.  --- Risk: Fixes in parser/crypto/lifetime co |
| CF-524 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_hs_process_certificate_verify" "net/tquic/crypto/handshake.c"; make M=net/tquic W=1 (+1 more) | Use `hs->is_server ? "TLS 1.3, client CertificateVerify" : "TLS 1.3, server CertificateVerify"`.  --- Risk: Fixes in par |
| CF-525 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:5, lines:5 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "crypto_memneq" "net/tquic/crypto/handshake.c"; sed -n '1076,1253p' net/tquic/crypto/handshake.c (+3 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-526 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:3 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_path_start_validation" "net/tquic/tquic_migration.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-527 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_store_session_ticket" "net/tquic/tquic_handshake.c"; make M=net/tquic W=1 (+1 more) | Populate `plaintext.alpn` and `plaintext.transport_params` from the connection state when storing session tickets. Risk: |
| CF-528 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_sysctl_prefer_v2" "net/tquic/core/connection.c"; make M=net/tquic W=1 (+1 more) | Add a proper declaration in a shared header file. Risk: Protocol correctness fixes can shift timing/state-machine behavi |
| CF-529 | PLAUSIBLE | medium | S3 | 1.00 | file:2, sym:1, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "buffer" "net/tquic/af_xdp.c"; sed -n '222,238p' net/tquic/af_xdp.c (+3 more) | Use a lockless ring buffer (SPSC or MPSC depending on usage pattern) for the free list, similar to how io_uring and XDP  |
| CF-530 | PLAUSIBLE | medium | S3 | 1.00 | file:2, sym:2, lines:2 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "free" "net/quic/tquic/fec/fec_encoder.c"; sed -n '349,350p' net/quic/tquic/fec/fec_encoder.c (+3 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-531 | PLAUSIBLE | medium | S3 | 1.00 | file:2, sym:12 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "apis" "net/tquic/bench/bench_common.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/bench/bench_com | Consider moving benchmark code to a `tools/` or `tests/` directory to avoid confusion about its execution context. Risk: |
| CF-532 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_cid" "net/tquic/tquic_cid.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tquic_cid.c" (+2 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-533 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "work_struct" "net/tquic/core/connection.c"; make M=net/tquic W=1 (+1 more) | Use a separate delayed_work for close retransmission.  --- Risk: Protocol correctness fixes can shift timing/state-machi |
| CF-535 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_retry" "net/quic/tquic/tquic_retry.c"; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-536 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:7, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_exfil_ctx_set_level" "net/tquic/security/quic_exfil.c"; make M=net/tquic W=1 (+1 more) | Check return values and either revert to the previous level or mark the context as failed.  --- Risk: Protocol correctne |
| CF-537 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:3, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_hp_mask_aes" "net/tquic/crypto/header_protection.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/ | Either (a) ensure callers never hold spinlocks when calling HP mask generation, or (b) use `CRYPTO_TFM_REQ_MAY_SLEEP` on |
| CF-540 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "h3_varint_len" "net/quic/tquic/http3/http3_request.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-541 | PLAUSIBLE | medium | S3 | 1.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add `memzero_explicit(hmac_out, sizeof(hmac_out));` before `goto fallback`.  --- Risk: Fixes in parser/crypto/lifetime c |
| CF-542 | PLAUSIBLE | medium | S3 | 1.00 | file:1, lines:1 | Code snippet proving the vulnerable pattern; Function/struct symbol name at the fault site (+1 more) | sed -n '2332,2332p' net/tquic/crypto/cert_verify.c; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-544 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_ku_derive_next_generation" "net/tquic/crypto/key_update.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net | Pass `hash_tfm` as a separate parameter copied under the lock, rather than passing the entire state.  --- Risk: Locking/ |
| CF-545 | PLAUSIBLE | medium | S3 | 1.00 | file:2, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_output" "net/tquic/tquic_output.c"; make M=net/tquic W=1 (+1 more) | Pre-compute `ns_per_byte = NSEC_PER_SEC Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify |
| CF-546 | PLAUSIBLE | medium | S3 | 1.00 | file:2, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Pre-compute a reciprocal multiplier for the RTT target to replace division with multiplication + shift. Risk: Protocol c |
| CF-547 | PLAUSIBLE | medium | S3 | 1.00 | sym:2, lines:2 | Concrete source file path (e.g., net/tquic/...); Code snippet proving the vulnerable pattern (+1 more) | rg -rn "tquic_retry" net/tquic/; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-548 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:7 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "recommendations" "net/tquic/diag/trace.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/diag/trace.c | Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Wat |
| CF-550 | PLAUSIBLE | medium | S3 | 1.00 | sym:3, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+1 more) | rg -rn "lockdep_assert_held" net/tquic/; rg -rn "spin_lock\\|mutex_lock" net/tquic/ (+2 more) | Add `lockdep_assert_held(&conn->lock)` at the beginning of functions that require `conn->lock` to be held. Risk: Locking |
| CF-554 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_netlink" "net/quic/tquic/tquic_netlink.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-555 | PLAUSIBLE | medium | S3 | 1.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-556 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "skb_queue_len" "net/tquic/pm/path_validation.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/pm/path_va | Use only one mechanism. `skb_queue_len()` is already atomic and thread-safe. Risk: Locking/ordering changes can cause de |
| CF-557 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "quic_exfil" "net/quic/tquic/security/quic_exfil.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-559 | PLAUSIBLE | medium | S3 | 1.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/core/connection.c"; make M=net/tquic W=1 (+1 more) | Return an error if the integrity tag cannot be computed rather than sending a tagless packet.  --- Risk: Fixes in parser |
| CF-560 | PLAUSIBLE | medium | S3 | 1.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Reduce limit to 1000 or add a total allocation size limit. Risk: Fixes in parser/crypto/lifetime code may alter packet a |
| CF-561 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "spin_lock" "net/quic/tquic/sched/scheduler.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic/sched/s | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-562 | PLAUSIBLE | medium | S3 | 1.00 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+1 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Implement periodic key rotation (e.g., every 24 hours) with support for decrypting tickets encrypted with the previous k |
| CF-563 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_stream_ext" "net/tquic/core/stream.c"; make M=net/tquic W=1 (+1 more) | Use names like `"tquic_core_stream_ext"` for clarity. Risk: Protocol correctness fixes can shift timing/state-machine be |
| CF-565 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_conn_destroy" "net/quic/tquic/core/quic_connection.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-567 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:2, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_exit" "net/quic/tquic/tquic_main.c"; sed -n '1198,1198p' net/quic/tquic/tquic_main.c (+2 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-568 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:7, lines:5 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_encap_recv" "net/tquic/tquic_output.c"; sed -n '2071,2117p' net/tquic/tquic_output.c (+4 more) | Consider pre-allocating frame structures outside the lock, or batching frame preparation. Risk: Locking/ordering changes |
| CF-569 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_pacing_cleanup" "net/quic/tquic/tquic_output.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-570 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_retry_rate_limit" "net/quic/tquic/tquic_retry.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-571 | PLAUSIBLE | medium | S3 | 1.00 | file:22, sym:4 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_stream_manager_destroy" "net/quic/tquic/http3/http3_conn.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-572 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_timer_state_alloc" "net/quic/tquic/tquic_timer.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-573 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_timer_state_free" "net/quic/tquic/tquic_timer.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tqui | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-574 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue | rg -n "get_random_u8" "net/tquic/core/connection.c"; sed -n '807,807p' net/tquic/core/connection.c (+2 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-576 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue | rg -n "tquic_input" "net/quic/tquic/tquic_input.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/quic/tquic/tquic | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-577 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:4 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+1 more) | rg -n "tquic_validate_target_address" "net/tquic/security/quic_exfil.c"; make M=net/tquic W=1 (+1 more) | If `exfil_wq` is NULL, either send the packet immediately (bypassing timing normalization) or return an error so the cal |
| CF-579 | PLAUSIBLE | medium | S3 | 1.00 | file:2, sym:1, lines:4, snippet:3 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_bench_latency" "net/quic/tquic/bench/tquic_bench_latency.c"; sed -n '980,980p' net/quic/tquic/bench/tquic_b | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-580 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, lines:1, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_cid" "net/quic/tquic/tquic_cid.c"; sed -n '617,617p' net/quic/tquic/tquic_cid.c (+3 more) | Maintain running `active_count` counter to avoid list traversal Risk: Locking/ordering changes can cause deadlocks or th |
| CF-581 | PLAUSIBLE | medium | S3 | 1.00 | file:1, lines:2, snippet:1 | Function/struct symbol name at the fault site; Kernel log / stack trace / error output demonstrating the issue (+1 more) | sed -n '1015,1017p' net/tquic/tquic_input.c; sed -n '251,251p' net/tquic/tquic_input.c (+2 more) | Change to `spin_lock_bh(&ctx->conn->lock)`. Risk: Locking/ordering changes can cause deadlocks or throughput regressions |
| CF-582 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:2, lines:4, snippet:2 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_build_short_header_internal" "net/tquic/tquic_output.c"; sed -n '818,818p' net/tquic/tquic_output.c (+3 mor | Allocate a separate scratch buffer or use a function-local buffer: ```c u8 pn_scratch[4]; pkt_num_len = tquic_encode_pkt |
| CF-583 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, lines:1, snippet:2 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_gso_init" "net/tquic/tquic_output.c"; sed -n '1489,1489p' net/tquic/tquic_output.c (+3 more) | Use `size_t` arithmetic with overflow checking: ```c size_t alloc_size; if (check_mul_overflow((size_t)gso->gso_size, (s |
| CF-584 | PLAUSIBLE | medium | S3 | 1.00 | file:1, sym:1, lines:5, snippet:1 | Kernel log / stack trace / error output demonstrating the issue; Independent confirmation from a second audit source | rg -n "tquic_cid" "net/tquic/tquic_cid.c"; sed -n '980,1180p' net/tquic/tquic_cid.c (+4 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-505 | SPECULATIVE | low | S3 | 1.00 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+2 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Explicitly initialize `push_buckets[]` in the priority init function for defensive coding. Risk: Protocol correctness fi |
| CF-509 | SPECULATIVE | low | S3 | 1.00 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+2 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Wat |
| CF-534 | SPECULATIVE | low | S3 | 1.00 | sym:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+2 more) | rg -rn "tquic_server" net/tquic/; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-539 | SPECULATIVE | low | S3 | 1.00 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+2 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Zero-initialize `empty_hash` or use `memzero_explicit` after use.  --- Risk: Fixes in parser/crypto/lifetime code may al |
| CF-543 | SPECULATIVE | low | S3 | 1.00 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+2 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-549 | SPECULATIVE | low | S3 | 1.00 | sym:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+2 more) | rg -rn "tquic_tunnel" net/tquic/; make M=net/tquic W=1 (+1 more) | Store the network namespace reference at module load time and add a helper function that returns the appropriate namespa |
| CF-552 | SPECULATIVE | low | S3 | 1.00 | sym:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+2 more) | rg -rn "tquic_input" net/tquic/; make M=net/tquic W=1 (+1 more) | Consolidate to a single implementation in `varint.c`/`varint.h` and use it everywhere. Risk: Protocol correctness fixes  |
| CF-575 | SPECULATIVE | low | S3 | 1.00 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+2 more) | rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/tquic/core/connection.c"; make M=net/tquic W=1 (+1 more) | Add a bounds check or use the `p - packet < sizeof(packet)` idiom. Risk: Fixes in parser/crypto/lifetime code may alter  |
| CF-578 | SPECULATIVE | low | S3 | 1.00 | sym:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+2 more) | rg -rn "scheme" net/tquic/; rg -rn "spin_lock\\|mutex_lock" net/tquic/ (+2 more) | Missing fix suggestion in source text. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if n |
| CF-585 | PLAUSIBLE | medium | S3 | 0.70 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+3 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-589 | PLAUSIBLE | medium | S3 | 0.70 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_sock_listen" "net/tquic/tquic_socket.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-590 | PLAUSIBLE | medium | S3 | 0.70 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_stateless_reset_detect" "net/tquic/tquic_stateless_reset.c"; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-593 | PLAUSIBLE | medium | S3 | 0.70 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_bpm" "net/tquic/bond/tquic_bpm.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-598 | PLAUSIBLE | medium | S3 | 0.70 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_path" "net/quic/tquic/http3/qpack_decoder.c"; make M=net/tquic W=1 (+1 more) | Audit SETTINGS parsing to confirm capacity is clamped Risk: Fixes in parser/crypto/lifetime code may alter packet accept |
| CF-601 | PLAUSIBLE | medium | S3 | 0.70 | file:1, sym:1, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_failover" "net/tquic/bond/tquic_failover.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/bond/tqu | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-603 | PLAUSIBLE | low | S3 | 0.70 | file:1, sym:3, lines:2 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_stream_open_incoming" "net/quic/tquic/tquic_nf.c"; sed -n '497,497p' net/quic/tquic/tquic_nf.c (+3 more) | Add per-IP NF tracking limit (e.g., 256 entries per source IP) Risk: Fixes in parser/crypto/lifetime code may alter pack |
| CF-606 | PLAUSIBLE | low | S3 | 0.70 | sym:2, lines:5, snippet:1 | Concrete source file path (e.g., net/tquic/...); Kernel log / stack trace / error output demonstrating the issue (+2 mor | rg -rn "tquic_cid_security_check_new_cid" net/tquic/; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-608 | PLAUSIBLE | low | S3 | 0.70 | file:10, sym:2, lines:5 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_input" "net/quic/tquic/crypto/extended_key_update.c"; sed -n '171,171p' net/quic/tquic/crypto/extended_key_ | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-609 | PLAUSIBLE | medium | S3 | 0.70 | file:1, sym:6, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "nla_len" "net/tquic/tquic_netlink.c"; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-612 | PLAUSIBLE | medium | S3 | 0.70 | file:1, snippet:1 | Exact line range(s) where the fault manifests; Function/struct symbol name at the fault site (+3 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-622 | PLAUSIBLE | low | S3 | 0.70 | sym:2, lines:2, snippet:1 | Concrete source file path (e.g., net/tquic/...); Kernel log / stack trace / error output demonstrating the issue (+2 mor | rg -rn "tquic_stream_open_incoming" net/tquic/; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-623 | PLAUSIBLE | low | S3 | 0.70 | file:1, lines:1 | Code snippet proving the vulnerable pattern; Function/struct symbol name at the fault site (+3 more) | sed -n '102,117p' net/tquic/sched/deadline_aware.c; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-626 | PLAUSIBLE | low | S3 | 0.70 | file:1, sym:2, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_encode_varint" "net/tquic/tquic_output.c"; sed -n '164,198p' net/tquic/tquic_output.c (+2 more) | Add validation: `if (val >= (1ULL << 62)) return -EINVAL;` Risk: Protocol correctness fixes can shift timing/state-machi |
| CF-629 | PLAUSIBLE | low | S3 | 0.70 | file:1, sym:2, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_process_ack_frame" "net/tquic/tquic_input.c"; sed -n '601,660p' net/tquic/tquic_input.c (+2 more) | Add: `if (first_ack_range > largest_ack) return -EINVAL;` Risk: Protocol correctness fixes can shift timing/state-machin |
| CF-631 | PLAUSIBLE | low | S3 | 0.70 | file:1, sym:2, lines:2 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_process_coalesced" "net/tquic/tquic_input.c"; sed -n '3079,3182p' net/tquic/tquic_input.c (+3 more) | Add `if (packets > 16) break;` to cap coalesced packets. Risk: Fixes in parser/crypto/lifetime code may alter packet acc |
| CF-635 | PLAUSIBLE | low | S3 | 0.70 | file:1, sym:2, lines:1 | Code snippet proving the vulnerable pattern; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_stream_release" "net/quic/tquic/tquic_stream.c"; sed -n '643,643p' net/quic/tquic/tquic_stream.c (+2 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-636 | PLAUSIBLE | medium | S3 | 0.70 | file:1, sym:2, snippet:1 | Exact line range(s) where the fault manifests; Kernel log / stack trace / error output demonstrating the issue (+2 more) | rg -n "tquic_stream" "net/quic/tquic/core/stream.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic/core/str | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-586 | SPECULATIVE | low | S3 | 0.70 | snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-587 | SPECULATIVE | low | S3 | 0.70 | snippet:4 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Validate before truncation: ```c if (val > U8_MAX)     return -EINVAL; data->flags = (u8)val; ``` Risk: Protocol correct |
| CF-588 | SPECULATIVE | low | S3 | 0.70 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "tquic_accept" "net/tquic/tquic_socket.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/tquic_socket.c" ( | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-591 | SPECULATIVE | low | S3 | 0.70 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "ktime_get" "net/tquic/multipath/sched_aggregate.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/multipa | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-592 | SPECULATIVE | low | S3 | 0.70 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Consider moving benchmark code to a `tools/` or `tests/` directory to avoid confusion about its execution context. Risk: |
| CF-594 | SPECULATIVE | low | S3 | 0.70 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "tquic_xor_decode" "net/tquic/fec/xor_fec.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/fec/xor_fec.c" | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-595 | SPECULATIVE | low | S3 | 0.70 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "crypto_memneq" "net/tquic/cong/cong_data.c"; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-596 | SPECULATIVE | low | S3 | 0.70 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "crypto_memneq" "net/tquic/bond/cong_coupled.c"; make M=net/tquic W=1 (+1 more) | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-599 | SPECULATIVE | low | S3 | 0.70 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "tquic_rx_buf_cache" "net/quic/tquic/"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic/" (+2 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-600 | SPECULATIVE | low | S3 | 0.70 | sym:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | rg -rn "tquic_dbg" net/tquic/; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-602 | SPECULATIVE | low | S3 | 0.70 | sym:3, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_dbg" net/tquic/; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-604 | SPECULATIVE | low | S3 | 0.70 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "tquic_main" "net/quic/tquic/tquic_main.c"; make M=net/tquic W=1 (+1 more) | Consider lazy initialization of stream buffers Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance lo |
| CF-605 | SPECULATIVE | low | S3 | 0.70 | file:2, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "tquic_bonding" "net/tquic/fec/"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/fec/" (+2 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-607 | SPECULATIVE | low | S3 | 0.70 | sym:4 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | rg -rn "tquic_scheduler" net/tquic/; rg -rn "spin_lock\\|mutex_lock" net/tquic/ (+2 more) | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-610 | SPECULATIVE | low | S3 | 0.70 | sym:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | rg -rn "tquic_process_frames" net/tquic/; make M=net/tquic W=1 (+1 more) | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-611 | SPECULATIVE | low | S3 | 0.70 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "del_timer_sync" "net/tquic/pm/path_validation.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/tquic/pm/path_v | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-613 | SPECULATIVE | low | S3 | 0.70 | sym:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | rg -rn "tquic_cid" net/tquic/; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-614 | SPECULATIVE | low | S3 | 0.70 | file:2, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "tquic_fec_get_pending_repair" "net/tquic/fec/fec_encoder.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/ | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-615 | SPECULATIVE | low | S3 | 0.70 | snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-616 | SPECULATIVE | low | S3 | 0.70 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "kfree_sensitive" "net/tquic/cong/cong_data.c"; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-617 | SPECULATIVE | low | S3 | 0.70 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-618 | SPECULATIVE | low | S3 | 0.70 | sym:2, snippet:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_process_max_data_frame" net/tquic/; make M=net/tquic W=1 (+1 more) | Change to `spin_lock_bh(&ctx->conn->lock)`.  --- Risk: Protocol correctness fixes can shift timing/state-machine behavio |
| CF-619 | SPECULATIVE | low | S3 | 0.70 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Enforce a maximum concurrent connections per-IP limit (distinct from rate limit), e.g., 32 connections per source IP Ris |
| CF-620 | SPECULATIVE | low | S3 | 0.70 | lines:2, snippet:1 | Concrete source file path (e.g., net/tquic/...); Function/struct symbol name at the fault site (+3 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Enforce max paths per connection limit Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Wat |
| CF-621 | SPECULATIVE | low | S3 | 0.70 | sym:5, lines:1 | Concrete source file path (e.g., net/tquic/...); Code snippet proving the vulnerable pattern (+3 more) | rg -rn "crypto_memneq" net/tquic/; make M=net/tquic W=1 (+1 more) | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-624 | SPECULATIVE | low | S3 | 0.70 | sym:6, snippet:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_build_short_header_internal" net/tquic/; make M=net/tquic W=1 (+1 more) | Allocate a separate scratch buffer or use a function-local buffer: ```c u8 pn_scratch[4]; pkt_num_len = tquic_encode_pkt |
| CF-625 | SPECULATIVE | low | S3 | 0.70 | sym:1 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | rg -rn "tquic_encap_recv" net/tquic/; make M=net/tquic W=1 (+1 more) | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-627 | SPECULATIVE | low | S3 | 0.70 | sym:3 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | rg -rn "tquic_encode_varint" net/tquic/; make M=net/tquic W=1 (+1 more) | Add validation: `if (val >= (1ULL << 62)) return -EINVAL;`  --- Risk: Protocol correctness fixes can shift timing/state- |
| CF-628 | SPECULATIVE | low | S3 | 0.70 | sym:2, snippet:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+3 more) | rg -rn "tquic_gso_init" net/tquic/; make M=net/tquic W=1 (+1 more) | Use `size_t` arithmetic with overflow checking: ```c size_t alloc_size; if (check_mul_overflow((size_t)gso->gso_size, (s |
| CF-630 | SPECULATIVE | low | S3 | 0.70 | sym:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | rg -rn "tquic_process_ack_frame" net/tquic/; make M=net/tquic W=1 (+1 more) | Add: `if (first_ack_range > largest_ack) return -EINVAL;`  --- Risk: Protocol correctness fixes can shift timing/state-m |
| CF-632 | SPECULATIVE | low | S3 | 0.70 | sym:2 | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+4 more) | rg -rn "tquic_process_coalesced" net/tquic/; make M=net/tquic W=1 (+1 more) | Add `if (packets > 16) break;` to cap coalesced packets.  --- Risk: Protocol correctness fixes can shift timing/state-ma |
| CF-633 | SPECULATIVE | low | S3 | 0.70 | file:1, sym:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "tquic_sched_release" "net/quic/tquic/core/priority.c"; rg -n "kmalloc\\|kzalloc\\|alloc_skb\\|memcpy" "net/quic/t | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-634 | SPECULATIVE | low | S3 | 0.70 | file:1, sym:2 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+3 more) | rg -n "tquic_stream_alloc" "net/quic/tquic/tquic_stream.c"; rg -n "spin_lock\\|mutex_lock\\|lock_sock" "net/quic/tquic/t | Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistentl |
| CF-637 | SPECULATIVE | low | S3 | 0.70 | file:1 | Exact line range(s) where the fault manifests; Code snippet proving the vulnerable pattern (+4 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-597 | REJECTED | low | S3 | 0.70 | NONE | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+5 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Consider faster convergence when path count changes. Risk: Protocol correctness fixes can shift timing/state-machine beh |
| CF-638 | REJECTED | low | S3 | 0.40 | NONE | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+5 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Verify the frame type dispatch logic handles multi-byte frame types correctly. Risk: Protocol correctness fixes can shif |
| CF-639 | REJECTED | low | S3 | 0.40 | NONE | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+5 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-640 | REJECTED | low | S3 | 0.40 | NONE | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+5 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transit |
| CF-641 | REJECTED | low | S3 | 0.40 | NONE | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+5 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malfor |
| CF-642 | REJECTED | low | S3 | 0.40 | NONE | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+5 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-643 | REJECTED | low | S3 | 0.40 | NONE | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+5 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |
| CF-644 | REJECTED | low | S3 | 0.40 | NONE | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+5 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Consolidate to the single canonical implementation in `core/varint.c` and export symbols for all callers.  --- Risk: Pro |
| CF-645 | REJECTED | low | S3 | 0.40 | NONE | Concrete source file path (e.g., net/tquic/...); Exact line range(s) where the fault manifests (+5 more) | make M=net/tquic W=1; make M=net/tquic C=1  # sparse static analysis | Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled. |

## CERTIFIED Findings (155)

### CF-001 -- Adaptive Scheduler cwnd_avail Underflow

**Severity:** S0 | **Category:** correctness | **Sources:** A,B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:4, snippet:5

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_scheduler" "net/tquic/multipath/tquic_scheduler.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add an explicit check: `cwnd_avail = (path->cc.cwnd > path->cc.bytes_in_flight) ? path->cc.cwnd - path->cc.bytes_in_flight : 0;` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/multipath/tquic_scheduler.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-003 -- Client Certificate Verification Uses Server Logic

**Severity:** S0 | **Category:** security | **Sources:** A,B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Sources disagree on severity: Severity disagreement across reports: S0, S1.

**Key evidence present:** file:1, sym:5, lines:2, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_verify_client_cert" "net/tquic/crypto/cert_verify.c"`
- `sed -n '2450,2450p' net/tquic/crypto/cert_verify.c`
- `sed -n '2243,2243p' net/tquic/crypto/cert_verify.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a `bool is_server` parameter to the internal `verify_chain()` call path, or refactor so that client cert verification passes `is_server=false`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-004 -- Connection Destroy Calls Sleeping Function Under Spinlock

**Severity:** S0 | **Category:** concurrency | **Sources:** A,B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "h3_connection_destroy" "net/tquic/http3/http3_stream.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/http3/http3_stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Collect stream pointers into a local list under the spinlock, release the spinlock, then close each stream outside the lock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/http3_stream.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-005 -- Fragile Hardcoded Offset for Key Update State Access

**Severity:** S0 | **Category:** security | **Sources:** A,B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, sym:9, snippet:4

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "change" "net/tquic/crypto/key_update.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a proper typed structure with a named field, or use `container_of()` macro. Never use raw byte offsets to access structure members. Define a proper interface header that both the crypto state creator and this function share. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/key_update.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-006 -- HTTP/3 Stream Lookup: Use-After-Free

**Severity:** S0 | **Category:** memory | **Sources:** A,B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:5

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "free" "net/tquic/http3/http3_stream.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/http3/http3_stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `refcount_inc(&stream->refcount)` in `h3_stream_lookup()` and require all callers to call a corresponding `h3_stream_put()` when done. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/http3_stream.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-007 -- OCSP Stapling Response Accepted Without Any Verification

**Severity:** S0 | **Category:** security | **Sources:** A,B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on severity: Severity disagreement across reports: S0, S1.

**Key evidence present:** file:1, sym:6, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "pr_debug" "net/tquic/crypto/cert_verify.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Either implement OCSP response verification or remove the early return so that the "no OCSP available" path is taken, which at least logs warnings in hard-fail mode. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-008 -- Path Metrics Netlink: Unbounded Allocation from Attacker-Influenced Value

**Severity:** S0 | **Category:** security | **Sources:** A,B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, perf, security.

**Key evidence present:** file:1, sym:6

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "allocation" "net/tquic/diag/path_metrics.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Cap the allocation at a fixed reasonable maximum (e.g., `min(conn->num_paths, TQUIC_MAX_PATHS) * NLMSG_DEFAULT_SIZE`), and add the CAP_NET_ADMIN check from H1. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/diag/path_metrics.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-009 -- QPACK Dynamic Table Duplicate: Use-After-Free via Lock Drop

**Severity:** S0 | **Category:** memory | **Sources:** A,B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:5

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "either" "net/tquic/http3/qpack_dynamic.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/http3/qpack_dynamic.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Either (a) increment the entry's refcount before dropping the lock, or (b) copy the name/value data into a local buffer before dropping the lock, or (c) use `GFP_ATOMIC` allocation under the lock (acceptable for small allocations). Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/qpack_dynamic.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-010 -- Self-Signed Certificate Comparison Uses Non-Constant-Time memcmp in One Path

**Severity:** S0 | **Category:** security | **Sources:** A,B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** file:1, sym:7, lines:4, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "comparison" "net/tquic/crypto/cert_verify.c"`
- `sed -n '1628,1628p' net/tquic/crypto/cert_verify.c`
- `sed -n '1626,1628p' net/tquic/crypto/cert_verify.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `crypto_memneq()` consistently for all comparisons, or use `memcmp()` consistently for non-secret data. The key point is to be consistent and use constant-time comparison for any data whose equality/inequality should not leak timing information. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-011 -- Stack Buffer Overflow in HKDF-Expand-Label

**Severity:** S0 | **Category:** memory | **Sources:** A,B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** file:1, sym:3, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "label" "net/tquic/crypto/handshake.c"`
- `sed -n '238,238p' net/tquic/crypto/handshake.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add explicit bounds check: `if (label_len + context_len + 10 > sizeof(hkdf_label)) return -EINVAL;` before any writes to the buffer. Note: the zero_rtt.c implementation at line ~238 correctly has this check (`if (label_len > 245 || context_len > 245 || (10 + label_len + context_len) > sizeof(hkdf... Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-012 -- Stream Data Queued Before Validation Check

**Severity:** S0 | **Category:** correctness | **Sources:** A,B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Sources disagree on category: Category disagreement across reports: concurrency, correctness, memory, perf, security.
- Sources disagree on severity: Severity disagreement across reports: S0, S1, S2.

**Key evidence present:** file:4, sym:20, lines:8, snippet:12

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "dispatcher" "net/tquic/tquic_input.c"`
- `sed -n '2303,2310p' net/tquic/tquic_input.c`
- `sed -n '944,948p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a flag to `tquic_rx_ctx` that records when a length-less STREAM frame is processed, and assert in the dispatcher that no further frames follow. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-014 -- `tquic_hs_process_certificate` -- integer underflow in `certs_len` tracking

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, lines:3, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_process_certificate" "net/tquic/crypto/handshake.c"`
- `sed -n '1778,1778p' net/tquic/crypto/handshake.c`
- `sed -n '1780,1780p' net/tquic/crypto/handshake.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Check `certs_len >= 3` before `certs_len -= 3`, and
`certs_len >= 2` before `certs_len -= 2`. Alternatively, track position using
pointer arithmetic against `end` only.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-015 -- `tquic_hs_process_new_session_ticket` -- nonce overflow into session ticket

**Severity:** S0 | **Category:** memory | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:3, lines:1, snippet:3

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_session_ticket" "net/tquic/crypto/handshake.c"`
- `sed -n '76,77p' net/tquic/crypto/handshake.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-023 -- Busy-poll per-packet lock/unlock

**Severity:** S0 | **Category:** concurrency | **Sources:** A,B | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.

**Key evidence present:** file:2, sym:8, lines:3, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "__skb_dequeue" "net/tquic/napi.c"`
- `sed -n '460,465p' net/tquic/napi.c`
- `sed -n '317,317p' net/tquic/napi.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/napi.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use the same batch-splice pattern as `tquic_napi_poll()`: splice the queue to a local list under a single lock acquisition, then process without holding the lock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-024 -- Capsule Buffer Size Addition Overflow

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, lines:2, snippet:2

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '850,850p' net/quic/tquic/masque/capsule.c`
- `sed -n '894,894p' net/quic/tquic/masque/capsule.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add overflow check:
```c
if (cap->length > SIZE_MAX - CAPSULE_MAX_HEADER_SIZE)
    return -EOVERFLOW;
```

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-028 -- GSO Segment Accumulation Can Overflow SKB Tailroom

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, sym:2, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_gso_ctx" "net/quic/tquic/tquic_output.c"`
- `sed -n '1487,1487p' net/quic/tquic/tquic_output.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Validate cumulative bytes written against SKB tailroom
before each `skb_put_data`/`skb_put` call, or check
`skb_tailroom(gso->gso_skb) >= len` before the write.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-029 -- GSO SKB Allocation Multiplication Overflow

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:2, lines:1, snippet:3

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_output" "net/quic/tquic/tquic_output.c"`
- `sed -n '1851,1851p' net/quic/tquic/tquic_output.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `check_mul_overflow` and `check_add_overflow`:
```c
size_t alloc_size;
if (check_mul_overflow((size_t)gso->gso_size, (size_t)max_segs, &alloc_size) ||
    check_add_overflow(alloc_size, (size_t)MAX_HEADER, &alloc_size))
    return -EOVERFLOW;
gso->gso_skb = alloc_skb(alloc_size, GFP_ATOMIC);
... Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-030 -- Handshake Packet Parsing with Unvalidated Offsets

**Severity:** S0 | **Category:** memory | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, sym:1, lines:5, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_parse_long_header" "net/tquic/core/connection.c"`
- `sed -n '1932,1932p' net/tquic/core/connection.c`
- `sed -n '1934,1934p' net/tquic/core/connection.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Replace the ad-hoc parsing with calls to the existing safe header parser `tquic_parse_long_header()`, or add proper bounds checks before every `data[hdr_offset]` access.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-033 -- Install Secrets Accesses State Without Lock After Unlock

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:2, lines:5, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_ku_derive_keys" "net/tquic/crypto/key_update.c"`
- `sed -n '878,878p' net/tquic/crypto/key_update.c`
- `sed -n '881,881p' net/tquic/crypto/key_update.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/crypto/key_update.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Copy the secrets into local variables under the lock, then derive from
the local copies (the pattern already used correctly in
`tquic_initiate_key_update` at lines 392-405). The results should be committed
back under the lock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-034 -- Integer overflow in `tquic_hs_build_ch_extensions` PSK identity length calculations

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, lines:2, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_build_ch_extensions" "net/tquic/crypto/handshake.c"`
- `sed -n '1224,1234p' net/tquic/crypto/handshake.c`
- `sed -n '1217,1218p' net/tquic/crypto/handshake.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Check for u32 overflow in the accumulation loop. Validate that
the total extension length fits in a u16.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-037 -- Missing SKB Tailroom Check in Coalesced Packet Output

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory, other, security.

**Key evidence present:** file:1, sym:1, lines:2, snippet:4

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_output" "net/quic/tquic/tquic_output.c"`
- `sed -n '1356,1356p' net/quic/tquic/tquic_output.c`
- `sed -n '981,981p' net/quic/tquic/tquic_output.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `BUILD_BUG_ON(TQUIC_MAX_HEADER_SIZE > 64)` or use
`min(header_len, 64)` as a defense.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-038 -- Nested Lock Hierarchy Violation in Timer Code

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, sym:4, lines:5, snippet:5

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_timer_update_pto" "net/quic/tquic/tquic_timer.c"`
- `sed -n '975,1029p' net/quic/tquic/tquic_timer.c`
- `sed -n '820,870p' net/quic/tquic/tquic_timer.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_timer.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Standardize ALL uses of `rs->lock` and `pns->lock` to use `spin_lock_bh` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-044 -- PADDING Frame Infinite Skip Without Bound on Encrypted Payload

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:3, lines:5, snippet:3

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_rx_ctx" "net/tquic/tquic_input.c"`
- `sed -n '565,571p' net/tquic/tquic_input.c`
- `sed -n '1901,1901p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a bounds check before decoding the packet number:
```c
if (ctx.offset + pkt_num_len > len)
    return -EINVAL;
``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-045 -- Path Pointer Use After Lock Release

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:6, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "sockaddr_storage" "net/quic/tquic/tquic_input.c"`
- `sed -n '242,243p' net/quic/tquic/tquic_input.c`
- `sed -n '268,285p' net/quic/tquic/tquic_input.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Take a reference on the path before releasing the lock: `tquic_path_get(found)` and require callers to call `tquic_path_put()`. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-046 -- Per-frame kzalloc + kmalloc in TX path

**Severity:** S0 | **Category:** memory | **Sources:** A,B | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, memory.
- Sources disagree on severity: Severity disagreement across reports: S0, S2.

**Key evidence present:** file:5, sym:18, lines:5, snippet:4

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "cache" "net/tquic/tquic_output.c"`
- `sed -n '1806,1826p' net/tquic/tquic_output.c`
- `sed -n '1819,1825p' net/tquic/tquic_output.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** 1. Use a slab cache (`kmem_cache`) for `tquic_pending_frame` structs (fixed size, high churn).
2. Eliminate the intermediate data copy entirely -- write STREAM frame data directly into the skb payload buffer during `tquic_assemble_packet()`. The current architecture allocates frame->data, copies ... Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-047 -- Per-Packet crypto_aead_setkey on Shared AEAD Handle -- Race Condition

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:4, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_decrypt_packet" "net/tquic/crypto/tls.c"`
- `sed -n '622,622p' net/tquic/crypto/tls.c`
- `sed -n '679,679p' net/tquic/crypto/tls.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/crypto/tls.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use separate AEAD transform handles for TX and RX, each with the key
set once during key installation (not per-packet). The `quic_crypto.c` file
already does this correctly with `tx_aead` and `rx_aead` -- the `tls.c`
implementation should follow the same pattern.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-048 -- Priority PRIORITY_UPDATE Parsing Off-by-Two in Loop Bound

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, lines:2, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '633,633p' net/quic/tquic/core/priority.c`
- `sed -n '637,637p' net/quic/tquic/core/priority.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Implement proper Structured Field Dictionary parsing per RFC 8941. Validate the priority field value format strictly. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-050 -- quic_packet.c Stream Frame - Uncapped Stream Creation

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, memory, other.
- Sources disagree on severity: Severity disagreement across reports: S0, S2.

**Key evidence present:** file:1, sym:3, lines:3, snippet:3

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "quic_packet" "net/quic/tquic/core/quic_packet.c"`
- `sed -n '1248,1248p' net/quic/tquic/core/quic_packet.c`
- `sed -n '158,158p' net/quic/tquic/core/quic_packet.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Replace `tquic_stream_create_internal` with
`tquic_stream_open_incoming` which validates peer's MAX_STREAMS limit.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-051 -- Race Condition Between `tquic_destroy_sock()` and Poll/Sendmsg/Recvmsg

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, correctness, other.
- Sources disagree on severity: Severity disagreement across reports: S0, S1, S2.

**Key evidence present:** file:1, sym:9, lines:1, snippet:3

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "read_once" "net/tquic/tquic_socket.c"`
- `sed -n '568,568p' net/tquic/tquic_socket.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** This is acceptable for poll() semantics (spurious wakeups are allowed), but document the intentional lockless access. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-053 -- Retry Token Validation -- Plaintext Buffer Overread

**Severity:** S0 | **Category:** memory | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, lines:1, snippet:3

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '1195,1195p' net/tquic/core/connection.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `if (ciphertext_len > sizeof(plaintext)) return -EINVAL;` before the memcpy. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-054 -- Server Accept CID Parsing Missing Bounds Checks -- Buffer Over-Read

**Severity:** S0 | **Category:** memory | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, sym:1, lines:2, snippet:3

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_cid" "net/tquic/core/connection.c"`
- `sed -n '2450,2450p' net/tquic/core/connection.c`
- `sed -n '2509,2509p' net/tquic/core/connection.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add bounds validation:
```c
if (offset >= len) goto err_free;
dcid_len = data[offset++];
if (dcid_len > TQUIC_MAX_CID_LEN) goto err_free;
if (offset + dcid_len > len) goto err_free;
```

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-055 -- Slab Cache Decryption Buffer May Be Too Small for Payload

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, memory, other.
- Sources disagree on severity: Severity disagreement across reports: S0, S1, S2, S3.

**Key evidence present:** file:1, sym:5, lines:10, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_process_stream_frame" "net/quic/tquic/tquic_input.c"`
- `sed -n '944,944p' net/quic/tquic/tquic_input.c`
- `sed -n '909,909p' net/quic/tquic/tquic_input.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a comment explaining why `_bh` is not needed in the receive path. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-056 -- Sleep-in-Atomic Context

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:7, lines:2, snippet:4

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_path" "net/tquic/tquic_migration.c"`
- `sed -n '1395,1395p' net/tquic/tquic_migration.c`
- `sed -n '503,503p' net/tquic/tquic_migration.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-058 -- Stack buffer overflow in `tquic_hs_hkdf_expand_label` -- unbounded label/context write to 512-byte stack buffer

**Severity:** S0 | **Category:** memory | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:8, lines:1, snippet:5

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_handshake" "net/tquic/crypto/handshake.c"`
- `sed -n '762,762p' net/tquic/crypto/handshake.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add bounds checking throughout `tquic_hs_build_ch_extensions`. Every
write to `p` must verify `p + N <= buf + buf_len` before writing. Use a macro similar to
`TP_CHECK_SPACE` from the transport params encoder.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-059 -- Stateless Reset Bypasses State Machine

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, correctness.

**Key evidence present:** file:1, sym:7, lines:1, snippet:3

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_conn_set_state" "net/tquic/tquic_input.c"`
- `sed -n '1308,1308p' net/tquic/tquic_input.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use the state machine: call `tquic_conn_set_state(conn, TQUIC_CONN_CLOSED, TQUIC_REASON_PEER_CLOSE)` instead. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-060 -- Stream Data Delivery Uses u64 Length with u32 alloc_skb

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, memory.

**Key evidence present:** file:1, sym:2, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stream" "net/quic/tquic/core/quic_packet.c"`
- `sed -n '1198,1198p' net/quic/tquic/core/quic_packet.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/core/quic_packet.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Cap `len` to a reasonable maximum (e.g., 16384 or the
connection's max_stream_data) before allocation.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-061 -- tquic_conn_server_accept() -- err_free leaks registered CIDs, work items, timers, crypto state

**Severity:** S0 | **Category:** security | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:6, lines:5, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_crypto_init_versioned" "net/quic/tquic/core/connection.c"`
- `sed -n '2518,2518p' net/quic/tquic/core/connection.c`
- `sed -n '2524,2524p' net/quic/tquic/core/connection.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Create incremental error labels:
```
err_free_crypto:
    tquic_crypto_free(conn->crypto_state);
    conn->crypto_state = NULL;
err_free_cids:
    /* remove added CIDs */
err_free_cs:
    skb_queue_purge(&cs->zero_rtt_buffer);
    kfree(cs);
    conn->state_machine = NULL;
```

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-065 -- Transcript Buffer Reallocation Doubling Overflow

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, lines:3, snippet:2

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '842,842p' net/quic/tquic/crypto/handshake.c`
- `sed -n '849,849p' net/quic/tquic/crypto/handshake.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `check_mul_overflow` or cap `new_alloc` more conservatively:
```c
u32 new_alloc;
if (check_mul_overflow(new_len, 2U, &new_alloc))
    new_alloc = TQUIC_MAX_TRANSCRIPT_SIZE;
new_alloc = max(new_alloc, 4096U);
```

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-068 -- Use-After-Free in Path Lookup

**Severity:** S0 | **Category:** memory | **Sources:** A,B | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, perf.

**Key evidence present:** file:2, sym:8, lines:4, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "memcmp" "net/tquic/tquic_input.c"`
- `sed -n '245,245p' net/tquic/tquic_input.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** - Compare by `ss_family`, then compare only the relevant address+port fields for that family. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-069 -- Version Negotiation Packet Overflow -- Unsanitized CID Lengths in tquic_send_version_negotiation

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on severity: Severity disagreement across reports: S0, S1, S3.

**Key evidence present:** file:1, sym:4, lines:4, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_cid" "net/tquic/core/connection.c"`
- `sed -n '961,961p' net/tquic/core/connection.c`
- `sed -n '965,965p' net/tquic/core/connection.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Calculate required size upfront and validate against `sizeof(packet)`.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-136 -- `ext->final_size = -1` Uses Signed Overflow

**Severity:** S1 | **Category:** correctness | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Define `#define TQUIC_STREAM_SIZE_UNKNOWN U64_MAX` and use it consistently. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/stream.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-137 -- Constant-Time CID Validation Has Branching on Lengths

**Severity:** S1 | **Category:** memory | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: build, memory, other, security.

**Key evidence present:** file:1, sym:4, lines:1, snippet:4

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_ct_memcmp" "net/tquic/security/quic_exfil.c"`
- `sed -n '394,394p' net/tquic/security/quic_exfil.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/security/quic_exfil.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-138 -- Custom ASN.1 Parser - High Attack Surface

**Severity:** S1 | **Category:** security | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:4

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "decoder" "net/tquic/crypto/cert_verify.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Consider using the kernel's built-in ASN.1 decoder (`lib/asn1_decoder.c`) and the x509 certificate parser (`crypto/asymmetric_keys/x509_cert_parser.c`) which have been battle-tested. If the custom parser must be retained, add fuzzing tests targeting all parsing entry points. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-139 -- Function Pointer Stored in skb->cb Without Validation

**Severity:** S1 | **Category:** security | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Sources disagree on category: Category disagreement across reports: correctness, other, security.

**Key evidence present:** file:1, sym:5, lines:2, snippet:3

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "corrupted" "net/tquic/security/quic_exfil.c"`
- `sed -n '71,71p' net/tquic/security/quic_exfil.c`
- `sed -n '533,533p' net/tquic/security/quic_exfil.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-140 -- HTTP/3 Request: TOCTOU Between State Check and Send

**Severity:** S1 | **Category:** concurrency | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "h3_request_send_headers" "net/tquic/http3/http3_request.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/http3/http3_request.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Either hold the lock during the entire send operation, or re-validate state after acquiring any needed resources. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/http3_request.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-141 -- HTTP/3 Settings Frame Length Truncation

**Severity:** S1 | **Category:** security | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other, security.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "h3_connection_send_settings" "net/tquic/http3/http3_stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use proper QUIC variable-length integer encoding for the frame length, or validate that `settings_len <= 255` before the cast and return an error if exceeded. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/http3_stream.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-142 -- Load Balancer Encryption Key Not Zeroized on Destroy

**Severity:** S1 | **Category:** security | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** file:1, sym:5, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "crypto_free_sync_skcipher" "net/tquic/lb/quic_lb.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/lb/quic_lb.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-143 -- No CAP_NET_ADMIN Check for Tunnel Creation

**Severity:** S1 | **Category:** security | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:8, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "capable" "net/tquic/tquic_tunnel.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-144 -- Path Metrics Netlink: Missing CAP_NET_ADMIN Permission Check

**Severity:** S1 | **Category:** security | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:5

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "export" "net/tquic/diag/path_metrics.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `.policy` with `GENL_ADMIN_PERM` flag or explicit `CAP_NET_ADMIN` check in each handler. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/diag/path_metrics.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-145 -- Per-Call crypto_aead_setkey in Encrypt/Decrypt Hot Path

**Severity:** S1 | **Category:** security | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:4

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "changes" "net/tquic/crypto/tls.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Set the key once when it changes (at key installation time), not on every packet. Store the AEAD transform with the key pre-set in `tquic_key_generation`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/tls.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-146 -- Per-Call crypto_alloc_aead in 0-RTT Encrypt/Decrypt

**Severity:** S1 | **Category:** security | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: perf, security.

**Key evidence present:** file:1, sym:6

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "crypto_alloc_aead" "net/tquic/crypto/zero_rtt.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Pre-allocate the AEAD transform during `tquic_zero_rtt_init()` or `tquic_zero_rtt_attempt()` and reuse it for the lifetime of the 0-RTT state. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-147 -- QPACK Decoder: Unbounded Blocked Stream Memory Exhaustion

**Severity:** S1 | **Category:** concurrency | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:5

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "blocks" "net/tquic/http3/qpack_decoder.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/http3/qpack_decoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Track total blocked stream memory and enforce a per-connection limit (e.g., 1MB total blocked stream data). Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/qpack_decoder.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-148 -- QPACK Encoder: Insert Count Increment Overflow

**Severity:** S1 | **Category:** memory | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory, other.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "qpack_encoder" "net/tquic/http3/qpack_encoder.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/http3/qpack_encoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Validate that `known_received_count + value <= insert_count` (the total entries ever inserted) and that the addition does not overflow. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/qpack_encoder.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-149 -- Race Condition in Key Update Secret Installation

**Severity:** S1 | **Category:** concurrency | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:4

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "derivation" "net/tquic/crypto/key_update.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/crypto/key_update.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a state flag (e.g., `keys_installing`) that prevents concurrent use during the derivation window. Set the flag under the first lock acquisition, derive keys, then clear it under the second lock acquisition. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/key_update.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-150 -- RSA-PSS Hash Algorithm Hardcoded to SHA-256

**Severity:** S1 | **Category:** security | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "verification" "net/tquic/crypto/cert_verify.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Parse the RSA-PSS AlgorithmIdentifier parameters to extract the actual hash algorithm. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-151 -- Secrets not zeroized on error paths in key derivation functions

**Severity:** S1 | **Category:** security | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Sources disagree on category: Category disagreement across reports: correctness, other, security.
- Sources disagree on severity: Severity disagreement across reports: S1, S2.

**Key evidence present:** file:1, sym:4, lines:5, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "consumed" "net/tquic/crypto/handshake.c"`
- `sed -n '995,1045p' net/tquic/crypto/handshake.c`
- `sed -n '1050,1071p' net/tquic/crypto/handshake.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Zeroize these secrets using `memzero_explicit()` as soon as they have been consumed (after key derivation and ticket issuance). Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-152 -- Stream State Machine Allows Unexpected Transitions from OPEN

**Severity:** S1 | **Category:** correctness | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:6, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "data_sent" "net/tquic/core/stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add TQUIC_STREAM_SEND and TQUIC_STREAM_RECV as valid transitions from OPEN. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/stream.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-153 -- Timing Normalization Can Block in Packet Processing Path

**Severity:** S1 | **Category:** concurrency | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:9, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "context" "net/tquic/security/quic_exfil.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/security/quic_exfil.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-154 -- Unbounded Connection Creation via Netlink

**Severity:** S1 | **Category:** security | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:5, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "connections" "net/tquic/tquic_netlink.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-155 -- WebTransport Context Destroy: Lock Drop During Iteration

**Severity:** S1 | **Category:** memory | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "context_destroy" "net/tquic/http3/webtransport.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/http3/webtransport.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a safe iteration pattern: move items to a local list under the lock, release the lock, then process the local list. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/webtransport.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-156 -- WebTransport: Unbounded Capsule Buffer Growth

**Severity:** S1 | **Category:** security | **Sources:** A,B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "capsule" "net/tquic/http3/webtransport.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Enforce a maximum capsule buffer size (e.g., 64KB or configurable via socket option) and reject connections that exceed it with `H3_EXCESSIVE_LOAD`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/webtransport.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-157 -- `quic_offload.c` Version Field Shift Without Cast

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:2, sym:1, lines:2, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "quic_offload" "net/quic/tquic/quic_offload.c"`
- `sed -n '429,429p' net/quic/tquic/quic_offload.c`
- `sed -n '474,475p' net/quic/tquic/quic_offload.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Cast to `u32` before shift:
```c
version = ((u32)data[1] << 24) | ((u32)data[2] << 16) |
          ((u32)data[3] << 8) | data[4];
``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-160 -- `tquic_hs_build_ch_extensions` -- ALPN extension length written as 2-byte but can overflow u16

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:2, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_set_alpn" "net/tquic/crypto/handshake.c"`
- `sed -n '2964,2964p' net/tquic/crypto/handshake.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Validate ALPN total length fits in u16 in `tquic_hs_set_alpn()`.
Add a reasonable cap on `alpn_count`.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-163 -- `tquic_hs_hkdf_expand_label` -- `context_len` truncated to u8

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_hkdf_expand_label" "net/tquic/crypto/handshake.c"`
- `sed -n '762,762p' net/tquic/crypto/handshake.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** ```c
if (context_len > 255)
    return -EINVAL;
```

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-165 -- `tquic_hs_process_new_session_ticket` -- memory leak of old ticket data on re-entry

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: other, security.
- Sources disagree on severity: Severity disagreement across reports: S1, S2.

**Key evidence present:** file:1, sym:3, lines:2, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_process_new_session_ticket" "net/tquic/crypto/handshake.c"`
- `sed -n '2609,2609p' net/tquic/crypto/handshake.c`
- `sed -n '2610,2610p' net/tquic/crypto/handshake.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Track whether `hs->session_ticket` is owned or borrowed. Only free
owned tickets. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-166 -- `tquic_hs_process_server_hello` -- session ID comparison not fully bounds-safe

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: other, security.
- Sources disagree on severity: Severity disagreement across reports: S1, S2.

**Key evidence present:** file:1, sym:1, lines:4, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_process_server_hello" "net/tquic/crypto/handshake.c"`
- `sed -n '1423,1423p' net/tquic/crypto/handshake.c`
- `sed -n '1426,1426p' net/tquic/crypto/handshake.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `if (p >= end) return -EINVAL;` before `session_id_len = *p++;`.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-169 -- accept() Uses spin_lock_bh on sk_lock.slock While lock_sock() Is Held

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on severity: Severity disagreement across reports: S1, S2.

**Key evidence present:** file:2, sym:5, lines:4, snippet:3

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "lock_sock" "net/quic/tquic/tquic_socket.c"`
- `sed -n '95,95p' net/quic/tquic/tquic_socket.c`
- `sed -n '2841,2854p' net/quic/tquic/tquic_socket.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Remove the inner `spin_lock_bh(&sk->sk_lock.slock)` calls in `tquic_accept()`. The `lock_sock()` already provides sufficient serialization. If the accept queue needs to be accessed from softirq context, use a dedicated spinlock instead of the socket's backing slock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-173 -- Bloom Filter Has High False Positive Rate at Scale

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, lines:1, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '913,916p' net/tquic/crypto/zero_rtt.h`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Increase `TQUIC_REPLAY_BLOOM_BITS` to at least `(1 << 20)` (1M bits = 128KB) for production use, or make it configurable via sysctl.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-174 -- Bonding State Machine Drop-Relock Without Re-validation

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, sym:3, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_bonding_destroy" "net/quic/tquic/bond/tquic_bonding.c"`
- `sed -n '174,174p' net/quic/tquic/bond/tquic_bonding.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/bond/tquic_bonding.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a "destroying" flag to `bc` checked after relock, or use refcounting on `bc`. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-177 -- conn->lock held during path selection on every TX packet

**Severity:** S1 | **Category:** concurrency | **Sources:** A,B | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.

**Key evidence present:** file:2, sym:8, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "read_once" "net/tquic/tquic_output.c"`
- `sed -n '1121,1132p' net/tquic/tquic_output.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** For the single-path fast path, use `READ_ONCE(conn->active_path)` without the lock. Only take the lock when a scheduler is configured. Consider RCU protection for the path list. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-178 -- conn->lock released and reacquired during output flush stream iteration

**Severity:** S1 | **Category:** concurrency | **Sources:** A,B | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.

**Key evidence present:** file:2, sym:7, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "operations" "net/tquic/tquic_output.c"`
- `sed -n '2058,2072p' net/tquic/tquic_output.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Merge the two critical sections into one: check flow control credit and begin stream iteration under the same `conn->lock` hold. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-179 -- conn->paths_lock in RX path for every packet

**Severity:** S1 | **Category:** memory | **Sources:** A,B | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, memory.

**Key evidence present:** file:2, sym:7, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "first" "net/tquic/tquic_input.c"`
- `sed -n '251,258p' net/tquic/tquic_input.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a hash table (rhashtable) for path-by-address lookup. For single-path connections, cache the last-used path and check it first (fast-path optimization). Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-180 -- CONNECTION_CLOSE uses kmalloc for small buffer

**Severity:** S1 | **Category:** perf | **Sources:** A,B | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, perf.

**Key evidence present:** file:2, sym:3, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "does" "net/tquic/tquic_output.c"`
- `sed -n '1950,1951p' net/tquic/tquic_output.c`
- `sed -n '1877,1877p' net/tquic/tquic_output.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a stack buffer like `tquic_send_ack()` does (line 1877: `u8 buf_stack[128]`). A 256-byte stack allocation is safe in kernel context. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-183 -- ECN Counter Values Passed Directly to TQUIC_ADD_STATS Without Overflow Check

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, lines:3, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_input" "net/tquic/tquic_input.c"`
- `sed -n '702,707p' net/tquic/tquic_input.c`
- `sed -n '764,764p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Validate that ECN counts are monotonically increasing from previous values. Store previous ECN counts per-path and only react to the *increase*, not the absolute value (as RFC 9002 Section 7.1 requires). The comment at line 759-763 acknowledges this is missing. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-184 -- EKU Derives Keys Using KU hash_tfm Without KU Lock

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:1, lines:3, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "eku_hkdf_extract" "net/tquic/crypto/extended_key_update.c"`
- `sed -n '821,821p' net/tquic/crypto/extended_key_update.c`
- `sed -n '829,829p' net/tquic/crypto/extended_key_update.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/crypto/extended_key_update.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Either (a) hold the KU lock around `hash_tfm` access, or (b) copy
`hash_tfm` under the KU lock and use the copy (though crypto transforms are
not reference-counted, so this requires ensuring the transform outlives usage).
For the PSK, copy it under the EKU lock before releasing.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-190 -- getsockopt PSK Identity - Missing Length Validation

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, memory.
- Sources disagree on severity: Severity disagreement across reports: S1, S2.

**Key evidence present:** file:1, sym:1, lines:2, snippet:3

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_socket" "net/quic/tquic/tquic_socket.c"`
- `sed -n '1317,1317p' net/quic/tquic/tquic_socket.c`
- `sed -n '1334,1334p' net/quic/tquic/tquic_socket.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `if (identity_len > len) return -EINVAL;` before
the copy_to_user call.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-191 -- GRO Coalesce Uses Hardcoded 8-byte CID Comparison

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_input" "net/tquic/tquic_input.c"`
- `sed -n '2249,2253p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** The GRO coalesce function needs to know the actual CID length. Pass it via skb metadata or look it up from connection state. Also add length checks:
```c
if (skb1->len < 1 + cid_len || skb2->len < 1 + cid_len)
    return false;
``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-192 -- GRO Flush Unlock-Relock Loop Without Re-validation

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, sym:2, lines:2, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_gro_receive_internal" "net/quic/tquic/tquic_input.c"`
- `sed -n '2306,2306p' net/quic/tquic/tquic_input.c`
- `sed -n '2309,2309p' net/quic/tquic/tquic_input.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** After the loop, set `gro->held_count = skb_queue_len(&gro->hold_queue)` instead of hard-coding 0. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-195 -- HIGH: GRO stats use global atomic64 on every packet

**Severity:** S1 | **Category:** correctness | **Sources:** A,B | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: api, concurrency, correctness, perf.
- Sources disagree on severity: Severity disagreement across reports: S1, S2, S3.

**Key evidence present:** file:4, sym:8, lines:3, snippet:3

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "atomic64_inc" "net/tquic/tquic_offload.c"`
- `sed -n '235,253p' net/tquic/tquic_offload.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use per-CPU counters for GRO statistics, aggregate on read. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-200 -- Infinite retry loop on EMSGSIZE/EEXIST

**Severity:** S1 | **Category:** concurrency | **Sources:** A,B | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, correctness.

**Key evidence present:** file:2, sym:4, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_skb_zerocopy_iter_stream" "net/tquic/tquic_zerocopy.c"`
- `sed -n '315,318p' net/tquic/tquic_zerocopy.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_zerocopy.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a retry counter (e.g., max 3 retries) and return an error after exhausting retries. Alternatively, adjust the chunk size downward on EMSGSIZE before retrying. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-202 -- io_uring buffer ring spinlock per get/put operation

**Severity:** S1 | **Category:** concurrency | **Sources:** A,B | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on severity: Severity disagreement across reports: S1, S2.

**Key evidence present:** file:3, sym:8, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "acquisitions" "net/tquic/io_uring.c"`
- `sed -n '804,838p' net/tquic/io_uring.c`
- `sed -n '799,838p' net/tquic/io_uring.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/io_uring.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** If get/put are guaranteed to be called from different contexts (producer vs consumer), replace the spinlock with a lockless SPSC ring using `smp_store_release`/`smp_load_acquire` on head/tail. If multi-producer or multi-consumer, consider per-CPU rings or batch get/put APIs. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-205 -- memset Instead of memzero_explicit for Old Key Material

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, sym:1, lines:3, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "memzero_explicit" "net/tquic/crypto/key_update.c"`
- `sed -n '435,435p' net/tquic/crypto/key_update.c`
- `sed -n '627,628p' net/tquic/crypto/key_update.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Replace all `memset(..., 0, ...)` clearing key material with
`memzero_explicit()`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-206 -- Missing kfree_sensitive for key material in crypto/handshake.c extensions buffer

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "kfree_sensitive" "net/quic/tquic/crypto/handshake.c"`
- `sed -n '1280,1280p' net/quic/tquic/crypto/handshake.c`
- `sed -n '3260,3260p' net/quic/tquic/crypto/handshake.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-211 -- payload_len Subtraction Underflow in Long Header Parsing

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, lines:2, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '590,601p' net/tquic/core/packet.c`
- `sed -n '619,619p' net/tquic/core/packet.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `if (hdr->payload_len < hdr->pn_len) return -EPROTO;` before the subtraction. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-213 -- Procfs trusted_cas Writable Without Privilege Check

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on severity: Severity disagreement across reports: S1, S2.

**Key evidence present:** file:1, sym:1, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "current_cred" "net/tquic/crypto/cert_verify.c"`
- `sed -n '2772,2808p' net/tquic/crypto/cert_verify.c`
- `sed -n '2615,2615p' net/tquic/crypto/cert_verify.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `capable(CAP_NET_ADMIN)` check in the write handler. Consider using 0600 permissions. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-217 -- Redundant triple-counting of statistics

**Severity:** S1 | **Category:** api | **Sources:** A,B | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: api, concurrency.
- Sources disagree on severity: Severity disagreement across reports: S1, S2.

**Key evidence present:** file:4, sym:11, lines:7, snippet:4

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "atomic64_add" "net/tquic/napi.c"`
- `sed -n '307,308p' net/tquic/napi.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Remove the `tquic_napi_global_stats` atomic counters entirely. Use `tquic_napi_aggregate_pcpu_stats()` (already implemented at line 75) when global totals are needed for /proc display. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-218 -- reed_solomon.c -- four-allocation group without individual NULL checks

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, lines:1, snippet:3

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '590,590p' net/quic/tquic/fec/reed_solomon.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-220 -- Retry Packet Stack Buffer Overflow

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, lines:2, snippet:2

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '1379,1379p' net/tquic/core/connection.c`
- `sed -n '1401,1401p' net/tquic/core/connection.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Allocate `packet`, `token`, and `pseudo_packet` on the heap using `kmalloc`.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-225 -- Security Hardening Pre-HS Atomic TOCTOU

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "atomic_inc_return" "net/quic/tquic/security_hardening.c"`
- `sed -n '280,280p' net/quic/tquic/security_hardening.c`
- `sed -n '289,289p' net/quic/tquic/security_hardening.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/security_hardening.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `atomic_inc_return()` and check the result instead of separate read + increment. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-226 -- Session Ticket Decode Missing Bounds Check on PSK Copy

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** file:1, lines:3, snippet:2

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '1160,1160p' net/tquic/crypto/zero_rtt.c`
- `sed -n '1143,1143p' net/tquic/crypto/zero_rtt.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/zero_rtt.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-231 -- tquic_process_stream_frame Allocates skb Based on Attacker-Controlled length

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:4, lines:4, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "alloc_skb" "net/tquic/tquic_input.c"`
- `sed -n '944,944p' net/tquic/tquic_input.c`
- `sed -n '909,909p' net/tquic/tquic_input.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Move the `sk_rmem_alloc` check BEFORE the `alloc_skb()` call to avoid the allocation entirely when the buffer is full. Also consider a global receive buffer cap. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-233 -- tquic_stream_recv_data Potential Integer Overflow in Flow Control Check

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stream_recv_data" "net/quic/tquic/core/stream.c"`
- `sed -n '697,699p' net/quic/tquic/core/stream.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add overflow check before the addition: `if (skb->len > U64_MAX - offset) return -EOVERFLOW;`

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-236 -- tquic_stream_socket_create Double-Free on fd Failure

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:4, lines:4, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stream_socket_create" "net/quic/tquic/tquic_stream.c"`
- `sed -n '213,231p' net/quic/tquic/tquic_stream.c`
- `sed -n '219,219p' net/quic/tquic/tquic_stream.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/tquic_stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Set `sk_user_data` to NULL before calling `tquic_sock_map_fd`, or set it only after successful fd allocation. Fix the `sock_alloc_file` failure path to release the socket.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-237 -- tquic_zerocopy_sendmsg -- uarg leak on partial send

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:2, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_zerocopy_sendmsg" "net/quic/tquic/tquic_zerocopy.c"`
- `sed -n '360,360p' net/quic/tquic/tquic_zerocopy.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** On the error path, dequeue and free all SKBs added during
this call, or commit the partial send as successful (return `copied` instead
of error if `copied > 0`).

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-240 -- Zero-RTT Session Ticket Deserialization Trusts Length Fields

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, lines:1, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '1140,1160p' net/quic/tquic/crypto/zero_rtt.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/crypto/zero_rtt.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-309 -- Bloom Filter False Negatives Allow Replay

**Severity:** S2 | **Category:** security | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "detected" "net/tquic/crypto/zero_rtt.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** This is an inherent limitation of bloom filters. Document this as a known limitation. Consider augmenting with a small exact-match cache for recent tickets (last N tickets stored exactly) to eliminate the rotation window for the most common case. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-310 -- Decoy Packet Size Calculation Can Underflow

**Severity:** S2 | **Category:** security | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, sym:4, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "alloc_skb" "net/tquic/security/quic_exfil.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-311 -- EKU Request ID Increment Outside Lock

**Severity:** S2 | **Category:** concurrency | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:1, lines:2

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_eku_request" "net/tquic/crypto/extended_key_update.c"`
- `sed -n '440,440p' net/tquic/crypto/extended_key_update.c`
- `sed -n '451,451p' net/tquic/crypto/extended_key_update.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/crypto/extended_key_update.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Keep the lock held through request allocation and insertion, or use an atomic increment for the request ID. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-312 -- HP Key Rotation Swaps Old Keys Without Zeroization

**Severity:** S2 | **Category:** security | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, sym:2, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "memzero_explicit" "net/tquic/crypto/header_protection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Ensure `memzero_explicit()` is called on the mask buffer in all return paths, including error paths. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/header_protection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-313 -- HTTP/3 Connection: O(n) Push Entry Counting

**Severity:** S2 | **Category:** security | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "client" "net/tquic/http3/http3_conn.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Maintain a running counter of push entries instead of counting on demand. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/http3_conn.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-314 -- HTTP/3 Frame Parsing: 16MB Maximum Frame Payload

**Severity:** S2 | **Category:** security | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, perf, security.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "frames" "net/tquic/http3/http3_frame.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Consider reducing the default limit to 1MB or making it configurable. Most HTTP/3 frames (HEADERS, SETTINGS, GOAWAY) should be much smaller. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/http3_frame.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-315 -- HTTP/3 Settings Parser: TOCTOU on Settings Count

**Severity:** S2 | **Category:** concurrency | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "processing" "net/tquic/http3/http3_frame.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/http3/http3_frame.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Ensure the input buffer is exclusively owned during parsing, or perform length validation inline during the single-pass parse. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/http3_frame.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-316 -- Missing Bounds Check on tbs Pointer in Signature Parse

**Severity:** S2 | **Category:** memory | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** file:1, sym:4

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "buffer" "net/tquic/crypto/cert_verify.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/cert_verify.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Validate that `cert->tbs + cert->tbs_len <= data + total_len` before computing `remaining`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-318 -- Path Score Computation Can Overflow in Migration Target Selection

**Severity:** S2 | **Category:** memory | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory, other.

**Key evidence present:** file:1, sym:4, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "bandwidth" "net/tquic/tquic_migration.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Reorder operations to divide before multiplying, or cap intermediate values. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-319 -- Per-Call crypto_alloc_shash in Stateless Reset Token Generation

**Severity:** S2 | **Category:** security | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stateless_reset_generate_token" "net/tquic/tquic_stateless_reset.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Pre-allocate a per-CPU or global HMAC transform and reuse it. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_stateless_reset.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-320 -- QAT Encrypt Sets Key on Every Call

**Severity:** S2 | **Category:** security | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: perf, security.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "crypto_aead_setkey" "net/tquic/crypto/hw_offload.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Set the key once during context initialization and only re-set on key update. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/hw_offload.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-321 -- Qlog Ring Buffer: Not Truly Lock-Free

**Severity:** S2 | **Category:** concurrency | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "buffer" "net/tquic/diag/qlog.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/diag/qlog.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Either implement a true lock-free ring buffer (using `smp_store_release`/`smp_load_acquire` pairs) or document the locking requirement clearly. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/diag/qlog.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-322 -- Qlog: JSON Strings Not Escaped

**Severity:** S2 | **Category:** api | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: api, other.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "json" "net/tquic/diag/qlog.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Implement JSON string escaping for all string values emitted in qlog JSON output. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/diag/qlog.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-323 -- QPACK Encoder/Decoder: Excessive Stack Usage

**Severity:** S2 | **Category:** memory | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory, other.

**Key evidence present:** file:2, sym:5

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "chain" "net/tquic/http3/qpack_encoder.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/http3/qpack_encoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Allocate these buffers dynamically with `kmalloc(GFP_ATOMIC)` or use a pre-allocated per-connection buffer. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/qpack_encoder.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-324 -- QPACK Huffman Decoder: O(n*256) Complexity

**Severity:** S2 | **Category:** security | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "decoder" "net/tquic/http3/qpack.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Replace with a 256-entry lookup table or state-machine-based decoder (standard approach for HPACK/QPACK Huffman). Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/qpack.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-325 -- QPACK Integer Decode: Shift Overflow

**Severity:** S2 | **Category:** memory | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory, other.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "behavior" "net/tquic/http3/qpack.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/http3/qpack.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a check: `if (shift > 62) return -H3_ERR_QPACK_DECOMPRESSION_FAILED;` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/qpack.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-326 -- Time Parsing Does Not Validate Digit Characters

**Severity:** S2 | **Category:** security | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, sym:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "isdigit" "net/tquic/crypto/cert_verify.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `isdigit()` checks for all time component characters before conversion. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-327 -- Transcript Buffer Not Zeroized Before Free

**Severity:** S2 | **Category:** security | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** file:1, sym:4

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "kfree" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `kfree_sensitive()` or call `memzero_explicit()` on the transcript buffer before freeing. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-328 -- Tunnel Port Allocation Unsigned Underflow

**Severity:** S2 | **Category:** correctness | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "none" "net/tquic/tquic_tunnel.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-348 -- `tquic_proc.c` Buffer Overflow in Hex CID Formatting

**Severity:** S2 | **Category:** memory | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:2, lines:3, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_proc" "net/quic/tquic/tquic_proc.c"`
- `sed -n '414,414p' net/quic/tquic/tquic_proc.c`
- `sed -n '604,604p' net/quic/tquic/tquic_proc.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/tquic_proc.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-351 -- `tquic_sock_setsockopt()` Reads `int` for Some Options But Accepts `optlen >= sizeof(int)` Without Capping

**Severity:** S2 | **Category:** api | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Sources disagree on category: Category disagreement across reports: api, other.

**Key evidence present:** file:1, sym:4, lines:5, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "definition" "net/tquic/tquic_socket.c"`
- `sed -n '840,840p' net/tquic/tquic_socket.c`
- `sed -n '899,899p' net/tquic/tquic_socket.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-352 -- `transport_params.c` Memcpy with `count * sizeof(u32)` Without Overflow Check

**Severity:** S2 | **Category:** memory | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, lines:1, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '2513,2513p' net/quic/tquic/core/transport_params.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/core/transport_params.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-353 -- ACK Frame Range Count Uses u64 Loop Variable Against size_t max_ranges

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on severity: Severity disagreement across reports: S2, S3.

**Key evidence present:** file:1, lines:1, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '370,370p' net/tquic/core/frame.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-361 -- Certificate Chain Parsing Does Not Verify Issuer-Subject Linkage Before Trust Check

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, lines:1, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '2319,2319p' net/tquic/crypto/cert_verify.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-362 -- CID Sequence Number Rollback on rhashtable Insert Failure

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, correctness.

**Key evidence present:** file:1, lines:1, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '502,502p' net/tquic/core/connection.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Perform the sequence number increment inside the spinlock, or use atomic operations.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-363 -- conn->streams_lock for RB-tree walk on every STREAM frame

**Severity:** S2 | **Category:** concurrency | **Sources:** A,B | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.

**Key evidence present:** file:2, sym:4, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "spin_lock_bh" "net/tquic/tquic_input.c"`
- `sed -n '917,934p' net/tquic/tquic_input.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Consider RCU-protected RB-tree for read-side lookups, or use a lockless hash table for the common case of looking up an already-existing stream. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-367 -- Coupled Congestion Control Division by Zero

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, lines:2, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '897,897p' net/quic/tquic/bond/cong_coupled.c`
- `sed -n '949,949p' net/quic/tquic/bond/cong_coupled.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-370 -- Error Ring Uses Atomics Under Spinlock Unnecessarily

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, sym:1, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_proc" "net/quic/tquic/tquic_proc.c"`
- `sed -n '572,589p' net/quic/tquic/tquic_proc.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_proc.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-372 -- FEC encoder allocates per-symbol in GFP_ATOMIC

**Severity:** S2 | **Category:** memory | **Sources:** A,B | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, memory.

**Key evidence present:** file:2, lines:1, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '111,115p' net/tquic/fec/fec_encoder.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/fec/fec_encoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use slab caches for symbol structs and data buffers. Pre-allocate symbol arrays per block. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-373 -- FEC encoder double lock nesting

**Severity:** S2 | **Category:** concurrency | **Sources:** A,B | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.

**Key evidence present:** file:2, sym:4, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "list_add_tail" "net/tquic/fec/fec_encoder.c"`
- `sed -n '275,283p' net/tquic/fec/fec_encoder.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/fec/fec_encoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Remove `block->lock` when the block is only accessed under `enc->lock`, or redesign to avoid nesting. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-374 -- FEC Encoder Triple-Nested Locking

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, lines:1, snippet:2

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '576,576p' net/quic/tquic/fec/fec_encoder.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-383 -- Key Material Not Zeroized on All Error Paths in tquic_zero_rtt_derive_keys

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, sym:1, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_zero_rtt_derive_keys" "net/tquic/crypto/zero_rtt.c"`
- `sed -n '662,662p' net/tquic/crypto/zero_rtt.c`
- `sed -n '698,698p' net/tquic/crypto/zero_rtt.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `if (ret) memzero_explicit(keys, sizeof(*keys));` before the `out:` label, or zeroize in the `out:` path when `ret != 0`.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-400 -- Pacing work function drops and reacquires lock per packet

**Severity:** S2 | **Category:** concurrency | **Sources:** A,B | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.

**Key evidence present:** file:2, sym:5, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "__skb_dequeue" "net/tquic/tquic_output.c"`
- `sed -n '1396,1421p' net/tquic/tquic_output.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Dequeue a batch of packets under a single lock hold, then send them all without the lock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-404 -- Per-Call skcipher_request Allocation in HP Mask Hot Path

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:1, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hp_key" "net/tquic/crypto/header_protection.c"`
- `sed -n '164,164p' net/tquic/crypto/header_protection.c`
- `sed -n '211,211p' net/tquic/crypto/header_protection.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/crypto/header_protection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Pre-allocate the `skcipher_request` in the `tquic_hp_key` structure
during key setup. Use a per-CPU or per-connection pre-allocated request to
avoid hot-path allocations.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-405 -- Per-Packet kmalloc in Batch Encrypt/Decrypt

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, lines:2, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '708,708p' net/tquic/crypto/hw_offload.c`
- `sed -n '703,703p' net/tquic/crypto/hw_offload.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Allocate a single buffer sized for the largest packet in the batch, or
use a pre-allocated per-CPU bounce buffer. Alternatively, encrypt in-place if
the caller guarantees sufficient tail room (the `data_buf_len` check at line
703 already validates this -- the temporary buffer is unnecessary).

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-409 -- PSK Identity Logged with `tquic_dbg()` -- Sensitive Data in Kernel Logs

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:2, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_dbg" "net/tquic/tquic_socket.c"`
- `sed -n '1202,1202p' net/tquic/tquic_socket.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-410 -- rcu_dereference Outside Explicit RCU Section

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, sym:3, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "sk_buff" "net/quic/tquic/tquic_udp.c"`
- `sed -n '1303,1303p' net/quic/tquic/tquic_udp.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_udp.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-417 -- SmartNIC offload takes dev->lock for every key operation

**Severity:** S2 | **Category:** concurrency | **Sources:** A,B | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.

**Key evidence present:** file:2, sym:3, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "add_key" "net/tquic/offload/smartnic.c"`
- `sed -n '326,328p' net/tquic/offload/smartnic.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/offload/smartnic.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a per-connection lock or a mutex (key operations are not in the data path and can sleep). Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-421 -- Sysctl and Proc Entries Registered in init_net Only

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:4, sym:2, lines:3, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_sysctl" "net/tquic/transport/tcp_fallback.c"`
- `sed -n '843,843p' net/tquic/transport/tcp_fallback.c`
- `sed -n '272,272p' net/tquic/transport/tcp_fallback.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-427 -- tquic_conn_create -- loss_detection_init failure doesn't clean up timers

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:2, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_conn_create" "net/quic/tquic/core/quic_connection.c"`
- `sed -n '495,501p' net/quic/tquic/core/quic_connection.c`
- `sed -n '504,506p' net/quic/tquic/core/quic_connection.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-438 -- Zerocopy entry refcount uses atomic_t

**Severity:** S2 | **Category:** memory | **Sources:** A,B | **Priority:** 4.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (A, B) agree; partial independent confirmation.

**Key evidence present:** file:2, sym:4, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "atomic_t" "net/tquic/tquic_zerocopy.c"`
- `sed -n '58,59p' net/tquic/tquic_zerocopy.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_zerocopy.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Change to `refcount_t` and use `refcount_inc()` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-501 -- Batch Crypto Allocates Per-Packet Temporary Buffer

**Severity:** S3 | **Category:** perf | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, perf, security.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_crypto_batch_encrypt" "net/tquic/crypto/hw_offload.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Perform in-place encryption if the caller's buffer has sufficient space (the `data_buf_len` check already exists), or pre-allocate a shared temporary buffer. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/hw_offload.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-502 -- Certificate Chain Length Limit Checked Late

**Severity:** S3 | **Category:** security | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:17, sym:11

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "csprng" "net/tquic/crypto/cert_verify.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Move the chain length check to the beginning of the loop iteration. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-503 -- Duplicate MODULE_DESCRIPTION in quic_exfil.c

**Severity:** S3 | **Category:** security | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: build, other, security.

**Key evidence present:** file:1, sym:6, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "module_author" "net/tquic/security/quic_exfil.c"`
- `sed -n '1684,1686p' net/tquic/security/quic_exfil.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-504 -- Duplicate Static Functions: h3_varint_encode/decode

**Severity:** S3 | **Category:** correctness | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:2, sym:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "h3_varint_decode" "net/tquic/http3/http3_request.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Move to a shared helper (e.g., in `http3_frame.c` or a common header as inline functions). Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/http3_request.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-506 -- Key Update Timeout Revert Could Race With Concurrent Update

**Severity:** S3 | **Category:** concurrency | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "inconsistent" "net/tquic/crypto/key_update.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/crypto/key_update.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a generation counter or sequence number to the key update so the timeout handler can detect if a response arrived between the timeout firing and the lock acquisition. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/key_update.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-507 -- Load Balancer Stack Buffers for Feistel Not Zeroized on Error

**Severity:** S3 | **Category:** security | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, sym:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "memzero_explicit" "net/tquic/lb/quic_lb.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/lb/quic_lb.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-508 -- Module Parameters Expose Security Configuration

**Severity:** S3 | **Category:** security | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_cert_verify_mode" "net/tquic/crypto/cert_verify.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Log a prominent warning when verification mode is set to NONE. Consider requiring a special flag to disable verification in production builds. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-510 -- Netlink Family Exported as EXPORT_SYMBOL_GPL

**Severity:** S3 | **Category:** memory | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory, security.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "export_symbol_gpl" "net/tquic/tquic_netlink.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_netlink.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-511 -- Per-CPU Stats Not Protected Against Torn Reads on 32-bit

**Severity:** S3 | **Category:** security | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "read_once" "net/tquic/crypto/hw_offload.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `u64_stats_sync` infrastructure for proper 64-bit stats on 32-bit architectures. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/hw_offload.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-512 -- Procfs trusted_cas File Writable Without Capability Check

**Severity:** S3 | **Category:** security | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:4

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "capable" "net/tquic/crypto/cert_verify.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `capable(CAP_NET_ADMIN)` check at the start of `tquic_proc_trusted_cas_write()`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-513 -- Qlog: Lock Drop Around copy_to_user

**Severity:** S3 | **Category:** concurrency | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "behavior" "net/tquic/diag/qlog.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/diag/qlog.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Copy the entry to a local kernel buffer under the lock, then `copy_to_user` from the local buffer. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/diag/qlog.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-514 -- Unused HKDF-Expand Output in Extended Key Update

**Severity:** S3 | **Category:** security | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_eku_derive_keys" "net/tquic/crypto/extended_key_update.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Actually use the `mixed_secret` as input to the subsequent key derivation rather than the standard derivation path. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/extended_key_update.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-515 -- Volatile Qualifiers in Constant-Time Functions May Be Insufficient

**Severity:** S3 | **Category:** security | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "crypto_memneq" "net/tquic/security/quic_exfil.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-538 -- crypto_wait_req May Sleep in Encrypt/Decrypt Hot Path

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, lines:2, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '637,637p' net/tquic/crypto/tls.c`
- `sed -n '694,694p' net/tquic/crypto/tls.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Ensure the encrypt/decrypt paths are only called from process context
(e.g., in a workqueue), or use async completion callbacks instead of
`crypto_wait_req`.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-551 -- Multipath Nonce Construction -- Potential Nonce Reuse Across Paths

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, sym:3, lines:5, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_crypto_ctx_destroy" "net/tquic/crypto/tls.c"`
- `sed -n '392,423p' net/tquic/crypto/tls.c`
- `sed -n '645,645p' net/tquic/crypto/tls.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Verify that path_id allocation is monotonically increasing per
connection and never reuses IDs within a key phase. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-553 -- Netlink Operations All Require GENL_ADMIN_PERM

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:2, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_netlink" "net/tquic/tquic_netlink.c"`
- `sed -n '274,274p' net/tquic/tquic_netlink.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-558 -- Redundant Lock in tquic_bonding_get_state

**Severity:** S3 | **Category:** concurrency | **Sources:** B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.

**Key evidence present:** file:1, sym:2, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_bonding_get_state" "net/quic/tquic/bond/tquic_bonding.c"`
- `sed -n '526,526p' net/quic/tquic/bond/tquic_bonding.c`
- `sed -n '899,899p' net/quic/tquic/bond/tquic_bonding.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/bond/tquic_bonding.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-564 -- Stream ID Right-Shift Comparison

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stream" "net/quic/tquic/tquic_stream.c"`
- `sed -n '1409,1410p' net/quic/tquic/tquic_stream.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-566 -- tquic_ipv6.c MTU Info getsockopt

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** CERTIFIED | **Confidence after judging:** high

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, sym:2, lines:5, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "copies" "net/quic/tquic/tquic_ipv6.c"`
- `sed -n '171,211p' net/quic/tquic/tquic_ipv6.c`
- `sed -n '226,227p' net/quic/tquic/tquic_ipv6.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

## PLAUSIBLE Findings (364)

### CF-002 -- Buffer Overflow in ClientHello Extension Building

**Severity:** S0 | **Category:** memory | **Sources:** A,B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- FP-risk: Snippet(s) contain only comments, not actual vulnerable code.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "enabled" "net/tquic/crypto/handshake.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a running `offset` tracker and validate `offset + needed_bytes <= buf_len` before every write operation. Return `-ENOSPC` if insufficient space. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-013 -- `tquic_close()` Does Not Hold `lock_sock()` During Connection Teardown

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:12, snippet:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_sock" "net/tquic/tquic_socket.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-016 -- `tquic_hs_process_server_hello` -- missing bounds check before compression byte read

**Severity:** S0 | **Category:** memory | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_process_server_hello" "net/tquic/crypto/handshake.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `if (p >= end) return -EINVAL;` before reading compression. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-017 -- `tquic_shutdown()` Missing `lock_sock()` -- Race on Connection State

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:9, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_shutdown" "net/tquic/tquic_socket.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-018 -- `tquic_varint_len()` Returns 0 for Invalid Values Without Error Propagation

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on severity: Severity disagreement across reports: S0, S1.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_varint_len" "net/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add explicit check: `if (len == 0) return -EOVERFLOW;` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_output.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-019 -- Adaptive Feedback Uses Path After list_for_each_entry Exit

**Severity:** S0 | **Category:** memory | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:7, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_path" "net/tquic/multipath/tquic_scheduler.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/multipath/tquic_scheduler.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a separate flag variable to track whether the path was found, or use `list_for_each_entry_rcu()` with a found flag check. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/multipath/tquic_scheduler.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-020 -- ASN.1 Time Parsing Does Not Validate Character Ranges

**Severity:** S0 | **Category:** security | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Validate each character is an ASCII digit before arithmetic. Validate month (1-12), day (1-31), hour (0-23), minute (0-59), second (0-59). Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-021 -- Authentication Bypass in QUIC-Aware Proxy

**Severity:** S0 | **Category:** security | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_quic_proxy_register_conn" "net/tquic/masque/quic_proxy.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Set `require_auth = true` by default. Implement mandatory authentication (PSK, certificate, or token-based) in `tquic_quic_proxy_register_conn()` before processing any registration. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/quic_proxy.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-022 -- BLEST Inconsistent Locking -- 3 of 6 Callbacks Lack Lock

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:5, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "blest_get_path" "net/tquic/multipath/sched_blest.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/multipath/sched_blest.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `spin_lock_irqsave(&sd->lock, flags)` to `blest_path_removed()`, `blest_ack_received()`, and `blest_loss_detected()`.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/multipath/sched_blest.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-025 -- Complete SSRF in CONNECT-UDP -- No Address Validation

**Severity:** S0 | **Category:** security | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:11, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "resolve_target" "net/tquic/masque/connect_udp.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add address validation after `in4_pton`/`in6_pton` succeeds. Block at minimum: `ipv4_is_loopback()`, `ipv4_is_multicast()`, `ipv4_is_lbcast()`, `ipv4_is_zeronet()`, `ipv4_is_private_10()`, `ipv4_is_private_172()`, `ipv4_is_private_192()`, link-local (169.254.0.0/16), and the IPv6 equivalents. Pro... Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/connect_udp.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-026 -- ECF Scheduler Declares Lock But Never Uses It

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "spin_lock_irqsave" "net/tquic/multipath/sched_ecf.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/multipath/sched_ecf.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Wrap all accesses to `sd->paths[]` and `sd->current_path_id` in `spin_lock_irqsave(&sd->lock, flags)` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/multipath/sched_ecf.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-027 -- ECN CE Count Processing Does Not Track Deltas

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_cong_on_ecn" "net/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Store the previous ECN counts per path (in `struct tquic_ecn_tracking`) and only call `tquic_cong_on_ecn()` with the delta when `ecn_ce > path->ecn.ce_count`. Update the stored count after processing. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_input.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-031 -- Hard-Fail Revocation Mode Does Not Actually Fail

**Severity:** S0 | **Category:** security | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** The function must return `-EKEYREVOKED` or a similar error when `TQUIC_REVOKE_HARD_FAIL` is set and revocation status cannot be determined.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-032 -- Hardcoded init_net Namespace Bypass in Socket Creation

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:2, sym:2, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_tunnel" "net/tquic/masque/connect_udp.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Store a reference to the correct network namespace (`struct net *`) at connection establishment time (via `sock_net(sk)` from the original QUIC socket) and use that namespace for all subsequent socket creation.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/connect_udp.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-035 -- Load Balancer Plaintext Mode Exposes Server ID

**Severity:** S0 | **Category:** memory | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "pr_warn_once" "net/tquic/lb/quic_lb.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/lb/quic_lb.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Log a `pr_warn_once()` when plaintext mode is selected. Consider requiring `CAP_NET_ADMIN` to create plaintext configs, or removing plaintext mode entirely. At minimum, add a prominent `IS THIS REALLY WHAT YOU WANT` style warning. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/lb/quic_lb.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-036 -- Missing RFC 1918 / Private Network Filtering in IPv4 SSRF Checks

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:5, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "ipv4_is_linklocal_169" "net/tquic/tquic_tunnel.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_tunnel.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add checks for `ipv4_is_private_10()`, `ipv4_is_private_172()`, `ipv4_is_private_192()`, `ipv4_is_linklocal_169()`, and other reserved ranges per RFC 5737 (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24). Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-039 -- Netfilter Hooks Registered Only in init_net

**Severity:** S0 | **Category:** security | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_nf" "net/tquic/tquic_nf.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Register hooks via `pernet_operations` so each namespace gets its own hooks, or verify this is intentionally init_net-only and document the limitation.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_nf.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-040 -- No Address Validation in CONNECT-IP Packet Injection

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:5, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "netif_rx" "net/tquic/masque/connect_ip.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add source and destination address validation in `connect_ip_validate_ip_header()` or a new function called before `netif_rx()`. Block loopback, multicast, broadcast, link-local, RFC1918, and IPv4-mapped-IPv6 addresses. Set `skb->dev` to the tunnel's virtual network device so netfilter rules appl... Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/connect_ip.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-041 -- No Privilege Check for TQUIC Socket Creation

**Severity:** S0 | **Category:** security | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_proto" "net/tquic/tquic_proto.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Consider requiring `CAP_NET_ADMIN` for bonding/multipath features, or at minimum for creating tunnels and MASQUE proxies.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_proto.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-042 -- No Privilege Checks for Security-Sensitive Socket Options

**Severity:** S0 | **Category:** security | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:2, lines:5

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_socket" "net/tquic/tquic_socket.c"`
- `sed -n '771,771p' net/tquic/tquic_socket.c`
- `sed -n '780,780p' net/tquic/tquic_socket.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN)` checks for privileged options.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-049 -- QPACK Decoder Stack Buffer Overflow via Large Headers

**Severity:** S0 | **Category:** memory | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "qpack_decoder" "net/quic/tquic/http3/qpack_decoder.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/http3/qpack_decoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Replace stack buffers with heap allocation (kmalloc with GFP_ATOMIC). The value_buf alone at 8192 bytes is dangerously large for kernel stack. Alternatively, reduce QPACK_MAX_HEADER_VALUE_LEN and allocate from a slab cache.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/qpack_decoder.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-052 -- Retry Token Address Validation Uses Non-Constant-Time Comparison

**Severity:** S0 | **Category:** memory | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "crypto_memneq" "net/tquic/core/connection.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `crypto_memneq()` for the hash comparison, or accept the current design as adequate given AEAD authentication. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-057 -- SSRF via IPv4-Mapped IPv6 Addresses Bypasses Address Filtering

**Severity:** S0 | **Category:** security | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "ipv6_addr_v4mapped" "net/tquic/tquic_tunnel.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add checks for `ipv6_addr_v4mapped()`, `ipv6_addr_is_isatap()`, private RFC 1918 ranges within mapped addresses, and the unspecified address (`::` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-062 -- tquic_conn_server_accept() -- overrides actual error code with -EINVAL

**Severity:** S0 | **Category:** correctness | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_conn_server_accept" "net/quic/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Change to `return ret;` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-063 -- tquic_send_connection_close() -- SKB leak and unencrypted packet on header failure

**Severity:** S0 | **Category:** build | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: build, other.

**Key evidence present:** file:1, sym:4, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_send_connection_close" "net/quic/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `if (header_len < 0) { kfree_skb(skb); kfree(buf); return header_len; }` before the `skb_put_data` calls.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_output.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-064 -- tquic_stream_sendmsg Writes to Stream Without Connection Refcount on Stream

**Severity:** S0 | **Category:** memory | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stream_sendmsg" "net/quic/tquic/tquic_stream.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/tquic_stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Stream objects need reference counting. The stream_sock should hold a reference to the stream. Only when both the tree reference and the socket reference are dropped should the stream be freed.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_stream.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-066 -- Tunnel Uses init_net -- Namespace Escape

**Severity:** S0 | **Category:** security | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use the network namespace from the QUIC connection's socket (`sock_net(conn->sk)`) instead of `&init_net`. Pass the correct `struct net *` through the client and tunnel structures. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-067 -- Unbounded Memory Allocation from Attacker-Controlled Capsule Length

**Severity:** S0 | **Category:** perf | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, perf.

**Key evidence present:** file:1, sym:2, snippet:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "capsule_alloc" "net/tquic/masque/capsule.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Validate `parser->header.length <= CAPSULE_MAX_PAYLOAD_SIZE` immediately after header decode succeeds, before calling `capsule_alloc()`. Additionally, add the same check inside `capsule_alloc()` as defense-in-depth.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/capsule.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-070 -- WebTransport Close Capsule Large Stack Allocation

**Severity:** S0 | **Category:** memory | **Sources:** B,C | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/http3/webtransport.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use heap allocation (kmalloc/kzalloc) for this buffer.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/webtransport.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-071 -- AF_XDP Socket and Device Lookup Use init_net

**Severity:** S0 | **Category:** security | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:3, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_xsk_create" "net/tquic/af_xdp.c"`
- `sed -n '367,367p' net/tquic/af_xdp.c`
- `sed -n '1096,1096p' net/tquic/af_xdp.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-072 -- conn->sk Accessed Without Lock After Stateless Reset

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:4, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_connection" "net/tquic/tquic_input.c"`
- `sed -n '397,407p' net/tquic/tquic_input.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Hold a reference to the socket (`sock_hold(sk)`) under the lock, then call `sk_state_change`, then release the reference (`sock_put(sk)`). Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-073 -- Integer Overflow in bytes_acked Calculation

**Severity:** S0 | **Category:** correctness | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_cong_on_ack" "net/quic/tquic/tquic_input.c"`
- `sed -n '737,737p' net/quic/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-074 -- Missing Lock in `tquic_sock_bind()` -- Race with `tquic_connect()`

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:11, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "copies" "net/tquic/tquic_socket.c"`
- `sed -n '246,246p' net/tquic/tquic_socket.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-075 -- Missing Upper Bound on Coalesced Packet Count

**Severity:** S0 | **Category:** correctness | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Sources disagree on severity: Severity disagreement across reports: S0, S2.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:7, lines:6, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_udp_recv" "net/quic/tquic/tquic_input.c"`
- `sed -n '3079,3079p' net/quic/tquic/tquic_input.c`
- `sed -n '2080,2080p' net/quic/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-076 -- Packet Number Length Extracted Before Header Unprotection

**Severity:** S0 | **Category:** correctness | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:3, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_remove_header_protection" "net/tquic/tquic_input.c"`
- `sed -n '2529,2529p' net/tquic/tquic_input.c`
- `sed -n '2545,2545p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Move the `pkt_num_len` extraction to AFTER `tquic_remove_header_protection()`:
```c
ret = tquic_remove_header_protection(conn, data, ctx.offset, ...);
if (ret < 0) return ret;
pkt_num_len = (data[0] & 0x03) + 1;  // Now reads unprotected bits
if (ctx.offset + pkt_num_len > len) return -EINVAL;
``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-077 -- QUIC-over-TCP Client and Server Sockets Use init_net

**Severity:** S0 | **Category:** security | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "quic_over_tcp" "net/tquic/transport/quic_over_tcp.c"`
- `sed -n '1225,1225p' net/tquic/transport/quic_over_tcp.c`
- `sed -n '1446,1446p' net/tquic/transport/quic_over_tcp.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-078 -- Refcount Underflow in Netlink Path Creation

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:5, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_netlink" "net/tquic/tquic_netlink.c"`
- `sed -n '427,427p' net/tquic/tquic_netlink.c`
- `sed -n '439,439p' net/tquic/tquic_netlink.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_netlink.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-079 -- Stale skb->len Read After ip_local_out

**Severity:** S0 | **Category:** correctness | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "ip_local_out" "net/tquic/tquic_output.c"`
- `sed -n '1730,1736p' net/tquic/tquic_output.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Save `skb->len` in a local variable before calling `ip_local_out()`:
```c
u32 pkt_len = skb->len;
ret = ip_local_out(&init_net, NULL, skb);
if (ret >= 0) {
    path->stats.tx_bytes += pkt_len;
``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-080 -- State Machine Type Confusion via `conn->state_machine` Void Pointer

**Severity:** S0 | **Category:** correctness | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on severity: Severity disagreement across reports: S0, S1.

**Key evidence present:** file:1, sym:11, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "could" "net/tquic/tquic_migration.c"`
- `sed -n '1098,1098p' net/tquic/tquic_migration.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-081 -- Stream Lookup Returns Pointer Without Refcount -- Use-After-Free

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:4, sym:4, lines:4, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_stream" "net/quic/tquic/core/priority.c"`
- `sed -n '497,524p' net/quic/tquic/core/priority.c`
- `sed -n '1461,1489p' net/quic/tquic/core/priority.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/core/priority.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-082 -- TOCTOU Race in Failover Hysteresis

**Severity:** S0 | **Category:** concurrency | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, lines:4, snippet:3

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "atomic_set" "net/quic/tquic/bond/tquic_failover.c"`
- `sed -n '198,229p' net/quic/tquic/bond/tquic_failover.c`
- `sed -n '207,207p' net/quic/tquic/bond/tquic_failover.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/bond/tquic_failover.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Either protect these operations with a per-path spinlock, or use `atomic_inc_return()` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-083 -- TQUIC_NEW_STREAM Missing Reserved Field Zeroing Check

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_conn_get" "net/quic/tquic/tquic_stream.c"`
- `sed -n '680,680p' net/quic/tquic/tquic_stream.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/tquic_stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-084 -- UAF-P1-01: - SmartNIC tquic_nic_find() returns pointer without reference

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:7, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_offload_key_install" "net/tquic/offload/smartnic.c"`
- `sed -n '264,264p' net/tquic/offload/smartnic.c`
- `sed -n '300,300p' net/tquic/offload/smartnic.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/offload/smartnic.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-085 -- Use-After-Free in Connect

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, lines:5, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "sock" "net/tquic/tquic_socket.c"`
- `sed -n '230,230p' net/tquic/tquic_socket.c`
- `sed -n '285,285p' net/tquic/tquic_socket.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-086 -- Wrong Network Namespace in ip_local_out

**Severity:** S0 | **Category:** security | **Sources:** B | **Priority:** 10.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, lines:2, snippet:2

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `sed -n '1730,1730p' net/tquic/tquic_output.c`
- `sed -n '1681,1681p' net/tquic/tquic_output.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `sock_net(conn->sk)` instead of `&init_net`. The correct network namespace was already computed at line 1681 in the `rt` lookup:
```c
ret = ip_local_out(net, conn->sk, skb);
``` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-089 -- ACK Range Failover Can Iterate Over Unbounded Packet Number Range

**Severity:** S0 | **Category:** correctness | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:4, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_failover_ctx" "net/tquic/bond/tquic_failover.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/tquic_failover.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-092 -- CID demux/lookup appears non-functional: the RX path uses one table, while connection creation populates different table

**Severity:** S0 | **Category:** security | **Sources:** A | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source A); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:4, sym:6, lines:4

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_cid_hash_add" "net/tquic/core/connection.c"`
- `sed -n '2696,2696p' net/tquic/core/connection.c`
- `sed -n '463,463p' net/tquic/core/quic_connection.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** - Pick exactly one authoritative CID demux table for RX and ensure connection creation inserts the SCID/DCIDs into it.
- Delete or hard-disable the unused tables (or clearly fence them behind config/ifdef) to reduce attack surface and confusion. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-095 -- Connection State Transition Not Fully Atomic

**Severity:** S0 | **Category:** concurrency | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:2, sym:5, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_conn_set_state" "net/tquic/core/connection.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-096 -- Connection State Transition Not Fully Atomic

**Severity:** S0 | **Category:** correctness | **Sources:** C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_conn_set_state" "net/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** All state transitions MUST go through `tquic_conn_set_state()`, and the function should assert/acquire `conn->lock` internally. Fix `tquic_handle_stateless_reset()` to use the state machine. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_input.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-097 -- Excessive Stack Usage in RS Recovery

**Severity:** S0 | **Category:** correctness | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "attempt_rs_recovery" "net/tquic/fec/fec_decoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/fec/fec_decoder.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-098 -- Global connection hashtable (`tquic_conn_table`) is initialized and removed-from, but never inserted-into

**Severity:** S0 | **Category:** correctness | **Sources:** A | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source A); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:4, lines:2

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "hashtable" "net/tquic/tquic_main.c"`
- `sed -n '145,145p' net/tquic/tquic_main.c`
- `sed -n '796,796p' net/tquic/tquic_main.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** - Either wire up insertion consistently at connection establishment, or delete `tquic_conn_table` and all iteration users in favor of the per-netns list already used by `tquic_conn_lookup_by_token()`. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-099 -- Header protection outputs are ignored; packet-number length + key phase are derived from protected header

**Severity:** S0 | **Category:** security | **Sources:** A | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source A); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, lines:3

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_hp_unprotect" "net/tquic/tquic_input.c"`
- `sed -n '2528,2528p' net/tquic/tquic_input.c`
- `sed -n '2539,2539p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** - Treat `tquic_hp_unprotect()` as authoritative for `pn_len` and (short header) `key_phase`.
- After HP removal, recompute any fields derived from the masked bits (pn length, key phase, reserved bits validation).
- In short header parsing: do not interpret spin/key-phase/pn-len prior to unprotect. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-100 -- Huffman Decoder O(n*256) Algorithmic Complexity DoS

**Severity:** S0 | **Category:** security | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/qpack.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-101 -- Integer Overflow in Coupled CC Increase Calculation

**Severity:** S0 | **Category:** correctness | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "coupled_cc_increase" "net/tquic/bond/cong_coupled.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/cong_coupled.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-102 -- IPv4/IPv6 Address Discovery Enumerates Host Interfaces

**Severity:** S0 | **Category:** security | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:2, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_ipv6.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-104 -- List Iterator Invalidation in BPM Netdev Notifier

**Severity:** S0 | **Category:** concurrency | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:5, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "rcu_read_unlock" "net/quic/tquic/bond/tquic_bpm.c"`
- `sed -n '1876,1898p' net/quic/tquic/bond/tquic_bpm.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/bond/tquic_bpm.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `list_for_each_entry_safe()` is NOT sufficient here since the iteration continues after relock. Instead, collect paths to process into a separate list under the lock, then process them after releasing the lock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-106 -- MASQUE CONNECT-UDP Proxy Creates Sockets in init_net

**Severity:** S0 | **Category:** security | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/connect_udp.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-110 -- Packet number reconstruction always uses `largest_pn = 0`

**Severity:** S0 | **Category:** correctness | **Sources:** A | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source A); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_decode_pkt_num" "net/tquic/tquic_input.c"`
- `sed -n '2572,2572p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** - Track `largest_pn` per PN space (Initial/Handshake/Application) and pass it into `tquic_decode_pkt_num()`. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-112 -- QPACK Dynamic Table Duplicate TOCTOU Race

**Severity:** S0 | **Category:** concurrency | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "qpack_dynamic" "net/quic/tquic/http3/qpack_dynamic.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/http3/qpack_dynamic.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/qpack_dynamic.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-113 -- QUIC-Exfil mitigation code uses `skb->cb` as a function-pointer slot and gates on `skb->cb[0]`

**Severity:** S0 | **Category:** concurrency | **Sources:** A | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, line range.
- Single-source finding (source A); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, lines:2

**What's missing:**
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `sed -n '1090,1090p' net/tquic/security/quic_exfil.c`
- `sed -n '270,270p' net/tquic/security/quic_exfil.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** - Never store function pointers in `skb->cb`.
- Use a wrapper object (`struct { struct sk_buff *skb; void (*send_fn)(...); }`) in a dedicated queue, or at least define a strict `struct` overlay for `skb->cb` and always set a sentinel + zero the rest. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-115 -- Rate Calculation Integer Overflow

**Severity:** S0 | **Category:** concurrency | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:2, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/rate_limit.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-118 -- Redundant Scheduler Deduplication Uses Only 8-bit Sequence Hash -- Trivial Collision

**Severity:** S0 | **Category:** correctness | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on severity: Severity disagreement across reports: S0, S3.

**Key evidence present:** file:1, sym:3, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_connection" "net/tquic/multipath/tquic_scheduler.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/multipath/tquic_scheduler.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-119 -- Reference counting/RCU lifetime is not actually enforced; direct `tquic_conn_destroy()` calls can free live connections

**Severity:** S0 | **Category:** memory | **Sources:** A | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source A); no independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:4, sym:10, lines:4

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "assertions" "Users/justinadams/Downloads/tquic-kernel/include/net/tquic.h"`
- `sed -n '1965,1965p' Users/justinadams/Downloads/tquic-kernel/include/net/tquic.h`
- `sed -n '1981,1981p' Users/justinadams/Downloads/tquic-kernel/include/net/tquic.h`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "Users/justinadams/Downloads/tquic-kernel/include/net/tquic.h"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** - Make `tquic_conn_destroy()` private/internal (not a general-purpose public API). Enforce that all external callers use `tquic_conn_put()` and that the destructor only runs on the refcount-to-zero edge.
- Add debug assertions (at least under `CONFIG_DEBUG_KERNEL`) to catch direct destruction wit... Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-120 -- rhashtable/RCU lifetime issues (use-after-free risk) in CID tables

**Severity:** S0 | **Category:** memory | **Sources:** A | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source A); no independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:2, sym:6, lines:2

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "call_rcu" "net/tquic/core/quic_connection.c"`
- `sed -n '355,355p' net/tquic/tquic_cid.c`
- `sed -n '537,537p' net/tquic/tquic_cid.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/core/quic_connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** - Decide on a correct concurrency model:
  - Option A: Use rhashtable in the intended RCU mode.
    - Lookups under `rcu_read_lock()`.
    - Deletions free via `kfree_rcu()` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-122 -- Same Overflow in OLIA Increase Path

**Severity:** S0 | **Category:** correctness | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "olia_cc_increase" "net/tquic/bond/cong_coupled.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/cong_coupled.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-125 -- Tunnel Socket Creation Uses init_net

**Severity:** S0 | **Category:** security | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "should" "net/tquic/tquic_tunnel.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-127 -- UAF-P2-01: - SKB accessed after udp_tunnel_xmit_skb

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "udp_tunnel_xmit_skb" "net/tquic/tquic_udp.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_udp.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_udp.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-128 -- UAF-P3-01: - retransmit_work_fn accesses ts->conn without connection reference

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:8, lines:2

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "cancel_work_sync" "net/tquic/tquic_timer.c"`
- `sed -n '848,848p' net/tquic/tquic_timer.c`
- `sed -n '1422,1422p' net/tquic/tquic_timer.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_timer.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-129 -- UAF-P3-02: - path_work_fn accesses ts->conn without reference

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_timer_state" "net/tquic/tquic_timer.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_timer.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_timer.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-131 -- Use-After-Free in `tquic_migrate_explicit()` -- Path Used Without Reference

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:5, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_path_find_by_addr" "net/tquic/tquic_migration.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-132 -- Use-After-Free in Algorithm Name Return

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:4, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_cong_get_default_name" "net/tquic/cong/tquic_cong.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/cong/tquic_cong.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/cong/tquic_cong.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-134 -- Widespread allocator mismatches (kmem_cache vs kzalloc/kfree) for core objects (conn/path/stream)

**Severity:** S0 | **Category:** memory | **Sources:** A | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source A); no independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:6, sym:18, lines:9

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "evidence" "net/tquic/Makefile"`
- `sed -n '18,18p' net/tquic/Makefile`
- `sed -n '428,428p' net/tquic/core/quic_connection.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/Makefile"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** - Pick exactly one allocator strategy per object type (`tquic_connection`, `tquic_path`, `tquic_stream`) and enforce it via dedicated wrappers:
  - `tquic_conn_alloc()/tquic_conn_free()`
  - `tquic_path_alloc()/tquic_path_free()`
  - `tquic_stream_alloc()/tquic_stream_free()`
- Remove or fence an... Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-158 -- `tquic_cid_pool_destroy()` Removes from rhashtable Under BH spinlock

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:7, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "kfree_rcu" "net/tquic/tquic_cid.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_cid.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_cid.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-159 -- `tquic_conn_retire_cid()` Does Not Remove CID from Lookup Hash Table

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_conn_retire_cid" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Call `rhashtable_remove_fast()` when retiring a local CID. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-161 -- `tquic_hs_cleanup` -- potential double-free of session ticket

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:2, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_setup_psk" "net/tquic/crypto/handshake.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Either document clearly that `tquic_hs_setup_psk` takes ownership
(and the caller must not free), or make `tquic_hs_setup_psk` copy the ticket data.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-162 -- `tquic_hs_generate_client_hello` -- output buffer `buf` not validated for minimum size

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:1, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_generate_client_hello" "net/tquic/crypto/handshake.c"`
- `sed -n '1320,1320p' net/tquic/crypto/handshake.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Validate `buf_len` against the minimum required size at function entry.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-164 -- `tquic_hs_process_encrypted_extensions` -- ALPN validation insufficient

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1, snippet:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_process_encrypted_extensions" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** ```c
if (ext_data_len >= 3 && proto_len > 0 && 3 + proto_len <= ext_data_len) {
```

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-167 -- `tquic_hs_setup_psk` -- integer overflow in ticket age calculation

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_setup_psk" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `u64` for `age` and validate the time difference before
multiplication. Also validate `lifetime` against RFC 8446 maximum of 604800 (7 days).

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-168 -- `tquic_recvmsg()` Same Issue as HIGH-07

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_recvmsg" "net/tquic/tquic_socket.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-170 -- Anti-Amplification Integer Overflow

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `check_add_overflow` and `check_mul_overflow` for safe arithmetic.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-171 -- atomic_sub on sk_rmem_alloc Incompatible with refcount_t

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "skb_set_owner_r" "net/quic/tquic/core/stream.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/core/stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `skb_set_owner_r()` for receive buffers and let the destructor handle accounting, consistent with the tquic_stream.c approach.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-172 -- BBRv2 Inflight Calculation Truncation

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Return `u64` or `u32` with saturation:
```c
return (u32)min_t(u64, inflight, U32_MAX);
```

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/cong/bbrv2.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-175 -- CID Lookup Returns Connection Without Reference Count

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:5, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "kfree_rcu" "net/tquic/tquic_cid.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_cid.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** The caller should be in an RCU read-side section, and connections should be freed via `kfree_rcu()`. Alternatively, take a refcount on the connection before returning. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_cid.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-176 -- Coalesced Packet Splitting Assumes v1 Packet Type Encoding

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_decode_packet_type" "net/tquic/core/packet.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Read the version field (bytes 1-4) and use `tquic_decode_packet_type()` for version-aware type detection.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/packet.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-181 -- const-Correctness Violation in Proxy Packet Decode

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "quic_proxy_capsules" "net/tquic/masque/quic_proxy_capsules.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/masque/quic_proxy_capsules.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Either copy the packet data into a separately allocated buffer, or declare `capsule->packet` as `const u8 *` and ensure all consumers respect const correctness.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/quic_proxy_capsules.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-182 -- copy_from_user with User-Controlled Size in Socket Options

**Severity:** S1 | **Category:** api | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: api, memory.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_socket" "net/quic/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_socket.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-185 -- EKU Semantic Mismatch: get_current_keys Returns Key, Not Secret

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:2, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_key_update_get_current_keys" "net/tquic/crypto/extended_key_update.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add and use a function to retrieve the current traffic secret (not the
derived key) from `tquic_key_update_state`. Derive `secret_len` from the
cipher suite.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/extended_key_update.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-186 -- FEC decoder recovery -- partial recovery leaks on kzalloc failure

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/fec/fec_decoder.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-187 -- FEC encoder repair symbol generation -- partial resource leak on kzalloc failure

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** After the loop, iterate remaining entries and free any
`repair_bufs[i]` that were not successfully adopted by a `repair_sym`.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/fec/fec_encoder.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-188 -- FEC Repair Count Computation: `block_size * target_fec_rate` Truncation

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Validate `target_fec_rate <= 100` before this calculation.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/fec/fec_scheduler.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-189 -- FEC Scheduler Loss Rate Overflow

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** ```c
new_rate = (u32)((u64)sched->loss_count * 1000 Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/fec/fec_scheduler.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-193 -- h3_control_recv_frame Does Not Parse Frame Payloads

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "h3_control_recv_frame" "net/quic/tquic/http3/http3_request.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Implement actual parsing and processing for each frame type in this handler.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_request.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-194 -- HIGH: atomic64_inc_return for packet number on every TX

**Severity:** S1 | **Category:** concurrency | **Sources:** A,B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (A, B) agree; partial independent confirmation.

**Key evidence present:** file:2, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "atomic64_inc_return" "net/tquic/tquic_output.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** If the TX path is always serialized by `conn->lock`, replace with a plain `u64` increment. If not always locked, document which paths require the atomic and consider whether a per-path packet number counter with a regular lock would be more appropriate. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_output.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-196 -- HIGH: Kernel address stored as u64 in buffer ring entries

**Severity:** S1 | **Category:** security | **Sources:** A,B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:2, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "userspace" "net/tquic/io_uring.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use buffer IDs (indices) rather than raw kernel addresses. Store the base address separately in a kernel-only structure and compute the buffer address from `base + bid * size` at use time, never exposing the kernel address in shared structures. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/io_uring.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-197 -- HIGH: kmalloc(path->mtu) per datagram send

**Severity:** S1 | **Category:** concurrency | **Sources:** A,B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (A, B) agree; partial independent confirmation.

**Key evidence present:** file:2, sym:6, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "buffer" "net/tquic/tquic_output.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a per-connection pre-allocated scratch buffer (protected by `conn->lock` which is already held in the send path), or use a stack allocation since `path->mtu` is bounded and small (typically <= 1500 bytes; 1500 bytes on stack is acceptable in kernel context). Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_output.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-198 -- http3_stream.c Uses spin_lock Without _bh

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "spin_lock" "net/quic/tquic/http3/http3_stream.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/http3/http3_stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `spin_lock_bh` consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_stream.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-199 -- Incomplete SSRF Protection in TCP-over-QUIC Tunnel

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:6, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "ipv6_addr_v4mapped" "net/tquic/tquic_tunnel.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_tunnel.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add checks for all private ranges. Use `ipv4_is_private_10()`, `ipv4_is_private_172()`, `ipv4_is_private_192()` (or the unified `ipv4_is_private()` if available in the kernel version). Add link-local check. For IPv6, add check for IPv4-mapped addresses: `ipv6_addr_v4mapped()` and then validate th... Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-201 -- Integer Overflow in iovec Total Length Calculation

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:2, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "check_add_overflow" "net/tquic/masque/connect_udp.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/masque/connect_udp.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `check_add_overflow()` or manually check for overflow: `if (total_len + iov[i].iov_len < total_len) return -EOVERFLOW;` within the accumulation loop.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/connect_udp.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-203 -- Load Balancer Has No Privilege Checks

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "quic_lb" "net/tquic/lb/quic_lb.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** All LB configuration interfaces should require `CAP_NET_ADMIN`.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/lb/quic_lb.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-207 -- Missing Validation of `first_ack_range` Against `largest_ack`

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:2, sym:1, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_input" "net/tquic/core/frame.c"`
- `sed -n '358,364p' net/tquic/core/frame.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add validation: `if (first_ack_range > largest_ack) return -EPROTO;` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-208 -- Missing Validation of `TQUIC_MIGRATE` sockopt Address

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:5, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_path_find_by_addr" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-209 -- Netfilter Short Header DCID Parsing Uses Arbitrary Length

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_nf" "net/quic/tquic/tquic_nf.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/tquic_nf.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_nf.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-210 -- Packet Forwarding Has No Privilege Checks

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_forward" "net/tquic/tquic_forward.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Require `CAP_NET_ADMIN` to enable packet forwarding.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_forward.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-212 -- Prague Congestion Control: `ecn_ce_count * mss` Overflow

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Clamp `ecn_ce_count` to a reasonable maximum before multiplication:
```c
ecn_ce_count = min_t(u64, ecn_ce_count, U32_MAX);
ce_bytes = ecn_ce_count * mss;
```

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/cong/prague.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-214 -- PTO Duration Exponential Shift Overflow

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_timer" "net/quic/tquic/tquic_timer.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** ```c
u32 shift = min_t(u32, rs->pto_count, 30);
pto_duration *= (1ULL << shift);
```

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_timer.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-215 -- qlog TOCTOU Race Between Length Check and copy_to_user

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, memory.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/diag/qlog.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-216 -- Race Condition in Idle Timer Connection Processing

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:3, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "proxied_conn_put" "net/tquic/masque/quic_proxy.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/masque/quic_proxy.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Hold a reference count on each connection while it is in the `to_remove` list (which appears to be partially done via `proxied_conn_put`). Ensure CID hash removal happens atomically with the list removal under the proxy lock, so no new lookups can find the connection after it is selected for remo... Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/quic_proxy.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-221 -- Retry Packet Version Encoding Is Hardcoded for v1

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_encode_packet_type" "net/tquic/core/connection.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `tquic_encode_packet_type()` for the header byte and `cpu_to_be32(conn->version)` for the version field. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-222 -- Retry Token AEAD Key Set Under Non-IRQ-Safe Spinlock

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, correctness.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a mutex instead of a spinlock, or use `spin_lock_bh`. Better yet, allocate a per-connection AEAD instance to avoid global locking entirely.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-223 -- Return Pointer to Stack/Lock-Protected Data in tquic_conn_get_active_cid

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, correctness.

**Key evidence present:** file:1, sym:3, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_cid" "net/tquic/core/connection.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Copy the CID data into a caller-provided buffer while holding the lock, rather than returning a pointer to shared data.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-224 -- RSA Signature Algorithm Hardcoded to SHA-256 Regardless of Certificate

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Construct the algorithm name dynamically from `cert->signature.hash_algo`, e.g., `"pkcs1pad(rsa,sha384)"` or `"pkcs1pad(rsa,sha512)"`.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-227 -- smartnic.c Uses spin_lock Without _bh

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "spin_lock" "net/quic/tquic/offload/smartnic.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/offload/smartnic.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Audit all call sites. If any are reachable from softirq context, change to `spin_lock_bh`. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/offload/smartnic.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-228 -- struct tquic_napi mixes hot and cold fields

**Severity:** S1 | **Category:** concurrency | **Sources:** A,B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on severity: Severity disagreement across reports: S1, S2.

**Key evidence present:** file:2, sym:10, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "cpus" "net/tquic/napi.h"`
- `sed -n '112,143p' net/tquic/napi.h`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/napi.h"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `____cacheline_aligned_in_smp` between the RX-side fields (`rx_queue`, `rx_queue_len`, `lock`) and the poll-side fields (`stats`, `coalesce`) to separate them onto different cache lines. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-229 -- Ticket Store Free-After-Remove Race Condition

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** file:1, sym:2, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_zero_rtt_ticket" "net/tquic/crypto/zero_rtt.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/zero_rtt.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** `ticket_store_remove_locked` should only remove from the tree/list. The actual free should happen via `tquic_zero_rtt_put_ticket` (refcount-based). Change `ticket_free(old)` to `tquic_zero_rtt_put_ticket(old)`.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-230 -- TPROXY Capability Check Logic Inversion

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:4, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_tunnel" "net/tquic/tquic_tunnel.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Check `capable(CAP_NET_ADMIN)` first. If the caller lacks the capability, return `-EPERM` immediately rather than silently degrading. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-232 -- tquic_stream_count_by_type O(n) Scan for Critical Stream Enforcement

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stream_count_by_type" "net/quic/tquic/tquic_stream.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Maintain per-type counters in the connection structure, incrementing/decrementing on stream creation/destruction. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_stream.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-234 -- tquic_stream_send_allowed Missing Underflow Check

**Severity:** S1 | **Category:** concurrency | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stream_send_allowed" "net/quic/tquic/core/stream.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/core/stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add underflow guards:
```c
if (stream->send_offset >= stream->max_send_data) { blocked; return 0; }
stream_limit = stream->max_send_data - stream->send_offset;
```

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-235 -- tquic_stream_sendfile Reads Only Into First Page

**Severity:** S1 | **Category:** memory | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stream_sendfile" "net/quic/tquic/core/stream.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/core/stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Read into each page individually, or allocate a contiguous buffer. The current code only works correctly when `chunk <= PAGE_SIZE`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-238 -- Version Negotiation Packet Missing Randomized First Byte

**Severity:** S1 | **Category:** correctness | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Snippet(s) contain only comments, not actual vulnerable code.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_input" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `get_random_bytes(&first_byte, 1); first_byte |= 0x80;` similar to the function in `tquic_input.c:523`. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-239 -- Weak CID Hash Function Enables Hash Flooding

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "quic_proxy" "net/tquic/masque/quic_proxy.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `jhash()` or `siphash()` with a per-proxy random key initialized at proxy creation time. SipHash is specifically designed to be resistant to hash-flooding attacks.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/quic_proxy.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-241 -- `tquic_connect()` Stores Error in `sk->sk_err` as Positive Value Wrongly

**Severity:** S1 | **Category:** correctness | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_connect" "net/tquic/tquic_socket.c"`
- `sed -n '260,274p' net/tquic/tquic_socket.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-242 -- ACK Frame bytes_acked Calculation Can Overflow

**Severity:** S1 | **Category:** correctness | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_cong_on_ack" "net/tquic/tquic_input.c"`
- `sed -n '736,738p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Cap `first_ack_range` to a reasonable value (e.g., the maximum number of packets in flight) before the multiplication. Alternatively, cap `bytes_acked` to the actual bytes in flight. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-243 -- ACK Range Processing Without Semantic Validation

**Severity:** S1 | **Category:** security | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, security.
- Sources disagree on severity: Severity disagreement across reports: S1, S2.

**Key evidence present:** file:1, sym:4, lines:4, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_input" "net/quic/tquic/tquic_input.c"`
- `sed -n '642,642p' net/quic/tquic/tquic_input.c`
- `sed -n '2631,2631p' net/quic/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Limit ACK frames per packet to 1 (which RFC 9000 already expects) Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-244 -- Connection Close Reason Phrase Skipped Without Content Validation

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:2, sym:1, lines:3, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_output_packet" "net/tquic/tquic_output.c"`
- `sed -n '1248,1250p' net/tquic/tquic_output.c`
- `sed -n '1252,1252p' net/tquic/tquic_output.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Save `skb->len` before calling `tquic_output_packet()`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-245 -- Data Race in Server Migration Check

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_migration" "net/tquic/tquic_migration.c"`
- `sed -n '1261,1261p' net/tquic/tquic_migration.c`
- `sed -n '1270,1270p' net/tquic/tquic_migration.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-246 -- Internal Round-Robin Scheduler Missing Bounds Check

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_weighted_select_path" "net/tquic/multipath/tquic_scheduler.c"`
- `sed -n '817,817p' net/tquic/multipath/tquic_scheduler.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/multipath/tquic_scheduler.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-247 -- Multipath Frame Processing Lacks Encryption Level Validation

**Severity:** S1 | **Category:** security | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_process_mp_new_connection_id_frame" "net/tquic/tquic_input.c"`
- `sed -n '2027,2038p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add encryption level checks for all multipath frame types. They should only be accepted in 1-RTT packets (and possibly 0-RTT):
```c
} else if (frame_type == 0x40) {
    if (is_initial || is_handshake) {
        conn->error_code = EQUIC_FRAME_ENCODING;
        return -EPROTO;
    }
    ret = tquic... Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-248 -- Race Condition on path->last_activity

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, lines:3, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_process_packet" "net/quic/tquic/tquic_input.c"`
- `sed -n '723,723p' net/quic/tquic/tquic_input.c`
- `sed -n '2687,2687p' net/quic/tquic/tquic_input.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-249 -- Retire Prior To Not Validated Against Sequence Number

**Severity:** S1 | **Category:** correctness | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Sources disagree on severity: Severity disagreement across reports: S1, S2.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:5, lines:7, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_process_retire_connection_id_frame" "net/quic/tquic/tquic_input.c"`
- `sed -n '1045,1045p' net/quic/tquic/tquic_input.c`
- `sed -n '1126,1138p' net/quic/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-250 -- Route Lookup Fallback to init_net

**Severity:** S1 | **Category:** security | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:2, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_output" "net/tquic/tquic_output.c"`
- `sed -n '1681,1681p' net/tquic/tquic_output.c`
- `sed -n '1714,1714p' net/tquic/tquic_output.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-251 -- tquic_output_packet Passes NULL conn to ip_local_out

**Severity:** S1 | **Category:** correctness | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, lines:5, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_output_packet" "net/tquic/tquic_output.c"`
- `sed -n '1413,1413p' net/tquic/tquic_output.c`
- `sed -n '1662,1663p' net/tquic/tquic_output.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Store a reference to `conn` in `tquic_pacing_state` and pass it through. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-252 -- Type Shadowing Creates Memory Corruption Risk

**Severity:** S1 | **Category:** api | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:5, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_mp_sched_notify_sent" "net/tquic/multipath/tquic_scheduler.c"`
- `sed -n '2158,2164p' net/tquic/multipath/tquic_scheduler.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-253 -- UAF-P1-02: - tquic_diag.c accesses conn->sk without reference

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_net_close_connection" "net/tquic/tquic_diag.c"`
- `sed -n '153,153p' net/tquic/tquic_diag.c`
- `sed -n '1019,1019p' net/tquic/tquic_diag.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_diag.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-254 -- UAF-P3-03: - Tunnel close races with connect_work and forward_work

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:4, lines:4, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "cancel_work_sync" "net/tquic/tquic_tunnel.c"`
- `sed -n '469,469p' net/tquic/tquic_tunnel.c`
- `sed -n '429,429p' net/tquic/tquic_tunnel.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_tunnel.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-255 -- UAF-P3-04: - Path validation timer callback accesses path after potential free

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:8, lines:3, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_path" "net/tquic/tquic_timer.c"`
- `sed -n '483,483p' net/tquic/tquic_timer.c`
- `sed -n '1345,1345p' net/tquic/tquic_timer.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_timer.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-256 -- UAF-P6-01: - SmartNIC ops dereference after device could be freed

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:4, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_nic_unregister" "net/tquic/offload/smartnic.c"`
- `sed -n '253,253p' net/tquic/offload/smartnic.c`
- `sed -n '256,256p' net/tquic/offload/smartnic.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/offload/smartnic.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-257 -- Unlocked Connection Access in IOCTL

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 7.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:4, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "socket" "net/tquic/tquic_socket.c"`
- `sed -n '660,660p' net/tquic/tquic_socket.c`
- `sed -n '672,672p' net/tquic/tquic_socket.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-262 -- `tquic_nl_cmd_path_remove()` Double Put on Path

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:8, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "kfree_rcu" "net/tquic/tquic_netlink.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_netlink.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-265 -- Bonding State Machine Missing Lock on State Transition Checks

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:4, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_bonding_ctx" "net/tquic/bond/tquic_bonding.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/bond/tquic_bonding.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/tquic_bonding.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-266 -- BPM Path Manager Falls Back to init_net

**Severity:** S1 | **Category:** security | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_bpm" "net/tquic/bond/tquic_bpm.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/tquic_bpm.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-267 -- CPU-5: All hash tables use `jhash` with a **fixed seed of 0**.

**Severity:** S1 | **Category:** security | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=symbol, line range, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1, lines:1, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_nf" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `siphash` with a per-boot random key (from `net_get_random_once`) instead of `jhash` with seed 0. This is the standard kernel approach since Linux 4.1. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-268 -- Double `tquic_nl_path_put()` in `tquic_path_remove_and_free()` Assumes refcnt==2

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:8, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_path_remove_and_free" "net/tquic/tquic_netlink.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_netlink.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-269 -- Expensive Operation in Loss Path

**Severity:** S1 | **Category:** correctness | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_bonding_on_loss_detected" "net/tquic/bond/tquic_bonding.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/tquic_bonding.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-270 -- Failover Retransmit Queue Can Exceed Memory Limits

**Severity:** S1 | **Category:** correctness | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_failover" "net/tquic/bond/tquic_failover.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/tquic_failover.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-271 -- FEC Scheme ID Not Validated From Wire

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/fec/fec_decoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/fec/fec_decoder.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-272 -- Global Congestion Data Cache Without Namespace Isolation

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_cong_data_cache" "net/tquic/cong/cong_data.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/cong/cong_data.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/cong/cong_data.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-274 -- h3_stream_lookup_by_push_id Linear Scan Under Lock

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "h3_stream" "net/quic/tquic/http3/http3_request.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/http3/http3_request.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_request.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-276 -- Hysteresis Counters Use Non-Atomic READ_ONCE/WRITE_ONCE Without Lock

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_failover_timeout_work" "net/tquic/bond/tquic_failover.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/bond/tquic_failover.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/tquic_failover.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-279 -- Migration State Stores Raw Path Pointers Without Reference Counting

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:5, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_migration_state" "net/tquic/tquic_migration.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-280 -- Missing Address Family Validation in `tquic_path_create()`

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:4, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "sockaddr_in6" "net/tquic/tquic_migration.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-283 -- No ACK Frame Frequency Limit Per Packet

**Severity:** S1 | **Category:** security | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, lines:4

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_process_frames" "net/quic/tquic/tquic_input.c"`
- `sed -n '1900,1914p' net/quic/tquic/tquic_input.c`
- `sed -n '1871,2060p' net/quic/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-284 -- Path Manager Uses init_net Instead of Per-Connection Net Namespace

**Severity:** S1 | **Category:** api | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_pm_discover_addresses" "net/tquic/pm/path_manager.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Pin down exact line range in net/tquic/pm/path_manager.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-285 -- Path Validation Timeout Accesses Path State Without Lock After Unlock

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_path_handle_response" "net/tquic/pm/path_validation.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/pm/path_validation.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/pm/path_validation.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-286 -- qpack_encoder known_received_count Overflow via Insert Count Increment

**Severity:** S1 | **Category:** correctness | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "qpack_encoder" "net/quic/tquic/http3/qpack_encoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/qpack_encoder.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-287 -- Repair Frame Field Truncation Without Validation

**Severity:** S1 | **Category:** correctness | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_fec_decode_repair_frame" "net/tquic/fec/fec_decoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/fec/fec_decoder.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-289 -- sched/scheduler.c rr_select TOCTOU on num_paths

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/sched/scheduler.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-292 -- Stateless Reset Falls Back to init_net

**Severity:** S1 | **Category:** security | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_stateless_reset" "net/tquic/tquic_stateless_reset.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_stateless_reset.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-294 -- TOCTOU Race in Bonding State Transition

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_bonding_update_state" "net/tquic/bond/tquic_bonding.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/bond/tquic_bonding.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/tquic_bonding.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-295 -- TQUIC_MAX_PATHS Mismatch

**Severity:** S1 | **Category:** correctness | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:2, sym:2, lines:4

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_sched" "net/tquic/multipath/tquic_scheduler.c"`
- `sed -n '40,40p' net/tquic/multipath/tquic_scheduler.c`
- `sed -n '46,46p' net/tquic/multipath/tquic_scheduler.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-297 -- tquic_stream_check_flow_control TOCTOU with sendmsg

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, lines:2

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_stream_check_flow_control" "net/quic/tquic/tquic_stream.c"`
- `sed -n '690,690p' net/quic/tquic/tquic_stream.c`
- `sed -n '980,994p' net/quic/tquic/tquic_stream.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-298 -- tquic_stream_ext Uses GFP_ATOMIC for Large Allocation

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_stream_ext" "net/quic/tquic/core/stream.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/core/stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-299 -- tquic_udp_recv Processes Stateless Reset Before Authenticating Packet

**Severity:** S1 | **Category:** correctness | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_udp_recv" "net/tquic/tquic_input.c"`
- `sed -n '2916,2932p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Only check for stateless reset AFTER regular decryption fails (RFC 9000 Section 10.3.1 recommends this order). The check should be a last resort, not a first check. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-301 -- UAF-P1-03: - conn->sk dereference in congestion control without locking

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "sock_net" "net/tquic/cong/tquic_cong.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/cong/tquic_cong.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/cong/tquic_cong.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-302 -- UAF-P4-01: - tquic_zc_entry uses atomic_t instead of refcount_t

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:5, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "refcount_set" "net/tquic/tquic_zerocopy.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_zerocopy.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_zerocopy.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-303 -- UAF-P4-02: - Paths lack reference counting entirely

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_path" "net/tquic/tquic_migration.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-305 -- Unprotected Global Loss Tracker Array

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_loss_tracker" "net/tquic/cong/tquic_cong.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/cong/tquic_cong.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/cong/tquic_cong.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-306 -- Unvalidated `addr_len` Passed to `memcpy` in `tquic_connect()`

**Severity:** S1 | **Category:** memory | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:4, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_connect" "net/tquic/tquic_socket.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-307 -- Weight Accumulation Without Overflow Check

**Severity:** S1 | **Category:** correctness | **Sources:** B | **Priority:** 4.90

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_select_weighted" "net/tquic/bond/bonding.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/bonding.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-317 -- Path Metrics Subscription: Timer/Connection Lifetime Race

**Severity:** S2 | **Category:** memory | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "del_timer_sync" "net/tquic/diag/path_metrics.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/diag/path_metrics.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `del_timer_sync()` in `tquic_metrics_unsubscribe_conn()` to ensure the timer callback has completed before freeing the connection, or hold a connection reference in the subscription. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/diag/path_metrics.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-330 -- `additional_addr_add()` Has TOCTOU Between Duplicate Check and Insert

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, correctness.

**Key evidence present:** file:1, sym:2, lines:2

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "additional_addr_add" "net/tquic/core/additional_addresses.c"`
- `sed -n '188,188p' net/tquic/core/additional_addresses.c`
- `sed -n '191,191p' net/tquic/core/additional_addresses.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/core/additional_addresses.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Keep the lock held across the check-and-insert operation, or use a two-phase approach with lock re-check after allocation. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-331 -- `bbrv3.c` CE Ratio Potential Division by Zero

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Check denominator and use u64 for multiplication.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/cong/bbrv3.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-332 -- `hs_varint_encode` -- no bounds check on output buffer

**Severity:** S2 | **Category:** memory | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a `u32 buf_len` parameter or document the 8-byte minimum requirement.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-333 -- `http3_frame.c` Settings Frame Parser: No Bounds on `count`

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_frame.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-334 -- `kmem_cache_create()` Per Stream Manager Risks Name Collision

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "kmem_cache_create" "net/tquic/core/stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a global slab cache shared across all stream managers, or include a unique identifier in the cache name. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/stream.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-335 -- `ring_index()` Uses Unbounded While Loop

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "ring_index" "net/tquic/core/receive_timestamps.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a guard: `if (size == 0) return 0;` and use modular arithmetic: `return ((idx % (s32)size) + size) % size;` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/receive_timestamps.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-336 -- `tquic_accept()` Holding `sk_lock.slock` Improperly

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, correctness.

**Key evidence present:** file:1, sym:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "lock_sock" "net/tquic/tquic_socket.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Access the accept queue under `lock_sock()` alone without the additional spinlock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-337 -- `tquic_cong.c` ECN Byte Calculation Overflow

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_cong" "net/quic/tquic/cong/tquic_cong.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Clamp `ecn_ce_count` to a realistic maximum before multiplication.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/cong/tquic_cong.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-338 -- `tquic_fc_conn_data_sent()` Race Between Check and Update

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, correctness.

**Key evidence present:** file:1, sym:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_fc_conn_data_sent" "net/tquic/core/flow_control.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/core/flow_control.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Provide a combined `tquic_fc_conn_try_send()` that atomically checks and commits. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/flow_control.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-339 -- `tquic_hs_derive_early_secrets` -- `memzero_explicit` called before error check

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_derive_early_secrets" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Move `memzero_explicit` after the binder key is no longer needed,
or into an error/cleanup path.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-340 -- `tquic_hs_generate_client_hello` -- `hkdf_label` stack buffer on sensitive crypto path

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_generate_client_hello" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `memzero_explicit(hkdf_label, sizeof(hkdf_label));` before return.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-341 -- `tquic_hs_process_certificate_verify` -- `content[200]` stack buffer could overflow with large hash

**Severity:** S2 | **Category:** memory | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_process_certificate_verify" "net/tquic/crypto/handshake.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Compute the required size dynamically: `content_size = 64 + 33 + 1 + hash_len`
and validate it fits, or allocate dynamically.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-342 -- `tquic_hs_process_certificate` -- unbounded certificate allocation

**Severity:** S2 | **Category:** memory | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_process_certificate" "net/tquic/crypto/handshake.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** ```c
if (cert_len > TLS_CERT_MAX_LEN)
    return -EINVAL;
```

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-343 -- `tquic_hs_process_server_hello` -- `static const` inside function body

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_process_server_hello" "net/tquic/crypto/handshake.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Move to file scope alongside the other static const arrays (like
`tls12_downgrade_sentinel`). Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-344 -- `tquic_migrate_validate_all_additional()` Lock Drop/Reacquire Pattern

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:2, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_migrate_validate_all_additional" "net/tquic/tquic_migration.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-345 -- `tquic_nl_cmd_path_dump()` Incorrect Cast of `cb->ctx`

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:4, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_dump_ctx" "net/tquic/tquic_netlink.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-346 -- `tquic_path_compute_score()` Integer Overflow in Score Calculation

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_path_compute_score" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-347 -- `tquic_path_is_degraded()` Division by Zero Possible

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_path_is_degraded" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-349 -- `tquic_process_stream_frame()` Does Not Check Final Size Consistency

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_process_stream_frame" "net/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** When FIN is received, record `stream->final_size = offset + length`. On subsequent data, verify `offset + length <= stream->final_size` and that any new FIN matches the recorded value. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_input.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-350 -- `tquic_sendmsg_datagram()` Allocates Kernel Buffer Sized by User-Controlled `len`

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_sendmsg_datagram" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-355 -- atomic_inc/dec for rx_queue_len on every enqueue/dequeue

**Severity:** S2 | **Category:** concurrency | **Sources:** A,B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:2, sym:4

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "count" "net/tquic/napi.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/napi.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Remove `rx_queue_len` atomic. Use `skb_queue_len(&tn->rx_queue)` when the length is needed (it reads `qlen` from the queue head, which is maintained by `__skb_queue_tail`/`__skb_dequeue` already under the queue's lock). Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/napi.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-356 -- Benchmark write() Handler - Stack Buffer for User Input

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/bench/benchmark.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-357 -- Bloom Filter Seeds Never Rotated

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use 64-bit seeds (siphash instead of jhash) and rotate seeds during bucket rotation, hashing any remaining entries into the new bucket with new seeds.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-358 -- BPM Path Manager Uses Workqueue Without Connection Lifetime Guard

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:5, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "delayed_work" "net/tquic/bond/tquic_bpm.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a `struct tquic_connection *conn` reference with proper refcounting, and verify all work items are cancelled during teardown. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/tquic_bpm.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-359 -- cert_verify.c - kmalloc(count + 1) Integer Overflow

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/crypto/cert_verify.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-360 -- cert_verify.c parse_san_extension -- error code not propagated

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/crypto/cert_verify.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-364 -- connect_ip.c Datagram Buffer Allocation from Attacker Data

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, memory.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/masque/connect_ip.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-365 -- connect_udp.c URL Encoding Can Exceed Buffer

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/masque/connect_udp.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-366 -- Connection State Not Checked in tquic_conn_handle_close

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_connection" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Check `conn->state` and early-return for DRAINING/CLOSED states. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-368 -- Decoy Traffic Uses Easily Fingerprinted All-Zero Padding

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "quic_exfil" "net/tquic/security/quic_exfil.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fill decoy packets with cryptographically random data, or better yet, use the same encryption layer as real packets so decoy traffic is indistinguishable at the wire level.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-369 -- Diag/Tracepoints Initialize in init_net

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/diag/tracepoints.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-371 -- Exfil Context set_level Destroys and Reinitializes Without Lock

**Severity:** S2 | **Category:** memory | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_exfil_ctx_set_level" "net/tquic/security/quic_exfil.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/security/quic_exfil.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Acquire `ctx->lock` around the destroy/init sequence, or use RCU to swap in a new configuration atomically. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-375 -- Gaussian Random Approximation Produces Biased Distribution

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "gaussian_random" "net/tquic/security/quic_exfil.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** If Gaussian jitter is required, use a proper implementation. For kernel context where floating-point is unavailable, consider using the Ziggurat method with integer arithmetic, or use a larger sum of uniform random variables for better CLT approximation (sum of 12 uniform randoms is a common choi... Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-376 -- h3_stream_recv_data frame_hdr Buffer Partial Read

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "h3_stream_recv_data" "net/quic/tquic/http3/http3_request.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Validate that `ret >= 2` (minimum varint frame header) before calling the parser, or zero-initialize `frame_hdr`.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_request.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-377 -- h3_stream_recv_headers Does Not Validate payload_len Against H3_MAX_FRAME_PAYLOAD_SIZE

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "h3_stream_recv_headers" "net/quic/tquic/http3/http3_request.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add: `if (payload_len > H3_MAX_FRAME_PAYLOAD_SIZE) return -EMSGSIZE;`

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_request.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-378 -- Hardcoded 8-Byte CID in Short Header Unprotect

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Snippet(s) contain only comments, not actual vulnerable code.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "quic_crypto" "net/tquic/core/quic_crypto.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Pass the known local CID length to the unprotection function. The
receiver knows the length of its own CIDs.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/quic_crypto.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-379 -- HMAC Transform Allocated Per-Token in `tquic_stateless_reset_generate_token()`

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:4

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "get_random_bytes" "net/tquic/tquic_stateless_reset.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_stateless_reset.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_stateless_reset.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-380 -- Hostname Wildcard Matching Allows Wildcards in Non-Leftmost Position

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-381 -- http3_priority.c snprintf Priority Field Truncation

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_priority.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-384 -- kmem_cache Names Not Unique Per Connection

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `KMEM_CACHE` macro or create caches at module init time (shared across all connections), not per-connection. Or use unique names with connection ID suffix.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-385 -- Load Balancer Feistel Network Half-Length Overlap

**Severity:** S2 | **Category:** memory | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/lb/quic_lb.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a separate byte position for the round number that does not conflict with data, or XOR the round number rather than overwriting. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/lb/quic_lb.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-386 -- Load Balancer Nonce Counter Wraps Without Re-keying

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Detect counter wrap and refuse to generate nonces, or use a larger state that combines counter with additional randomness. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/lb/quic_lb.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-387 -- MEDIUM: BBRv3 uses ktime_get_ns() for every bandwidth sample

**Severity:** S2 | **Category:** perf | **Sources:** A,B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (A, B) agree; partial independent confirmation.

**Key evidence present:** file:2, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "bbrv3_update_bw" "net/tquic/cong/bbrv3.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Pass the timestamp from the caller rather than calling `ktime_get_ns()` again. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/cong/bbrv3.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-388 -- MEDIUM: kzalloc per io_uring async request

**Severity:** S2 | **Category:** correctness | **Sources:** A,B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, memory, perf.

**Key evidence present:** file:2, sym:4, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "area" "net/tquic/io_uring.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `io_alloc_async_data()` or embed the async data in the `io_kiocb` command data area (the `io_kiocb_to_cmd()` pattern already used for send/recv). Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/io_uring.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-389 -- MEDIUM: Per-chunk skb allocation in zerocopy path

**Severity:** S2 | **Category:** api | **Sources:** A,B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: api, perf.

**Key evidence present:** file:2, sym:6, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "alloc_skb" "net/tquic/tquic_zerocopy.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Batch skb allocation using `alloc_skb_with_frags()` or `napi_alloc_skb()` for bulk allocation. Use the path MTU instead of hardcoded 1200. Consider using GSO to coalesce multiple chunks into fewer skbs. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_zerocopy.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-390 -- MEDIUM: Zerocopy sendmsg chunks at 1200 bytes

**Severity:** S2 | **Category:** perf | **Sources:** A,B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: api, correctness, perf.

**Key evidence present:** file:2, sym:6, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "chunks" "net/tquic/tquic_zerocopy.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use larger chunks (up to GSO segment size) and coalesce page fragments into fewer skbs. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_zerocopy.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-391 -- MIB counter updates on every packet in RX/TX paths

**Severity:** S2 | **Category:** perf | **Sources:** A,B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=symbol, line range, snippet.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** sym:8, lines:2, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -rn "tquic_add_stats" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Acceptable overhead if using per-CPU counters. Verify the macro implementation uses `this_cpu_add` rather than atomics. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-392 -- Missing Bounds Check on tquic_hyst_state_names Array Access

**Severity:** S2 | **Category:** memory | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hyst_state_names" "net/tquic/bond/tquic_failover.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/bond/tquic_failover.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `ARRAY_SIZE(tquic_hyst_state_names)` bounds check before indexing. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/tquic_failover.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-393 -- Missing skb->dev Assignment in Packet Injection

**Severity:** S2 | **Category:** api | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: api, other.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_connect_ip_inject_packet" "net/tquic/masque/connect_ip.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Set `skb->dev` to the tunnel's virtual network device (`iface->net_device` from the tunnel's interface structure).

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/connect_ip.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-394 -- Multiple atomic operations in NAPI enqueue path

**Severity:** S2 | **Category:** concurrency | **Sources:** A,B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:2, sym:4

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "line" "net/tquic/napi.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/napi.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Remove the redundant `rx_queue_len` atomic (as noted above). This reduces to the minimum of one lock acquisition per enqueue. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/napi.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-395 -- NAT Keepalive Config Pointer Not Protected Against Concurrent Free

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "rcu_assign_pointer" "net/tquic/pm/nat_keepalive.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/pm/nat_keepalive.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Access `state->config` under `state->lock`, or use `rcu_dereference()`/`rcu_assign_pointer()` for RCU-protected access. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/pm/nat_keepalive.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-396 -- Netlink Path Dump Reads conn_id on Every Iteration

**Severity:** S2 | **Category:** memory | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_nl_cmd_path_dump" "net/tquic/tquic_netlink.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_netlink.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-397 -- Netlink PM Commands Missing CAP_NET_ADMIN Checks

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_pm_nl_add_path" "net/tquic/pm/pm_netlink.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Ensure all PM netlink ops have `.flags = GENL_ADMIN_PERM` in the `genl_ops` array, or add explicit `capable(CAP_NET_ADMIN)` checks in each handler. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/pm/pm_netlink.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-398 -- No Flow Count Limit in HTTP Datagram Manager

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "http_datagram_flow" "net/tquic/masque/http_datagram.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a configurable `max_flows` limit to the manager and reject new flow creation when the limit is reached.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/http_datagram.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-399 -- No Token Replay Protection Beyond Timestamp

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_token" "net/tquic/tquic_token.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Implement a token replay cache (e.g., a bloom filter or hash set of
recently seen token nonces) similar to the 0-RTT anti-replay mechanism already
defined in `zero_rtt.h`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_token.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-401 -- Packet Number Decode Returns 0 on Invalid Input

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Return a sentinel value or use an error pointer pattern (pass pn by reference, return error code).

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/packet.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-402 -- Path Length Constraint Check Off-By-One

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-403 -- Path Manager netdev_event Shadows Variable 'i'

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Rename the inner loop variable. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/pm/path_manager.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-407 -- poll() Accesses Connection/Stream Without Any Lock

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_socket" "net/quic/tquic/tquic_socket.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `READ_ONCE(tsk->accept_queue_len)`. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_socket.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-408 -- Proc Entries Hardcoded to init_net.proc_net

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:3, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-411 -- Request ID Truncation from u64 to int

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_connect_ip_request_address" "net/tquic/masque/connect_ip.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Change the return type to `s64` or return 0 for success and pass the request_id through an output pointer parameter.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/connect_ip.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-412 -- Retry Token Address Validation Uses Weak Hash

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `siphash` instead of `jhash` for address validation hashing.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-413 -- SAN DNS Names Not Validated for Embedded NUL Characters

**Severity:** S2 | **Category:** memory | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/crypto/cert_verify.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Reject SAN DNS names containing NUL bytes (0x00). Add: `if (memchr(p + 1 + hdr_len, 0, content_len)) continue;`

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-414 -- Scheduler Change Race Between State Check and Modification

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_scheduler" "net/tquic/multipath/tquic_scheduler.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/multipath/tquic_scheduler.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Move the state check inside the spinlock-protected region. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/multipath/tquic_scheduler.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-415 -- Security Hardening MIB Stats Always Go to init_net

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Pass the connection's `sock_net(conn->sk)` to the security event reporting function.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/security_hardening.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-416 -- Signed/Unsigned Mismatch in Scheduler Queue Delay

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/sched/scheduler.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-418 -- smartnic.c - kmalloc_array with Attacker-Influenced Count

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, memory.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/offload/smartnic.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-419 -- snprintf Return Value Not Checked in qlog.c

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `scnprintf` consistently (returns actual bytes
written, not hypothetical) or check `if (len >= buflen) return;` after
each snprintf.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/diag/qlog.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-420 -- Stateless Reset Static Key Accessible via `tquic_stateless_reset_get_static_key()` Export

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stateless_reset_get_static_key" "net/tquic/tquic_stateless_reset.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_stateless_reset.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-422 -- Sysctl Permissions Are Overly Permissive

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_sysctl" "net/tquic/tquic_sysctl.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_sysctl.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-423 -- Sysctl Variables Lack Range Validation

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Register a proper sysctl table with `proc_dointvec_minmax` handlers and range limits, or add range validation in the accessor functions. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-424 -- Token Hash Comparison Not Constant-Time

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `crypto_memneq` for the comparison.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-425 -- Token Key Rotation Does Not Zeroize Old Key

**Severity:** S2 | **Category:** security | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:3, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "memzero_explicit" "net/tquic/tquic_token.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Zeroize `old_key->key` with `memzero_explicit()` and set
`old_key->valid = false` inside this function, making the API self-cleaning.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_token.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-426 -- tquic_cid_pool_init -- timer initialized but not cancelled on later failure

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:6, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "init_work" "net/quic/tquic/tquic_cid.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Call `del_timer_sync(&pool->rotation_timer)` before `kfree(pool)`.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_cid.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-428 -- tquic_fc_reserve_credit Does Not Actually Reserve

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_fc_reserve_credit" "net/quic/tquic/core/flow_control.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Implement actual atomic reservation by deducting credit in reserve and adding back in release.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/core/flow_control.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-429 -- tquic_handshake.c tquic_start_handshake -- hs freed with memzero_explicit but no kfree_sensitive

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "kfree_sensitive" "net/quic/tquic/tquic_handshake.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_handshake.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-430 -- tquic_output_flush -- spin_unlock_bh after acquiring spin_lock_bh, but lock dropped mid-loop

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_output_flush" "net/quic/tquic/tquic_output.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_output.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-431 -- tquic_retry.c -- integrity_aead_lock held across AEAD operations

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_retry" "net/quic/tquic/tquic_retry.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_retry.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_retry.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-432 -- tquic_stream_memory_pressure Frees Without ext Cleanup

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stream_memory_pressure" "net/quic/tquic/core/stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `tquic_stream_ext_free(mgr, stream->ext);` before `kfree(stream);`.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-433 -- tquic_stream_trigger_output Inflight Underflow

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stream_trigger_output" "net/quic/tquic/tquic_stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add underflow guard: `inflight = (path->stats.tx_bytes > path->stats.acked_bytes) ? path->stats.tx_bytes - path->stats.acked_bytes : 0;`

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_stream.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-434 -- tquic_stream_write Holds mgr->lock for Entire Copy Loop

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stream_write" "net/quic/tquic/core/stream.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/core/stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Copy data to a pre-allocated buffer outside the lock, then enqueue under the lock. Or use a mutex instead of spinlock for the write path.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-435 -- Unbounded Pending Path Challenges

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, correctness.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_path" "net/tquic/core/connection.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Limit pending challenges to a reasonable maximum (e.g., 10).

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-436 -- Version Negotiation Packet Not Authenticated

**Severity:** S2 | **Category:** correctness | **Sources:** B,C | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Check that the VN version list does NOT contain the version the client originally tried.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-439 -- AMP-1: The anti-amplification check uses `atomic64` operations for `bytes_received` and `bytes_sent`, but the check-then

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, lines:1, snippet:3

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `sed -n '271,271p' net/quic/tquic/tquic_migration.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `atomic64_add_return` to atomically check-and-add, or serialize under a spinlock Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-440 -- asn1_get_length Does Not Handle Length 0x84+

**Severity:** S2 | **Category:** security | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, lines:2, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `sed -n '186,186p' net/tquic/crypto/cert_verify.c`
- `sed -n '155,155p' net/tquic/crypto/cert_verify.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-441 -- Coalesced Packet Processing Silently Truncates on Overflow

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, lines:1, snippet:2

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `sed -n '3172,3173p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Instead of silently truncating, reject the coalesced packet entirely when the claimed length exceeds remaining data:
```c
if (offset + pkt_len > total_len)
    break;  /* Malformed coalesced packet -- stop */
``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-442 -- conn->data_sent Underflow on Error Path

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, lines:4, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `sed -n '1008,1015p' net/quic/tquic/tquic_netlink.c`
- `sed -n '993,993p' net/quic/tquic/tquic_netlink.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-443 -- CPU-2: FEC decoder block search is a linear list walk.

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, lines:1, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `sed -n '285,285p' net/quic/tquic/fec/fec_decoder.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a bitmap or hash set for symbol ID dedup within blocks Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-444 -- EDF Scheduler edf_select_path Called Without Lock

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, lines:3, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "edf_select_path" "net/tquic/sched/deadline_scheduler.c"`
- `sed -n '591,591p' net/tquic/sched/deadline_scheduler.c`
- `sed -n '594,594p' net/tquic/sched/deadline_scheduler.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/sched/deadline_scheduler.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-445 -- ktime_get_ts64 Written to skb->cb May Exceed cb Size

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, lines:2, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "timespec64" "net/tquic/tquic_input.c"`
- `sed -n '1471,1471p' net/tquic/tquic_input.c`
- `sed -n '951,951p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a typed union or dedicated struct for `skb->cb` usage, documented per frame type. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-446 -- MP Frame Type Range Check Too Broad

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, lines:4, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `sed -n '1623,1623p' net/quic/tquic/tquic_input.c`
- `sed -n '1652,1652p' net/quic/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-447 -- tquic_fc_stream_can_send Missing Overflow Check

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_fc_stream_can_send" "net/quic/tquic/core/flow_control.c"`
- `sed -n '291,292p' net/quic/tquic/core/flow_control.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-448 -- TQUIC_IDLE_TIMEOUT Missing Range Validation

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, lines:1, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `sed -n '768,768p' net/quic/tquic/tquic_socket.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-449 -- TQUIC_PSK_IDENTITY Off-by-One Potential

**Severity:** S2 | **Category:** memory | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, lines:2, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `sed -n '942,942p' net/quic/tquic/tquic_socket.c`
- `sed -n '942,951p' net/quic/tquic/tquic_socket.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-450 -- tquic_recv_datagram Can Loop Forever Under Signal Pressure

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_recv_datagram" "net/tquic/tquic_output.c"`
- `sed -n '2706,2743p' net/tquic/tquic_output.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a retry counter to prevent excessive looping:
```c
int retries = 0;
...
retry:
    if (++retries > 3) return -EAGAIN;
``` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-451 -- TQUIC_SCHEDULER Race on tquic_sched_find

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:6, lines:4, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_sched_ops" "net/quic/tquic/tquic_socket.c"`
- `sed -n '848,848p' net/quic/tquic/tquic_socket.c`
- `sed -n '848,872p' net/quic/tquic/tquic_socket.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-452 -- UAF-P5-02: - Path list uses RCU but active_path does not

**Severity:** S2 | **Category:** memory | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:4, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "rcu_assign_pointer" "net/tquic/tquic_migration.c"`
- `sed -n '848,848p' net/tquic/tquic_migration.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-453 -- Version Negotiation Versions Logged Without Rate Limiting

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 4.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_dbg" "net/tquic/tquic_input.c"`
- `sed -n '473,477p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Either remove the per-version debug line or cap the number of logged versions. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-455 -- 0-RTT Encrypt Allocates AEAD Per-Packet

**Severity:** S2 | **Category:** security | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-458 -- Alpha Precision Loss in Coupled CC

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "mul_u64_u64_div" "net/tquic/bond/cong_coupled.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/cong_coupled.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-460 -- AMP-3: The MASQUE CONNECT-UDP tunnel implementation in `masque/connect_udp.c` creates UDP sockets to forward proxied tra

**Severity:** S2 | **Category:** security | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, line range.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `sed -n '374,374p' net/quic/tquic/masque/connect_udp.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add per-connection and per-client tunnel limits (e.g., max 16 tunnels per connection) Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-461 -- Anti-Amplification Check Has TOCTOU Race

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_path_anti_amplification_sent" "net/tquic/tquic_migration.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-464 -- Deadline Scheduler in_flight Underflow

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, line range.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `sed -n '299,299p' net/tquic/sched/deadline_aware.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-465 -- Division Safety in Congestion Data Validation

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_cong_data_on_ack" "net/tquic/cong/cong_data.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/cong/cong_data.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/cong/cong_data.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-468 -- h3_parse_settings_frame u64 to Pointer Cast

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "h3_parse_settings_frame" "net/quic/tquic/http3/http3_frame.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_frame.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-470 -- HMAC Stack Buffer Size

**Severity:** S2 | **Category:** memory | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_cong_data_compute_hmac" "net/tquic/cong/cong_data.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/cong/cong_data.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/cong/cong_data.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-471 -- In-Flight Calculation Signed Arithmetic

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_calc_path_quality" "net/tquic/bond/bonding.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/bonding.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-474 -- Loss Rate Cast Overflow

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "update_loss_rate" "net/tquic/fec/fec_scheduler.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/fec/fec_scheduler.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-475 -- MEM-1: `tquic_handshake.c` lines 605 and 1136 allocate skbs based on computed handshake message lengths (`ch_len`, `resp

**Severity:** S2 | **Category:** security | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:5

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_handshake" "net/quic/tquic/tquic_handshake.c"`
- `sed -n '605,605p' net/quic/tquic/tquic_handshake.c`
- `sed -n '963,963p' net/quic/tquic/tquic_handshake.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Enforce a hard cap on `ch_len` and `resp_len` (e.g., 16KB max for any single handshake message) Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-476 -- Nested Locking in Repair Reception

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_fec_receive_repair" "net/tquic/fec/fec_decoder.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/fec/fec_decoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/fec/fec_decoder.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-477 -- Path Creation Uses static atomic_t for path_id -- Not Per-Connection

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_migration" "net/tquic/tquic_migration.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-481 -- Reorder Buffer Sequence in skb->cb Alignment

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:5, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "put_unaligned" "net/tquic/bond/bonding.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/bonding.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-482 -- sched/scheduler.c Debug Logging Leaks Kernel Pointers

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:4, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_sched_default" "net/tquic/sched/scheduler.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/sched/scheduler.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-484 -- Sort Modifies Caller's Lost Packets Array

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_lost_packet" "net/tquic/cong/persistent_cong.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/cong/persistent_cong.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-487 -- tquic_main.c init/exit -- conditional cleanup mismatch for NAPI/io_uring

**Severity:** S2 | **Category:** api | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:6, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_napi_subsys_exit" "net/quic/tquic/tquic_main.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_main.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-491 -- UAF-ADD-01: - tquic_tunnel_close does not cancel forward_work for tproxy tunnels

**Severity:** S2 | **Category:** memory | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_tunnel_create_tproxy" "net/tquic/tquic_tunnel.c"`
- `sed -n '592,592p' net/tquic/tquic_tunnel.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_tunnel.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-492 -- UAF-P3-05: - GRO flush_timer can fire after kfree

**Severity:** S2 | **Category:** memory | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "hrtimer_cancel" "net/tquic/tquic_input.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_input.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-493 -- UAF-P4-03: - Double destruction path for connections

**Severity:** S2 | **Category:** memory | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:2, sym:6, lines:3

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_net_close_all_connections" "net/tquic/tquic_proto.c"`
- `sed -n '171,171p' net/tquic/tquic_proto.c`
- `sed -n '1082,1160p' net/tquic/tquic_proto.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_proto.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-494 -- UAF-P5-01: - Correct RCU usage in tquic_nf.c

**Severity:** S2 | **Category:** memory | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:5, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "call_rcu" "net/tquic/tquic_nf.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_nf.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_nf.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-495 -- UAF-P6-02: - tquic_zerocopy_complete callback chain

**Severity:** S2 | **Category:** memory | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:4, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "sk_buff" "net/tquic/tquic_zerocopy.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_zerocopy.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_zerocopy.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-499 -- XDP Uses capable

**Severity:** S2 | **Category:** security | **Sources:** B | **Priority:** 2.80

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/af_xdp.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-516 -- `established_time` Set Twice in Connection State Machine

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "ktime_get" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Only set it in CONNECTED, or rename the CONNECTING one to `handshake_start_time`. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-517 -- `sk->sk_err = -ret` Stores Negative Error Code

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_socket" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a comment: `/* ret is negative errno, sk_err needs positive */` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-518 -- `tquic_cid_compare()` Marked `__maybe_unused`

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_cid_compare" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Remove if truly unused, or remove the `__maybe_unused` annotation. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-519 -- `tquic_cid_retire()` Sends RETIRE_CONNECTION_ID After Retirement

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:11, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "release_sock" "net/tquic/tquic_cid.c"`
- `sed -n '516,516p' net/tquic/tquic_cid.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-520 -- `tquic_debug.c` CID Hex Loop Bound

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_debug" "net/quic/tquic/tquic_debug.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_debug.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-521 -- `tquic_hs_cleanup` -- does not zeroize exporter_secret and resumption_secret

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_cleanup" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `memzero_explicit` calls for all remaining sensitive fields.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-522 -- `tquic_hs_generate_client_hello` -- client random not checked for all-zero

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "get_random_bytes" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-523 -- `tquic_hs_get_handshake_secrets` and `tquic_hs_get_app_secrets` -- no output buffer size validation

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_get_handshake_secrets" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Document the minimum buffer size requirement or add a `buf_len` parameter.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-524 -- `tquic_hs_process_certificate_verify` hardcodes "server CertificateVerify" string

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hs_process_certificate_verify" "net/tquic/crypto/handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `hs->is_server ? "TLS 1.3, client CertificateVerify" : "TLS 1.3, server CertificateVerify"`.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-525 -- `tquic_hs_process_new_session_ticket` -- ignores extensions

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Snippet(s) contain only comments, not actual vulnerable code.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1, sym:5, lines:5

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "crypto_memneq" "net/tquic/crypto/handshake.c"`
- `sed -n '1076,1253p' net/tquic/crypto/handshake.c`
- `sed -n '735,809p' net/tquic/crypto/handshake.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-526 -- `tquic_server_check_path_recovery()` Uses `goto restart` Pattern

**Severity:** S3 | **Category:** concurrency | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_path_start_validation" "net/tquic/tquic_migration.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-527 -- `tquic_store_session_ticket()` Does Not Store ALPN or Transport Parameters

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_store_session_ticket" "net/tquic/tquic_handshake.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Populate `plaintext.alpn` and `plaintext.transport_params` from the connection state when storing session tickets. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_handshake.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-528 -- `tquic_sysctl_prefer_v2()` Function Not Declared in Visible Header

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_sysctl_prefer_v2" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a proper declaration in a shared header file. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-529 -- AF_XDP frame pool uses spinlock for every frame alloc/free

**Severity:** S3 | **Category:** concurrency | **Sources:** A,B | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:2, sym:1, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "buffer" "net/tquic/af_xdp.c"`
- `sed -n '222,238p' net/tquic/af_xdp.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/af_xdp.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a lockless ring buffer (SPSC or MPSC depending on usage pattern) for the free list, similar to how io_uring and XDP use lockless rings. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-530 -- bench/benchmark.c -- kvmalloc used correctly with kvfree

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:2, sym:2, lines:2

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "free" "net/quic/tquic/fec/fec_encoder.c"`
- `sed -n '349,350p' net/quic/tquic/fec/fec_encoder.c`
- `sed -n '341,342p' net/quic/tquic/fec/fec_encoder.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-531 -- Benchmark Code: Userspace, Not Kernel

**Severity:** S3 | **Category:** memory | **Sources:** A,B | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: build, memory.

**Key evidence present:** file:2, sym:12

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "apis" "net/tquic/bench/bench_common.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/bench/bench_common.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Consider moving benchmark code to a `tools/` or `tests/` directory to avoid confusion about its execution context. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bench/bench_common.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-532 -- CID Table Initialization Not Thread-Safe

**Severity:** S3 | **Category:** concurrency | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_cid" "net/tquic/tquic_cid.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_cid.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_cid.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-533 -- close_work Repurposes drain_work for Retransmit Scheduling

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "work_struct" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a separate delayed_work for close retransmission.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-535 -- Constant-Time Comparison Used for Integrity Tags

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_retry" "net/quic/tquic/tquic_retry.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_retry.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-536 -- Context Set Level Does Not Check init Return Values

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:7, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_exfil_ctx_set_level" "net/tquic/security/quic_exfil.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Check return values and either revert to the previous level or mark the context as failed.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-537 -- CRYPTO_TFM_REQ_MAY_BACKLOG in Atomic Context

**Severity:** S3 | **Category:** concurrency | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:3, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_hp_mask_aes" "net/tquic/crypto/header_protection.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/crypto/header_protection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Either (a) ensure callers never hold spinlocks when calling HP mask
generation, or (b) use `CRYPTO_TFM_REQ_MAY_SLEEP` only when in process context
and remove `MAY_BACKLOG` in atomic context, or (c) document the sleeping
requirement clearly.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/header_protection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-540 -- h3_varint_len Defined Multiple Times as Static

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "h3_varint_len" "net/quic/tquic/http3/http3_request.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_request.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-541 -- HMAC Output Not Zeroized on Fallback Path

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `memzero_explicit(hmac_out, sizeof(hmac_out));` before `goto fallback`.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-542 -- Inconsistent Error Return From verify_chain

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, line range.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `sed -n '2332,2332p' net/tquic/crypto/cert_verify.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-544 -- Lock Drop/Re-acquire Pattern in Key Derivation

**Severity:** S3 | **Category:** concurrency | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, security.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_ku_derive_next_generation" "net/tquic/crypto/key_update.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/crypto/key_update.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Pass `hash_tfm` as a separate parameter copied under the lock, rather
than passing the entire state.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/key_update.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-545 -- LOW: pacing_calc_gap uses division

**Severity:** S3 | **Category:** correctness | **Sources:** A,B | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, perf.

**Key evidence present:** file:2, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_output" "net/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Pre-compute `ns_per_byte = NSEC_PER_SEC Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_output.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-546 -- LOW: Prague RTT scaling division on every ACK

**Severity:** S3 | **Category:** correctness | **Sources:** A,B | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Sources disagree on category: Category disagreement across reports: correctness, perf.

**Key evidence present:** file:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Pre-compute a reciprocal multiplier for the RTT target to replace division with multiplication + shift. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/cong/prague.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-547 -- memzero_explicit Used Correctly for Key Material

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=symbol, line range.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, security.

**Key evidence present:** sym:2, lines:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -rn "tquic_retry" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-548 -- Minimal tracepoint overhead

**Severity:** S3 | **Category:** memory | **Sources:** A,B | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:7

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "recommendations" "net/tquic/diag/trace.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/diag/trace.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/diag/trace.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-550 -- Missing lockdep Annotations

**Severity:** S3 | **Category:** concurrency | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** sym:3, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -rn "lockdep_assert_held" net/tquic/`
- `rg -rn "spin_lock\|mutex_lock" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `lockdep_assert_held(&conn->lock)` at the beginning of functions that require `conn->lock` to be held. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-554 -- nla_put Operations in Netlink Properly Handle Failure

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_netlink" "net/quic/tquic/tquic_netlink.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_netlink.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-555 -- parse_basic_constraints Hardcoded BOOLEAN Length

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-556 -- Path Validation Response Queue Uses Two Tracking Mechanisms

**Severity:** S3 | **Category:** concurrency | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "skb_queue_len" "net/tquic/pm/path_validation.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/pm/path_validation.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use only one mechanism. `skb_queue_len()` is already atomic and thread-safe. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/pm/path_validation.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-557 -- quic_exfil.c Decoy Packet Size Controlled by MTU

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "quic_exfil" "net/quic/tquic/security/quic_exfil.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/security/quic_exfil.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-559 -- Retry Integrity Tag Computed with Potentially-Failing AEAD

**Severity:** S3 | **Category:** memory | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Return an error if the integrity tag cannot be computed rather than sending a tagless packet.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-560 -- SAN Parsing Capacity Limit Check Could Be Tighter

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Reduce limit to 1000 or add a total allocation size limit. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-561 -- Scheduler Lock Uses spin_lock Without _bh

**Severity:** S3 | **Category:** concurrency | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "spin_lock" "net/quic/tquic/sched/scheduler.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/sched/scheduler.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/sched/scheduler.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-562 -- server_ticket_key Is Static Global Without Rotation

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Implement periodic key rotation (e.g., every 24 hours) with support for decrypting tickets encrypted with the previous key.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-563 -- Slab Cache Names Are Not Module-Prefixed

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stream_ext" "net/tquic/core/stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use names like `"tquic_core_stream_ext"` for clarity. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/stream.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-565 -- tquic_conn_destroy -- thorough cleanup

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_conn_destroy" "net/quic/tquic/core/quic_connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/core/quic_connection.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-567 -- tquic_main.c init -- correct cascading cleanup

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:2, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_exit" "net/quic/tquic/tquic_main.c"`
- `sed -n '1198,1198p' net/quic/tquic/tquic_main.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-568 -- tquic_output_flush Holds conn->lock While Calling GFP_ATOMIC Allocation

**Severity:** S3 | **Category:** concurrency | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:7, lines:5

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_encap_recv" "net/tquic/tquic_output.c"`
- `sed -n '2071,2117p' net/tquic/tquic_output.c`
- `sed -n '2071,2071p' net/tquic/tquic_output.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Consider pre-allocating frame structures outside the lock, or batching frame preparation. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-569 -- tquic_pacing_cleanup -- correct ordering

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_pacing_cleanup" "net/quic/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_output.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-570 -- tquic_retry_rate_limit Potential Token Bucket Underflow

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_retry_rate_limit" "net/quic/tquic/tquic_retry.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_retry.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-571 -- tquic_stream_manager_destroy Does Not Free Extended State for All Streams

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:22, sym:4

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_stream_manager_destroy" "net/quic/tquic/http3/http3_conn.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_conn.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-572 -- tquic_timer_state_alloc -- cleanup loop is correct

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_timer_state_alloc" "net/quic/tquic/tquic_timer.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_timer.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-573 -- tquic_timer_state_free -- thorough and correct

**Severity:** S3 | **Category:** concurrency | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_timer_state_free" "net/quic/tquic/tquic_timer.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_timer.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_timer.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-574 -- Version Negotiation First Byte Missing Fixed Bit Randomization

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Snippet(s) contain only comments, not actual vulnerable code.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.

**Key evidence present:** file:1, sym:1, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "get_random_u8" "net/tquic/core/connection.c"`
- `sed -n '807,807p' net/tquic/core/connection.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-576 -- Version Negotiation Response - dcid/scid_len Not Capped

**Severity:** S3 | **Category:** memory | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_input" "net/quic/tquic/tquic_input.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_input.c where the fault occurs.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-577 -- Workqueue Not Validated Before Use

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, symbol.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** file:1, sym:4

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "tquic_validate_target_address" "net/tquic/security/quic_exfil.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** If `exfil_wq` is NULL, either send the packet immediately (bypassing timing normalization) or return an error so the caller can handle it. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-579 -- `bench_latency.c` Allocation Without Overflow Check

**Severity:** S3 | **Category:** perf | **Sources:** B | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:2, sym:1, lines:4, snippet:3

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_bench_latency" "net/quic/tquic/bench/tquic_bench_latency.c"`
- `sed -n '980,980p' net/quic/tquic/bench/tquic_bench_latency.c`
- `sed -n '840,840p' net/quic/tquic/bench/tquic_bench_latency.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-580 -- CPU-3: CID pool active count enumeration.

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:1, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_cid" "net/quic/tquic/tquic_cid.c"`
- `sed -n '617,617p' net/quic/tquic/tquic_cid.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_cid.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Maintain running `active_count` counter to avoid list traversal Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-581 -- spin_lock

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, line range, snippet.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, lines:2, snippet:1

**What's missing:**
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `sed -n '1015,1017p' net/tquic/tquic_input.c`
- `sed -n '251,251p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Change to `spin_lock_bh(&ctx->conn->lock)`. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-582 -- tquic_build_short_header_internal Writes pkt_num to buf+64 Scratch Space

**Severity:** S3 | **Category:** build | **Sources:** B | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, lines:4, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_build_short_header_internal" "net/tquic/tquic_output.c"`
- `sed -n '818,818p' net/tquic/tquic_output.c`
- `sed -n '1915,1915p' net/tquic/tquic_output.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Allocate a separate scratch buffer or use a function-local buffer:
```c
u8 pn_scratch[4];
pkt_num_len = tquic_encode_pkt_num(pn_scratch, pkt_num, largest_acked);
``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-583 -- tquic_gso_init Integer Overflow in Allocation Size

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:1, snippet:2

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_gso_init" "net/tquic/tquic_output.c"`
- `sed -n '1489,1489p' net/tquic/tquic_output.c`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `size_t` arithmetic with overflow checking:
```c
size_t alloc_size;
if (check_mul_overflow((size_t)gso->gso_size, (size_t)max_segs, &alloc_size))
    return -EINVAL;
``` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-584 -- UAF-ADD-02: - CID pool rotation_work vs pool destruction race window

**Severity:** S3 | **Category:** memory | **Sources:** B | **Priority:** 1.00

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.
- Single-source finding (source B); no independent confirmation.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, lines:5, snippet:1

**What's missing:**
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source

**Minimal verification:**
- `rg -n "tquic_cid" "net/tquic/tquic_cid.c"`
- `sed -n '980,1180p' net/tquic/tquic_cid.c`
- `sed -n '480,1170p' net/tquic/tquic_cid.c`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_cid.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-585 -- `bench_common.c` Variance Calculation

**Severity:** S3 | **Category:** tests | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/bench/bench_common.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-589 -- `tquic_sock_listen()` Redundant `INIT_LIST_HEAD` Check

**Severity:** S3 | **Category:** correctness | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_sock_listen" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-590 -- `tquic_stateless_reset_detect()` Iterates All Tokens Non-Constant-Time

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_stateless_reset_detect" "net/tquic/tquic_stateless_reset.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_stateless_reset.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-593 -- BPM Path Metrics min_rtt Initialized to UINT_MAX

**Severity:** S3 | **Category:** correctness | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_bpm" "net/tquic/bond/tquic_bpm.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/tquic_bpm.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-598 -- CPU-6: The QPACK decoder accepts a `max_table_capacity` parameter from the peer via SETTINGS. While the sysctl caps the 

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_path" "net/quic/tquic/http3/qpack_decoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Audit SETTINGS parsing to confirm capacity is clamped Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/qpack_decoder.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-601 -- Failover Sent Packet Count Can Go Negative

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_failover" "net/tquic/bond/tquic_failover.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/bond/tquic_failover.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/tquic_failover.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-603 -- MEM-3: The NF connection tracking limit (65536) has no per-source-IP limit at the netfilter layer. While the TQUIC proto

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:3, lines:2

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_stream_open_incoming" "net/quic/tquic/tquic_nf.c"`
- `sed -n '497,497p' net/quic/tquic/tquic_nf.c`
- `sed -n '634,648p' net/quic/tquic/tquic_nf.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add per-IP NF tracking limit (e.g., 256 entries per source IP) Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-606 -- Multicast Group Only Requires CAP_NET_ADMIN

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=symbol, line range, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, lines:5, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_cid_security_check_new_cid" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-608 -- Multiple Varint Implementations

**Severity:** S3 | **Category:** correctness | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:10, sym:2, lines:5

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_input" "net/quic/tquic/crypto/extended_key_update.c"`
- `sed -n '171,171p' net/quic/tquic/crypto/extended_key_update.c`
- `sed -n '49,131p' net/quic/tquic/crypto/extended_key_update.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-609 -- Netlink Attribute Policy Does Not Use Strict Validation for Binary Addresses

**Severity:** S3 | **Category:** correctness | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:6, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "nla_len" "net/tquic/tquic_netlink.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-612 -- Priority Extension Allocation Race

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 2/5: present=file, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/core/priority.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-622 -- Stream Creation Not Bounded in Input Path

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=symbol, line range, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, lines:2, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_stream_open_incoming" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-623 -- timer_setup with NULL Callback

**Severity:** S3 | **Category:** correctness | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, line range.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `sed -n '102,117p' net/tquic/sched/deadline_aware.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-626 -- tquic_encode_varint Does Not Validate val Range

**Severity:** S3 | **Category:** correctness | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_encode_varint" "net/tquic/tquic_output.c"`
- `sed -n '164,198p' net/tquic/tquic_output.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add validation: `if (val >= (1ULL << 62)) return -EINVAL;` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-629 -- tquic_process_ack_frame Does Not Validate largest_ack vs first_ack_range

**Severity:** S3 | **Category:** correctness | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_process_ack_frame" "net/tquic/tquic_input.c"`
- `sed -n '601,660p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add: `if (first_ack_range > largest_ack) return -EINVAL;` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-631 -- tquic_process_coalesced Missing Infinite Loop Guard

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, lines:2

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_process_coalesced" "net/tquic/tquic_input.c"`
- `sed -n '3079,3182p' net/tquic/tquic_input.c`
- `sed -n '3169,3169p' net/tquic/tquic_input.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `if (packets > 16) break;` to cap coalesced packets. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-635 -- tquic_stream_release Missing Error Return

**Severity:** S3 | **Category:** correctness | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** low

**Reason:**
- Evidence score 3/5: present=file, symbol, line range.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, lines:1

**What's missing:**
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_stream_release" "net/quic/tquic/tquic_stream.c"`
- `sed -n '643,643p' net/quic/tquic/tquic_stream.c`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-636 -- tquic_stream_set_priority Missing Lock Protection

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 0.70

**Verdict:** PLAUSIBLE | **Confidence after judging:** medium

**Reason:**
- Evidence score 3/5: present=file, symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2, snippet:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_stream" "net/quic/tquic/core/stream.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/core/stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

## SPECULATIVE Findings (116)

### CF-043 -- No security_socket_* Hook Invocations

**Severity:** S0 | **Category:** concurrency | **Sources:** B,C | **Priority:** 10.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** sym:10

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -rn "tquic_sock_bind" net/tquic/`
- `rg -rn "spin_lock\|mutex_lock" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Invoke appropriate `security_socket_*` hooks in TQUIC socket operations. At minimum:
- `security_socket_create()` in `tquic_sock_create()`
- `security_socket_connect()` in `tquic_connect_socket()`
- `security_socket_bind()` in `tquic_sock_bind()` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-087 -- (actual): `tquic_hs_process_server_hello` -- missing check before cipher suite read

**Severity:** S0 | **Category:** other | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_hs_process_server_hello" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `if (p + 2 > end) return -EINVAL;` before the cipher suite read.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-088 -- (Revised): tquic_process_packet Does Not Validate pkt_num_len Against Remaining Data (tquic_input.c, lines 2528-2529, 25

**Severity:** S0 | **Category:** other | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, snippet:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_process_packet" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a bounds check before decoding the packet number:
```c
if (ctx.offset + pkt_num_len > len)
    return -EINVAL;
```

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-090 -- AF_XDP Socket and Device Lookup Use init_net (Container Escape)

**Severity:** S0 | **Category:** other | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "ns_capable" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Replace `&init_net` with `current->nsproxy->net_ns` consistently, and use `ns_capable()` instead of `capable()` to check capabilities relative to the correct namespace.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-091 -- Attacker-Controlled Allocation Sizes

**Severity:** S0 | **Category:** concurrency | **Sources:** B | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** lines:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-093 -- Client Certificate Verification Uses Server Logic (EKU Bypass)

**Severity:** S0 | **Category:** security | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_hs_verify_client_cert" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** `tquic_hs_verify_client_cert` must call `verify_chain(ctx, false)` instead of delegating to the server verification function.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-094 -- conn->sk Accessed Without Lock After Stateless Reset (tquic_input.c, lines 397-407)

**Severity:** S0 | **Category:** other | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_input" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Hold a reference to the socket (`sock_hold(sk)`) under the lock, then call `sk_state_change`, then release the reference (`sock_put(sk)`).

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-103 -- IPv4/IPv6 Address Discovery Enumerates Host Interfaces (Container Escape / Info Leak)

**Severity:** S0 | **Category:** other | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** snippet:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `sock_net(conn->sk)` to enumerate only devices visible in the connection's namespace.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-105 -- List Iterator Invalidation in BPM Netdev Notifier (Drop-Relock Pattern)

**Severity:** S0 | **Category:** concurrency | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_bpm_path_set_state" net/tquic/`
- `rg -rn "spin_lock\|mutex_lock" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `list_for_each_entry_safe()` is NOT sufficient here since the iteration continues after relock. Instead, collect paths to process into a separate list under the lock, then process them after releasing the lock.

--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-107 -- MASQUE CONNECT-UDP Proxy Creates Sockets in init_net (Container Escape)

**Severity:** S0 | **Category:** other | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** The tunnel must inherit the network namespace from the QUIC connection's socket: `sock_net(tunnel->conn->sk)`.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-108 -- Missing Bounds Check Before Frame Type Read

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=line range, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** lines:2, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-109 -- Packet Number Length Extracted Before Header Unprotection (tquic_input.c, lines 2529, 2545 vs 2565)

**Severity:** S0 | **Category:** other | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, snippet:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_remove_header_protection" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Move the `pkt_num_len` extraction to AFTER `tquic_remove_header_protection()`:
```c
ret = tquic_remove_header_protection(conn, data, ctx.offset, ...);
if (ret < 0) return ret;
pkt_num_len = (data[0] & 0x03) + 1;  // Now reads unprotected bits
if (ctx.offset + pkt_num_len > len) return -EINVAL;
``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-111 -- Potential Integer Overflow in CRYPTO Frame on 32-bit

**Severity:** S0 | **Category:** correctness | **Sources:** B | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=line range, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** lines:1, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-114 -- QUIC-over-TCP Client and Server Sockets Use init_net (Container Escape)

**Severity:** S0 | **Category:** other | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "quic_conn" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Propagate `sock_net(quic_conn->sk)` to the TCP socket creation.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-116 -- Rate Calculation Integer Overflow (`count * 1000`)

**Severity:** S0 | **Category:** other | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** snippet:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Cast to `u64` before multiplication:
```c
rate = (u64)count * 1000 Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-117 -- Reason Length Underflow on 32-bit

**Severity:** S0 | **Category:** correctness | **Sources:** B | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=line range, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** lines:1, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-121 -- RX parsing/decryption assumes contiguous skb data (non-linear skb / GRO risk)

**Severity:** S0 | **Category:** memory | **Sources:** A | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source A); no independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- FP-risk: Single-source S0 finding with no line ranges or snippets -- severity may be inflated.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "skb_copy_bits" "net/tquic/tquic_input.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_input.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** - Linearize the skb before any parsing/decryption that assumes contiguity, or use `skb_copy_bits()` into a contiguous buffer for header+payload.
- Do this *before* using `data[offset]` patterns. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_input.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-123 -- Stale skb->len Read After ip_local_out (tquic_output.c, lines 1730-1736)

**Severity:** S0 | **Category:** other | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, snippet:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "ip_local_out" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Save `skb->len` in a local variable before calling `ip_local_out()`:
```c
u32 pkt_len = skb->len;
ret = ip_local_out(&init_net, NULL, skb);
if (ret >= 0) {
    path->stats.tx_bytes += pkt_len;
```

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-124 -- TOCTOU Race in Failover Hysteresis (Atomic Read-Modify-Write)

**Severity:** S0 | **Category:** concurrency | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, snippet:3

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "atomic_inc_return" net/tquic/`
- `rg -rn "spin_lock\|mutex_lock" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Either protect these operations with a per-path spinlock, or use `atomic_inc_return()` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-126 -- Tunnel Socket Creation Uses init_net (Container Escape)

**Severity:** S0 | **Category:** other | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Must use `sock_net(conn->sk)` or propagate the caller's namespace. The tunnel struct should store a `struct net *` reference obtained from the originating socket.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-130 -- Use-After-Free in `tquic_migrate_auto()` -- RCU-Protected Path Used After RCU Unlock

**Severity:** S0 | **Category:** memory | **Sources:** B | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- FP-risk: Single-source S0 finding with no line ranges or snippets -- severity may be inflated.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:6

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_migrate_auto" "net/tquic/tquic_migration.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/tquic_migration.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-133 -- Use-After-Free in Path Lookup (tquic_input.c, lines 245-261)

**Severity:** S0 | **Category:** other | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:3, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_path_put" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Implement reference counting on `tquic_path` objects. The lookup function should atomically increment the refcount under `paths_lock` before returning. Callers must call `tquic_path_put()` when done.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-135 -- Wrong Network Namespace in ip_local_out (tquic_output.c, line 1730)

**Severity:** S0 | **Category:** other | **Sources:** C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1, snippet:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_output" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `sock_net(conn->sk)` instead of `&init_net`. The correct network namespace was already computed at line 1681 in the `rt` lookup:
```c
ret = ip_local_out(net, conn->sk, skb);
```

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-204 -- MASQUE Proxy Has No Access Control

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Require `CAP_NET_ADMIN` to enable MASQUE proxy functionality.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/masque/connect_udp.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-219 -- Retry Integrity Tag Uses Wrong Key/Nonce for QUIC v2

**Severity:** S1 | **Category:** security | **Sources:** B,C | **Priority:** 7.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Select retry integrity key/nonce based on `conn->version`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-258 -- (Revised): tquic_pacing_work Accesses skb->len After tquic_output_packet (tquic_output.c, lines 1413-1418)

**Severity:** S1 | **Category:** other | **Sources:** C | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:3, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_output_packet" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Save `skb->len` before calling `tquic_output_packet()`.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-259 -- 0-RTT Keys Derived With Empty Transcript

**Severity:** S1 | **Category:** security | **Sources:** B | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Snippet(s) contain only comments, not actual vulnerable code.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-260 -- 0-RTT Keys Derived With Empty Transcript (Not ClientHello Hash)

**Severity:** S1 | **Category:** security | **Sources:** C | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- FP-risk: Snippet(s) contain only comments, not actual vulnerable code.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_zero_rtt_derive_secret" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** The ClientHello hash must be included in the key derivation. Use `tquic_zero_rtt_derive_secret` (which does accept `client_hello_hash`) instead of `tquic_zero_rtt_derive_keys` for actual connections.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-261 -- `setsockopt(SOL_TQUIC, ...)` forces `optlen >= sizeof(int)` even for string/binary options

**Severity:** S1 | **Category:** api | **Sources:** A | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source A); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:4

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "copy_from_sockptr" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** - Move `copy_from_sockptr(&val, ...)` inside the integer-valued cases only. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-263 -- ACK Frame bytes_acked Calculation Can Overflow (tquic_input.c, lines 736-738)

**Severity:** S1 | **Category:** other | **Sources:** C | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_input" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Cap `first_ack_range` to a reasonable value (e.g., the maximum number of packets in flight) before the multiplication. Alternatively, cap `bytes_acked` to the actual bytes in flight.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-264 -- Aggregate Scheduler Unfair Minimum Weight Floor

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/multipath/sched_aggregate.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-273 -- h3_request_send_headers State Check TOCTOU

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "h3_request_send_headers" "net/quic/tquic/http3/http3_request.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/http3/http3_request.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_request.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-275 -- HIGH: Multiple ktime_get() calls per packet

**Severity:** S1 | **Category:** perf | **Sources:** A | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source A); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:3, sym:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "ktime_get" "net/tquic/napi.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Read the timestamp once at the start of packet processing and pass it through the context. The `tquic_rx_ctx` struct already exists and could carry a `ktime_t recv_time` field. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/napi.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-277 -- Large Stack Allocation in XOR Recovery

**Severity:** S1 | **Category:** correctness | **Sources:** B | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "attempt_xor_recovery" "net/tquic/fec/fec_decoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/fec/fec_decoder.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-278 -- Memory Exhaustion via Unbounded QPACK Header Lists

**Severity:** S1 | **Category:** security | **Sources:** B | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "qpack_header_list_add" "net/quic/tquic/http3/qpack.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/qpack.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-281 -- Multipath Frame Processing Lacks Encryption Level Validation (tquic_input.c, lines 2027-2038)

**Severity:** S1 | **Category:** other | **Sources:** C | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, snippet:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_input" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add encryption level checks for all multipath frame types. They should only be accepted in 1-RTT packets (and possibly 0-RTT):
```c
} else if (frame_type == 0x40) {
    if (is_initial || is_handshake) {
        conn->error_code = EQUIC_FRAME_ENCODING;
        return -EPROTO;
    }
    ret = tquic... Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-282 -- Multiple ktime_get() calls per packet

**Severity:** S1 | **Category:** perf | **Sources:** B | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:3, sym:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "already" "net/tquic/tquic_output.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_output.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-288 -- Same Stack Issue in Encoder

**Severity:** S1 | **Category:** perf | **Sources:** B | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "generate_rs_repair" "net/tquic/fec/fec_encoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Pin down exact line range in net/tquic/fec/fec_encoder.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-290 -- sched/scheduler.c wrr_select Stale total_weight

**Severity:** S1 | **Category:** correctness | **Sources:** B | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/sched/scheduler.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-291 -- Stale Path Pointer Returned After rcu_read_unlock

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:4

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_path_remove" net/tquic/`
- `rg -rn "spin_lock\|mutex_lock" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-293 -- TOCTOU in Round-Robin Path Count vs Selection

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/multipath/sched_minrtt.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-296 -- tquic_output_packet Passes NULL conn to ip_local_out (tquic_output.c, line 1413)

**Severity:** S1 | **Category:** other | **Sources:** C | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:3, snippet:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_output_packet" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Store a reference to `conn` in `tquic_pacing_state` and pass it through. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-300 -- tquic_udp_recv Processes Stateless Reset Before Authenticating Packet (tquic_input.c, lines 2916-2932)

**Severity:** S1 | **Category:** other | **Sources:** C | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_udp_recv" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Only check for stateless reset AFTER regular decryption fails (RFC 9000 Section 10.3.1 recommends this order). The check should be a last resort, not a first check.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-304 -- Unit tests model packet-number length as readable from the first byte without HP removal

**Severity:** S1 | **Category:** concurrency | **Sources:** A | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source A); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:5

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "plan" "net/tquic/test/packet_test.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/test/packet_test.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** - Add tests that build a packet with header protection applied, run HP unprotect, and then validate pn_len and key_phase. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/test/packet_test.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-308 -- Weighted Scheduler Has No Lock Protection

**Severity:** S1 | **Category:** concurrency | **Sources:** B | **Priority:** 4.90

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "weighted_get_path" "net/tquic/multipath/sched_weighted.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/multipath/sched_weighted.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/multipath/sched_weighted.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-329 -- WebTransport: TOCTOU in Datagram Queue Push

**Severity:** S2 | **Category:** concurrency | **Sources:** A,B,C | **Priority:** 4.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- All 3 audit sources (A, B, C) independently flagged this issue.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, other.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Perform the size check and push atomically under a lock, or use an atomic counter with compare-and-swap. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/webtransport.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-354 -- Anti-Replay Hash Table Cleanup Iterates All Buckets Under spinlock

**Severity:** S2 | **Category:** concurrency | **Sources:** B,C | **Priority:** 4.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: concurrency, correctness.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a separate periodic cleanup timer rather than inline cleanup, or maintain a time-ordered list for efficient expiration. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/early_data.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-382 -- Interop Framework - Same Pattern

**Severity:** S2 | **Category:** tests | **Sources:** B,C | **Priority:** 4.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, tests.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/test/interop/interop_framework.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-406 -- Per-path stats updated from both RX and TX

**Severity:** S2 | **Category:** correctness | **Sources:** A,B | **Priority:** 4.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, perf.

**Key evidence present:** sym:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -rn "tquic_input" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Split path stats into `____cacheline_aligned` RX and TX sections, or use per-CPU counters for path stats. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-437 -- WebTransport Session Refcount Not Checked After Accept

**Severity:** S2 | **Category:** memory | **Sources:** B,C | **Priority:** 4.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: memory, other.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/http3/webtransport.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Audit all callers of session-returning functions and ensure every get has a matching put.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/webtransport.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-456 -- 0-RTT Encrypt Allocates AEAD Per-Packet (Performance / Side Channel)

**Severity:** S2 | **Category:** security | **Sources:** C | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_zero_rtt_keys" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Allocate the AEAD transform once during key derivation and store it in `tquic_zero_rtt_keys`. Reuse for all packets.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-457 -- All MP Scheduler init() Functions Silently Fail on OOM

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:8

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "aggregate_init" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-459 -- AMP-2: The `tquic_path_handle_challenge` function in `pm/path_validation.c:249` does not check anti-amplification limits

**Severity:** S2 | **Category:** security | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_path_handle_challenge" "net/quic/tquic/pm/path_validation.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Check `tquic_path_anti_amplification_check` before queuing response; charge response bytes to `bytes_sent` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/pm/path_validation.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-462 -- asn1_get_length Does Not Handle Length 0x84+ (4+ byte lengths)

**Severity:** S2 | **Category:** security | **Sources:** C | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-463 -- Coalesced Packet Processing Silently Truncates on Overflow (tquic_input.c, lines 3172-3173)

**Severity:** S2 | **Category:** other | **Sources:** C | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1, snippet:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_input" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Instead of silently truncating, reject the coalesced packet entirely when the claimed length exceeds remaining data:
```c
if (offset + pkt_len > total_len)
    break;  /* Malformed coalesced packet -- stop */
``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-466 -- Duplicate ECF Path State Allocation Race

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/multipath/sched_ecf.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-467 -- ECN State Tracking Per-Round Limitation

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on severity: Severity disagreement across reports: S2, S3.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_cong" "net/tquic/cong/tquic_cong.h"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/cong/tquic_cong.h where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-469 -- h3_parser_advance Missing Bounds Check

**Severity:** S2 | **Category:** memory | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "h3_parser_advance" "net/quic/tquic/http3/http3_frame.h"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/http3/http3_frame.h"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_frame.h where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-472 -- ktime_get_ts64 Written to skb->cb May Exceed cb Size (tquic_input.c, line 1471)

**Severity:** S2 | **Category:** other | **Sources:** C | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_input" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use a typed union or dedicated struct for `skb->cb` usage, documented per frame type.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-473 -- Lock Ordering Between Encoder and Scheduler

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_fec_should_send_repair" "net/tquic/fec/fec_scheduler.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/fec/fec_scheduler.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/fec/fec_scheduler.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-478 -- Path Manager discover_addresses Holds rtnl_lock While Accessing inet6_dev

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "rtnl_lock" "net/tquic/pm/path_manager.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/pm/path_manager.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/pm/path_manager.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-479 -- Priority State No Limit on stream_count

**Severity:** S2 | **Category:** api | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_priority.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-480 -- Push Entry Count O(n) Iteration

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_conn.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-483 -- sched/scheduler.c ECF Loss Rate Division by Zero

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/sched/scheduler.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-485 -- STATE-1: The transition to "attack mode" (TQUIC_RL_COOKIE_REQUIRED) appears to be reactive -- it triggers when rate limi

**Severity:** S2 | **Category:** security | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Consider proactive cookie validation when pre-handshake memory exceeds 50% of budget, independent of rate limit triggers Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/rate_limit.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-486 -- tquic_gro_flush Drops and Re-acquires Lock Per Packet (tquic_input.c, lines 2303-2310)

**Severity:** S2 | **Category:** other | **Sources:** C | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_gro_flush" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** After the loop, set `held_count = skb_queue_len(&gro->hold_queue)`.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-488 -- tquic_main.c init/exit -- conditional cleanup mismatch for NAPI/io_uring

**Severity:** S2 | **Category:** other | **Sources:** C | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_main" "err_netlink:"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-489 -- tquic_recv_datagram Can Loop Forever Under Signal Pressure (tquic_output.c, lines 2706-2743)

**Severity:** S2 | **Category:** other | **Sources:** C | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, snippet:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_recv_datagram" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a retry counter to prevent excessive looping:
```c
int retries = 0;
... Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-490 -- Triplicated Varint Encode/Decode Implementations

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:3

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_frame.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-496 -- Version Negotiation Versions Logged Without Rate Limiting (tquic_input.c, lines 473-477)

**Severity:** S2 | **Category:** other | **Sources:** C | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_input" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Either remove the per-version debug line or cap the number of logged versions.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-497 -- WebTransport Datagram Queue Double-Checked Locking Anti-Pattern

**Severity:** S2 | **Category:** concurrency | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/webtransport.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-498 -- Weighted Scheduler Weight Not Validated

**Severity:** S2 | **Category:** correctness | **Sources:** B | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/tquic/multipath/sched_weighted.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-500 -- XDP Uses capable() Instead of ns_capable()

**Severity:** S2 | **Category:** other | **Sources:** C | **Priority:** 2.80

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-505 -- HTTP/3 Priority: push_buckets Not Initialized

**Severity:** S3 | **Category:** correctness | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other, perf.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Explicitly initialize `push_buckets[]` in the priority init function for defensive coding. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/http3/http3_priority.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-509 -- Netlink Events Do Not Include Timestamp

**Severity:** S3 | **Category:** security | **Sources:** A,B,C | **Priority:** 1.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- All 3 audit sources (A, B, C) independently flagged this issue.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, security.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-534 -- Consistent use of kfree_sensitive for key material -- GOOD

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: other, security.

**Key evidence present:** sym:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -rn "tquic_server" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-539 -- Empty Hash Computed Without Algorithm Validation

**Severity:** S3 | **Category:** security | **Sources:** B,C | **Priority:** 1.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Zero-initialize `empty_hash` or use `memzero_explicit` after use.

--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-543 -- io_uring.c getsockopt Same len Validation Pattern

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/io_uring.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-549 -- Missing Error Check for init_net Reference

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, other.

**Key evidence present:** sym:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -rn "tquic_tunnel" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Store the network namespace reference at module load time and add a helper function that returns the appropriate namespace.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-552 -- Multiple Redundant Varint Implementations

**Severity:** S3 | **Category:** correctness | **Sources:** B,C | **Priority:** 1.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** sym:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -rn "tquic_input" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Consolidate to a single implementation in `varint.c`/`varint.h` and use it everywhere. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-575 -- Version Negotiation Packet Size Not Validated Against 256-Byte Buffer

**Severity:** S3 | **Category:** memory | **Sources:** B,C | **Priority:** 1.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (B, C) agree; partial independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Sources disagree on category: Category disagreement across reports: correctness, memory.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/core/connection.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add a bounds check or use the `p - packet < sizeof(packet)` idiom. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/core/connection.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-578 -- XOR FEC encoding is efficient

**Severity:** S3 | **Category:** concurrency | **Sources:** A,B | **Priority:** 1.00

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- 2 of 3 sources (A, B) agree; partial independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** sym:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue

**Minimal verification:**
- `rg -rn "scheme" net/tquic/`
- `rg -rn "spin_lock\|mutex_lock" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Missing fix suggestion in source text. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-586 -- `bench_common.c` Variance Calculation (Userspace Code)

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-587 -- `bench_latency.c` Allocation Without Overflow Check (Userspace Code)

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** snippet:4

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Validate before truncation:
```c
if (val > U8_MAX)
    return -EINVAL;
data->flags = (u8)val;
``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-588 -- `tquic_accept()` Nested Locking Pattern

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_accept" "net/tquic/tquic_socket.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/tquic_socket.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-591 -- Aggregate Scheduler Long Spinlock Hold

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "ktime_get" "net/tquic/multipath/sched_aggregate.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/multipath/sched_aggregate.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/multipath/sched_aggregate.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-592 -- Benchmark Code: Userspace, Not Kernel

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Consider moving benchmark code to a `tools/` or `tests/` directory to avoid confusion about its execution context. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bench/ where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-594 -- C99 Variable Declaration in Loop

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_xor_decode" "net/tquic/fec/xor_fec.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/fec/xor_fec.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/fec/xor_fec.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-595 -- Constant-Time Comparison

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "crypto_memneq" "net/tquic/cong/cong_data.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/cong/cong_data.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-596 -- Coupled CC Alpha Smoothing May Suppress Rapid Changes

**Severity:** S3 | **Category:** api | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "crypto_memneq" "net/tquic/bond/cong_coupled.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Pin down exact line range in net/tquic/bond/cong_coupled.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-599 -- CROSS-2: Consider using the `tquic_rx_buf_cache` slab cache pattern (already used at `tquic_input.c:2586`) more broadly 

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_rx_buf_cache" "net/quic/tquic/"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/ where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-600 -- Debug Logging of Packet Contents

**Severity:** S3 | **Category:** correctness | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_dbg" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-602 -- INFO-1: Several `pr_debug`/`tquic_dbg` calls include connection state information. While these are compile-time optional

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:3, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_dbg" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-604 -- MEM-4: While stream count is limited, each stream allocates both `send_buf` and `recv_buf` skb queues. An attacker openi

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_main" "net/quic/tquic/tquic_main.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Consider lazy initialization of stream buffers Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_main.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-605 -- Missing Documentation on Lock Ordering

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- FP-risk: Snippet(s) contain only comments, not actual vulnerable code.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** file:2, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_bonding" "net/tquic/fec/"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/fec/"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/fec/ where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-607 -- Multiple Scheduler Registration Systems Coexist

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:4

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_scheduler" net/tquic/`
- `rg -rn "spin_lock\|mutex_lock" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-610 -- No Per-Connection Frame Processing Budget

**Severity:** S3 | **Category:** correctness | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_process_frames" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-611 -- Path Validation Timer del_timer vs del_timer_sync

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "del_timer_sync" "net/tquic/pm/path_validation.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/tquic/pm/path_validation.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/tquic/pm/path_validation.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-613 -- PROTO-1: The retire loop at `tquic_cid.c:667-674` iterates the entire remote CID list for each NEW_CONNECTION_ID frame, 

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_cid" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-614 -- Repair Data Pointer Lifetime

**Severity:** S3 | **Category:** memory | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:2, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_fec_get_pending_repair" "net/tquic/fec/fec_encoder.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/tquic/fec/fec_encoder.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/fec/fec_encoder.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-615 -- send_skb Variable Used After Potential NULL

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-616 -- Sensitive Key Cleanup

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "kfree_sensitive" "net/tquic/cong/cong_data.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/tquic/cong/cong_data.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-617 -- settings seen_mask Limited to 64 Settings

**Severity:** S3 | **Category:** correctness | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/http3/http3_settings.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-618 -- spin_lock (Not spin_lock_bh) Used in tquic_process_max_data_frame (tquic_input.c, lines 1015-1017)

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_process_max_data_frame" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Change to `spin_lock_bh(&ctx->conn->lock)`.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-619 -- STATE-2: An attacker could open connections, complete the handshake (consuming 1 connection per client rate token), then

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Enforce a maximum concurrent connections per-IP limit (distinct from rate limit), e.g., 32 connections per source IP Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_sysctl.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-620 -- STATE-3: No visible limit on the number of paths per connection. If an attacker can trigger path creation (via connectio

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=line range, snippet.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** lines:2, snippet:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Enforce max paths per connection limit Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-621 -- Stateless Reset Token Comparison Timing

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, line range.
- Single-source finding (source B); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:5, lines:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "crypto_memneq" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-624 -- tquic_build_short_header_internal Writes pkt_num to buf+64 Scratch Space (tquic_output.c, line 818)

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:6, snippet:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_build_short_header_internal" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Allocate a separate scratch buffer or use a function-local buffer:
```c
u8 pn_scratch[4];
pkt_num_len = tquic_encode_pkt_num(pn_scratch, pkt_num, largest_acked);
```

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-625 -- tquic_encap_recv Double UDP Header Strip

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:1

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_encap_recv" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-627 -- tquic_encode_varint Does Not Validate val Range (tquic_output.c, lines 164-198)

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:3

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_encode_varint" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add validation: `if (val >= (1ULL << 62)) return -EINVAL;`

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-628 -- tquic_gso_init Integer Overflow in Allocation Size (tquic_output.c, line 1489)

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=symbol, snippet.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2, snippet:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_gso_init" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Use `size_t` arithmetic with overflow checking:
```c
size_t alloc_size;
if (check_mul_overflow((size_t)gso->gso_size, (size_t)max_segs, &alloc_size))
    return -EINVAL;
```

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-630 -- tquic_process_ack_frame Does Not Validate largest_ack vs first_ack_range (tquic_input.c, lines 601-660)

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_process_ack_frame" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add: `if (first_ack_range > largest_ack) return -EINVAL;`

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-632 -- tquic_process_coalesced Missing Infinite Loop Guard (tquic_input.c, lines 3079-3182)

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** sym:2

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -rn "tquic_process_coalesced" net/tquic/`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add `if (packets > 16) break;` to cap coalesced packets.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-633 -- tquic_sched_release Frees ext Under Lock but kfree Can Sleep

**Severity:** S3 | **Category:** memory | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_sched_release" "net/quic/tquic/core/priority.c"`
- `rg -n "kmalloc\|kzalloc\|alloc_skb\|memcpy" "net/quic/tquic/core/priority.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/core/priority.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-634 -- tquic_stream_alloc Uses GFP_KERNEL in Potentially Atomic Context

**Severity:** S3 | **Category:** concurrency | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 2/5: present=file, symbol.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1, sym:2

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `rg -n "tquic_stream_alloc" "net/quic/tquic/tquic_stream.c"`
- `rg -n "spin_lock\|mutex_lock\|lock_sock" "net/quic/tquic/tquic_stream.c"`
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.

**Required next artifacts:**
- Pin down exact line range in net/quic/tquic/tquic_stream.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-637 -- Weighted DRR Iterates Over Empty Slots

**Severity:** S3 | **Category:** perf | **Sources:** B | **Priority:** 0.70

**Verdict:** SPECULATIVE | **Confidence after judging:** low

**Reason:**
- Evidence score 1/5: only one evidence type present -- weak.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** file:1

**What's missing:**
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Pin down exact line range in net/tquic/multipath/sched_weighted.c where the fault occurs.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

## REJECTED Findings (10)

### CF-454 -- CROSS-1: The systematic use of `jhash` with seed 0 across 15+ call sites creates a coordinated attack vector. An attacke

**Severity:** S1 | **Category:** security | **Sources:** B | **Priority:** 2.80

**Verdict:** REJECTED | **Confidence after judging:** low

**Reason:**
- Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** NONE

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-597 -- Coupled CC Alpha Smoothing May Suppress Rapid Changes

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.70

**Verdict:** REJECTED | **Confidence after judging:** low

**Reason:**
- Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.
- Single-source finding (source C); no independent confirmation.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** NONE

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Consider faster convergence when path count changes. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-638 -- ACK Frequency Frame Type Inconsistency

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.40

**Verdict:** REJECTED | **Confidence after judging:** low

**Reason:**
- Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.
- Single-source finding (source C); no independent confirmation.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** NONE

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Verify the frame type dispatch logic handles multi-byte frame types correctly. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-639 -- copy_from_sockptr in setsockopt Always Uses sizeof(type)

**Severity:** S3 | **Category:** memory | **Sources:** C | **Priority:** 0.40

**Verdict:** REJECTED | **Confidence after judging:** low

**Reason:**
- Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.
- Single-source finding (source C); no independent confirmation.
- FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** NONE

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-640 -- Diagnostic Counter Wraps

**Severity:** S3 | **Category:** correctness | **Sources:** B | **Priority:** 0.40

**Verdict:** REJECTED | **Confidence after judging:** low

**Reason:**
- Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.
- Single-source finding (source B); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** NONE

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-641 -- Error Codes Leak Processing State

**Severity:** S3 | **Category:** security | **Sources:** B | **Priority:** 0.40

**Verdict:** REJECTED | **Confidence after judging:** low

**Reason:**
- Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.
- Single-source finding (source B); no independent confirmation.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** NONE

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-642 -- IMMEDIATE_ACK Frame Type Similar Issue

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.40

**Verdict:** REJECTED | **Confidence after judging:** low

**Reason:**
- Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.
- Single-source finding (source C); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** NONE

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-643 -- Inconsistent Congestion State Layouts

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.40

**Verdict:** REJECTED | **Confidence after judging:** low

**Reason:**
- Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.
- Single-source finding (source C); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** NONE

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-644 -- Multiple Varint Implementations (Code Duplication Risk)

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.40

**Verdict:** REJECTED | **Confidence after judging:** low

**Reason:**
- Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.
- Single-source finding (source C); no independent confirmation.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.
- Single-source finding -- no independent confirmation.

**Key evidence present:** NONE

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Consolidate to the single canonical implementation in `core/varint.c` and export symbols for all callers.

--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

### CF-645 -- Three Parallel Scheduler Frameworks

**Severity:** S3 | **Category:** other | **Sources:** C | **Priority:** 0.40

**Verdict:** REJECTED | **Confidence after judging:** low

**Reason:**
- Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.
- Single-source finding (source C); no independent confirmation.
- FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.
- FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.
- Highest severity retained but flagged as weakly evidenced.

**Key evidence present:** NONE

**What's missing:**
- Concrete source file path (e.g., net/tquic/...)
- Exact line range(s) where the fault manifests
- Code snippet proving the vulnerable pattern
- Function/struct symbol name at the fault site
- Kernel log / stack trace / error output demonstrating the issue
- Independent confirmation from a second audit source
- Minimal reproduction steps (expected vs. actual)

**Minimal verification:**
- `make M=net/tquic W=1`
- `make M=net/tquic C=1  # sparse static analysis`

**Safest fix:** Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.

**Required next artifacts:**
- Identify the exact source file (e.g., net/tquic/...) where the bug manifests.
- Provide a minimal code snippet from the source showing the vulnerable pattern.
- Obtain independent confirmation from a second auditor or a failing test case.
- Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.
- Create a targeted KUnit or kselftest that triggers the bug and fails before the fix.

---

*Generated by judge_findings.py -- Skeptical Code Audit Judge.*
*No new findings introduced. No commands were executed.*
