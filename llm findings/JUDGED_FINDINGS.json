[
  {
    "cid": "CF-001",
    "title": "Adaptive Scheduler cwnd_avail Underflow",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:4, snippet:5",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_scheduler\" \"net/tquic/multipath/tquic_scheduler.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add an explicit check: `cwnd_avail = (path->cc.cwnd > path->cc.bytes_in_flight) ? path->cc.cwnd - path->cc.bytes_in_flight : 0;` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/multipath/tquic_scheduler.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-003",
    "title": "Client Certificate Verification Uses Server Logic",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Sources disagree on severity: Severity disagreement across reports: S0, S1."
    ],
    "key_evidence_present": "file:1, sym:5, lines:2, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_verify_client_cert\" \"net/tquic/crypto/cert_verify.c\"",
      "sed -n '2450,2450p' net/tquic/crypto/cert_verify.c",
      "sed -n '2243,2243p' net/tquic/crypto/cert_verify.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a `bool is_server` parameter to the internal `verify_chain()` call path, or refactor so that client cert verification passes `is_server=false`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-004",
    "title": "Connection Destroy Calls Sleeping Function Under Spinlock",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"h3_connection_destroy\" \"net/tquic/http3/http3_stream.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/http3/http3_stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Collect stream pointers into a local list under the spinlock, release the spinlock, then close each stream outside the lock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/http3_stream.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-005",
    "title": "Fragile Hardcoded Offset for Key Update State Access",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, sym:9, snippet:4",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"change\" \"net/tquic/crypto/key_update.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a proper typed structure with a named field, or use `container_of()` macro. Never use raw byte offsets to access structure members. Define a proper interface header that both the crypto state creator and this function share. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/key_update.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-006",
    "title": "HTTP/3 Stream Lookup: Use-After-Free",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:5",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"free\" \"net/tquic/http3/http3_stream.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/http3/http3_stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `refcount_inc(&stream->refcount)` in `h3_stream_lookup()` and require all callers to call a corresponding `h3_stream_put()` when done. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/http3_stream.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-007",
    "title": "OCSP Stapling Response Accepted Without Any Verification",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on severity: Severity disagreement across reports: S0, S1."
    ],
    "key_evidence_present": "file:1, sym:6, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"pr_debug\" \"net/tquic/crypto/cert_verify.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Either implement OCSP response verification or remove the early return so that the \"no OCSP available\" path is taken, which at least logs warnings in hard-fail mode. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-008",
    "title": "Path Metrics Netlink: Unbounded Allocation from Attacker-Influenced Value",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, perf, security."
    ],
    "key_evidence_present": "file:1, sym:6",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"allocation\" \"net/tquic/diag/path_metrics.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Cap the allocation at a fixed reasonable maximum (e.g., `min(conn->num_paths, TQUIC_MAX_PATHS) * NLMSG_DEFAULT_SIZE`), and add the CAP_NET_ADMIN check from H1. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/diag/path_metrics.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-009",
    "title": "QPACK Dynamic Table Duplicate: Use-After-Free via Lock Drop",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:5",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"either\" \"net/tquic/http3/qpack_dynamic.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/http3/qpack_dynamic.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Either (a) increment the entry's refcount before dropping the lock, or (b) copy the name/value data into a local buffer before dropping the lock, or (c) use `GFP_ATOMIC` allocation under the lock (acceptable for small allocations). Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/qpack_dynamic.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-010",
    "title": "Self-Signed Certificate Comparison Uses Non-Constant-Time memcmp in One Path",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "file:1, sym:7, lines:4, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"comparison\" \"net/tquic/crypto/cert_verify.c\"",
      "sed -n '1628,1628p' net/tquic/crypto/cert_verify.c",
      "sed -n '1626,1628p' net/tquic/crypto/cert_verify.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `crypto_memneq()` consistently for all comparisons, or use `memcmp()` consistently for non-secret data. The key point is to be consistent and use constant-time comparison for any data whose equality/inequality should not leak timing information. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-011",
    "title": "Stack Buffer Overflow in HKDF-Expand-Label",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "file:1, sym:3, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"label\" \"net/tquic/crypto/handshake.c\"",
      "sed -n '238,238p' net/tquic/crypto/handshake.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add explicit bounds check: `if (label_len + context_len + 10 > sizeof(hkdf_label)) return -EINVAL;` before any writes to the buffer. Note: the zero_rtt.c implementation at line ~238 correctly has this check (`if (label_len > 245 || context_len > 245 || (10 + label_len + context_len) > sizeof(hkdf... Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-012",
    "title": "Stream Data Queued Before Validation Check",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Sources disagree on category: Category disagreement across reports: concurrency, correctness, memory, perf, security.",
      "Sources disagree on severity: Severity disagreement across reports: S0, S1, S2."
    ],
    "key_evidence_present": "file:4, sym:20, lines:8, snippet:12",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"dispatcher\" \"net/tquic/tquic_input.c\"",
      "sed -n '2303,2310p' net/tquic/tquic_input.c",
      "sed -n '944,948p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a flag to `tquic_rx_ctx` that records when a length-less STREAM frame is processed, and assert in the dispatcher that no further frames follow. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-014",
    "title": "`tquic_hs_process_certificate` -- integer underflow in `certs_len` tracking",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, lines:3, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_process_certificate\" \"net/tquic/crypto/handshake.c\"",
      "sed -n '1778,1778p' net/tquic/crypto/handshake.c",
      "sed -n '1780,1780p' net/tquic/crypto/handshake.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Check `certs_len >= 3` before `certs_len -= 3`, and\n`certs_len >= 2` before `certs_len -= 2`. Alternatively, track position using\npointer arithmetic against `end` only.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-015",
    "title": "`tquic_hs_process_new_session_ticket` -- nonce overflow into session ticket",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:3, lines:1, snippet:3",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_session_ticket\" \"net/tquic/crypto/handshake.c\"",
      "sed -n '76,77p' net/tquic/crypto/handshake.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-023",
    "title": "Busy-poll per-packet lock/unlock",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:8, lines:3, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"__skb_dequeue\" \"net/tquic/napi.c\"",
      "sed -n '460,465p' net/tquic/napi.c",
      "sed -n '317,317p' net/tquic/napi.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/napi.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use the same batch-splice pattern as `tquic_napi_poll()`: splice the queue to a local list under a single lock acquisition, then process without holding the lock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-024",
    "title": "Capsule Buffer Size Addition Overflow",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, lines:2, snippet:2",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '850,850p' net/quic/tquic/masque/capsule.c",
      "sed -n '894,894p' net/quic/tquic/masque/capsule.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add overflow check:\n```c\nif (cap->length > SIZE_MAX - CAPSULE_MAX_HEADER_SIZE)\n    return -EOVERFLOW;\n```\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-028",
    "title": "GSO Segment Accumulation Can Overflow SKB Tailroom",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_gso_ctx\" \"net/quic/tquic/tquic_output.c\"",
      "sed -n '1487,1487p' net/quic/tquic/tquic_output.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Validate cumulative bytes written against SKB tailroom\nbefore each `skb_put_data`/`skb_put` call, or check\n`skb_tailroom(gso->gso_skb) >= len` before the write.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-029",
    "title": "GSO SKB Allocation Multiplication Overflow",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1, snippet:3",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_output\" \"net/quic/tquic/tquic_output.c\"",
      "sed -n '1851,1851p' net/quic/tquic/tquic_output.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `check_mul_overflow` and `check_add_overflow`:\n```c\nsize_t alloc_size;\nif (check_mul_overflow((size_t)gso->gso_size, (size_t)max_segs, &alloc_size) ||\n    check_add_overflow(alloc_size, (size_t)MAX_HEADER, &alloc_size))\n    return -EOVERFLOW;\ngso->gso_skb = alloc_skb(alloc_size, GFP_ATOMIC);\n... Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-030",
    "title": "Handshake Packet Parsing with Unvalidated Offsets",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, sym:1, lines:5, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_parse_long_header\" \"net/tquic/core/connection.c\"",
      "sed -n '1932,1932p' net/tquic/core/connection.c",
      "sed -n '1934,1934p' net/tquic/core/connection.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Replace the ad-hoc parsing with calls to the existing safe header parser `tquic_parse_long_header()`, or add proper bounds checks before every `data[hdr_offset]` access.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-033",
    "title": "Install Secrets Accesses State Without Lock After Unlock",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:2, lines:5, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_ku_derive_keys\" \"net/tquic/crypto/key_update.c\"",
      "sed -n '878,878p' net/tquic/crypto/key_update.c",
      "sed -n '881,881p' net/tquic/crypto/key_update.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/crypto/key_update.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Copy the secrets into local variables under the lock, then derive from\nthe local copies (the pattern already used correctly in\n`tquic_initiate_key_update` at lines 392-405). The results should be committed\nback under the lock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-034",
    "title": "Integer overflow in `tquic_hs_build_ch_extensions` PSK identity length calculations",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, lines:2, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_build_ch_extensions\" \"net/tquic/crypto/handshake.c\"",
      "sed -n '1224,1234p' net/tquic/crypto/handshake.c",
      "sed -n '1217,1218p' net/tquic/crypto/handshake.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Check for u32 overflow in the accumulation loop. Validate that\nthe total extension length fits in a u16.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-037",
    "title": "Missing SKB Tailroom Check in Coalesced Packet Output",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory, other, security."
    ],
    "key_evidence_present": "file:1, sym:1, lines:2, snippet:4",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_output\" \"net/quic/tquic/tquic_output.c\"",
      "sed -n '1356,1356p' net/quic/tquic/tquic_output.c",
      "sed -n '981,981p' net/quic/tquic/tquic_output.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `BUILD_BUG_ON(TQUIC_MAX_HEADER_SIZE > 64)` or use\n`min(header_len, 64)` as a defense.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-038",
    "title": "Nested Lock Hierarchy Violation in Timer Code",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4, lines:5, snippet:5",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_timer_update_pto\" \"net/quic/tquic/tquic_timer.c\"",
      "sed -n '975,1029p' net/quic/tquic/tquic_timer.c",
      "sed -n '820,870p' net/quic/tquic/tquic_timer.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_timer.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Standardize ALL uses of `rs->lock` and `pns->lock` to use `spin_lock_bh` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-044",
    "title": "PADDING Frame Infinite Skip Without Bound on Encrypted Payload",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:3, lines:5, snippet:3",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_rx_ctx\" \"net/tquic/tquic_input.c\"",
      "sed -n '565,571p' net/tquic/tquic_input.c",
      "sed -n '1901,1901p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a bounds check before decoding the packet number:\n```c\nif (ctx.offset + pkt_num_len > len)\n    return -EINVAL;\n``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-045",
    "title": "Path Pointer Use After Lock Release",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:6, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"sockaddr_storage\" \"net/quic/tquic/tquic_input.c\"",
      "sed -n '242,243p' net/quic/tquic/tquic_input.c",
      "sed -n '268,285p' net/quic/tquic/tquic_input.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Take a reference on the path before releasing the lock: `tquic_path_get(found)` and require callers to call `tquic_path_put()`. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-046",
    "title": "Per-frame kzalloc + kmalloc in TX path",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory.",
      "Sources disagree on severity: Severity disagreement across reports: S0, S2."
    ],
    "key_evidence_present": "file:5, sym:18, lines:5, snippet:4",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"cache\" \"net/tquic/tquic_output.c\"",
      "sed -n '1806,1826p' net/tquic/tquic_output.c",
      "sed -n '1819,1825p' net/tquic/tquic_output.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "1. Use a slab cache (`kmem_cache`) for `tquic_pending_frame` structs (fixed size, high churn).\n2. Eliminate the intermediate data copy entirely -- write STREAM frame data directly into the skb payload buffer during `tquic_assemble_packet()`. The current architecture allocates frame->data, copies ... Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-047",
    "title": "Per-Packet crypto_aead_setkey on Shared AEAD Handle -- Race Condition",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:4, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_decrypt_packet\" \"net/tquic/crypto/tls.c\"",
      "sed -n '622,622p' net/tquic/crypto/tls.c",
      "sed -n '679,679p' net/tquic/crypto/tls.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/crypto/tls.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use separate AEAD transform handles for TX and RX, each with the key\nset once during key installation (not per-packet). The `quic_crypto.c` file\nalready does this correctly with `tx_aead` and `rx_aead` -- the `tls.c`\nimplementation should follow the same pattern.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-048",
    "title": "Priority PRIORITY_UPDATE Parsing Off-by-Two in Loop Bound",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, lines:2, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '633,633p' net/quic/tquic/core/priority.c",
      "sed -n '637,637p' net/quic/tquic/core/priority.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Implement proper Structured Field Dictionary parsing per RFC 8941. Validate the priority field value format strictly. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-050",
    "title": "quic_packet.c Stream Frame - Uncapped Stream Creation",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory, other.",
      "Sources disagree on severity: Severity disagreement across reports: S0, S2."
    ],
    "key_evidence_present": "file:1, sym:3, lines:3, snippet:3",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"quic_packet\" \"net/quic/tquic/core/quic_packet.c\"",
      "sed -n '1248,1248p' net/quic/tquic/core/quic_packet.c",
      "sed -n '158,158p' net/quic/tquic/core/quic_packet.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Replace `tquic_stream_create_internal` with\n`tquic_stream_open_incoming` which validates peer's MAX_STREAMS limit.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-051",
    "title": "Race Condition Between `tquic_destroy_sock()` and Poll/Sendmsg/Recvmsg",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, correctness, other.",
      "Sources disagree on severity: Severity disagreement across reports: S0, S1, S2."
    ],
    "key_evidence_present": "file:1, sym:9, lines:1, snippet:3",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"read_once\" \"net/tquic/tquic_socket.c\"",
      "sed -n '568,568p' net/tquic/tquic_socket.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "This is acceptable for poll() semantics (spurious wakeups are allowed), but document the intentional lockless access. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-053",
    "title": "Retry Token Validation -- Plaintext Buffer Overread",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, lines:1, snippet:3",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '1195,1195p' net/tquic/core/connection.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `if (ciphertext_len > sizeof(plaintext)) return -EINVAL;` before the memcpy. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-054",
    "title": "Server Accept CID Parsing Missing Bounds Checks -- Buffer Over-Read",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, sym:1, lines:2, snippet:3",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cid\" \"net/tquic/core/connection.c\"",
      "sed -n '2450,2450p' net/tquic/core/connection.c",
      "sed -n '2509,2509p' net/tquic/core/connection.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add bounds validation:\n```c\nif (offset >= len) goto err_free;\ndcid_len = data[offset++];\nif (dcid_len > TQUIC_MAX_CID_LEN) goto err_free;\nif (offset + dcid_len > len) goto err_free;\n```\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-055",
    "title": "Slab Cache Decryption Buffer May Be Too Small for Payload",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, memory, other.",
      "Sources disagree on severity: Severity disagreement across reports: S0, S1, S2, S3."
    ],
    "key_evidence_present": "file:1, sym:5, lines:10, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_process_stream_frame\" \"net/quic/tquic/tquic_input.c\"",
      "sed -n '944,944p' net/quic/tquic/tquic_input.c",
      "sed -n '909,909p' net/quic/tquic/tquic_input.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a comment explaining why `_bh` is not needed in the receive path. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-056",
    "title": "Sleep-in-Atomic Context",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:7, lines:2, snippet:4",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path\" \"net/tquic/tquic_migration.c\"",
      "sed -n '1395,1395p' net/tquic/tquic_migration.c",
      "sed -n '503,503p' net/tquic/tquic_migration.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-058",
    "title": "Stack buffer overflow in `tquic_hs_hkdf_expand_label` -- unbounded label/context write to 512-byte stack buffer",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:8, lines:1, snippet:5",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_handshake\" \"net/tquic/crypto/handshake.c\"",
      "sed -n '762,762p' net/tquic/crypto/handshake.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add bounds checking throughout `tquic_hs_build_ch_extensions`. Every\nwrite to `p` must verify `p + N <= buf + buf_len` before writing. Use a macro similar to\n`TP_CHECK_SPACE` from the transport params encoder.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-059",
    "title": "Stateless Reset Bypasses State Machine",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, correctness."
    ],
    "key_evidence_present": "file:1, sym:7, lines:1, snippet:3",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_conn_set_state\" \"net/tquic/tquic_input.c\"",
      "sed -n '1308,1308p' net/tquic/tquic_input.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use the state machine: call `tquic_conn_set_state(conn, TQUIC_CONN_CLOSED, TQUIC_REASON_PEER_CLOSE)` instead. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-060",
    "title": "Stream Data Delivery Uses u64 Length with u32 alloc_skb",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, memory."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream\" \"net/quic/tquic/core/quic_packet.c\"",
      "sed -n '1198,1198p' net/quic/tquic/core/quic_packet.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/core/quic_packet.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Cap `len` to a reasonable maximum (e.g., 16384 or the\nconnection's max_stream_data) before allocation.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-061",
    "title": "tquic_conn_server_accept() -- err_free leaks registered CIDs, work items, timers, crypto state",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:6, lines:5, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_crypto_init_versioned\" \"net/quic/tquic/core/connection.c\"",
      "sed -n '2518,2518p' net/quic/tquic/core/connection.c",
      "sed -n '2524,2524p' net/quic/tquic/core/connection.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Create incremental error labels:\n```\nerr_free_crypto:\n    tquic_crypto_free(conn->crypto_state);\n    conn->crypto_state = NULL;\nerr_free_cids:\n    /* remove added CIDs */\nerr_free_cs:\n    skb_queue_purge(&cs->zero_rtt_buffer);\n    kfree(cs);\n    conn->state_machine = NULL;\n```\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-065",
    "title": "Transcript Buffer Reallocation Doubling Overflow",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, lines:3, snippet:2",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '842,842p' net/quic/tquic/crypto/handshake.c",
      "sed -n '849,849p' net/quic/tquic/crypto/handshake.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `check_mul_overflow` or cap `new_alloc` more conservatively:\n```c\nu32 new_alloc;\nif (check_mul_overflow(new_len, 2U, &new_alloc))\n    new_alloc = TQUIC_MAX_TRANSCRIPT_SIZE;\nnew_alloc = max(new_alloc, 4096U);\n```\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-068",
    "title": "Use-After-Free in Path Lookup",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, perf."
    ],
    "key_evidence_present": "file:2, sym:8, lines:4, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"memcmp\" \"net/tquic/tquic_input.c\"",
      "sed -n '245,245p' net/tquic/tquic_input.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "- Compare by `ss_family`, then compare only the relevant address+port fields for that family. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-069",
    "title": "Version Negotiation Packet Overflow -- Unsanitized CID Lengths in tquic_send_version_negotiation",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on severity: Severity disagreement across reports: S0, S1, S3."
    ],
    "key_evidence_present": "file:1, sym:4, lines:4, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cid\" \"net/tquic/core/connection.c\"",
      "sed -n '961,961p' net/tquic/core/connection.c",
      "sed -n '965,965p' net/tquic/core/connection.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Calculate required size upfront and validate against `sizeof(packet)`.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-002",
    "title": "Buffer Overflow in ClientHello Extension Building",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "FP-risk: Snippet(s) contain only comments, not actual vulnerable code.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"enabled\" \"net/tquic/crypto/handshake.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a running `offset` tracker and validate `offset + needed_bytes <= buf_len` before every write operation. Return `-ENOSPC` if insufficient space. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-013",
    "title": "`tquic_close()` Does Not Hold `lock_sock()` During Connection Teardown",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:12, snippet:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_sock\" \"net/tquic/tquic_socket.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-016",
    "title": "`tquic_hs_process_server_hello` -- missing bounds check before compression byte read",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_process_server_hello\" \"net/tquic/crypto/handshake.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `if (p >= end) return -EINVAL;` before reading compression. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-017",
    "title": "`tquic_shutdown()` Missing `lock_sock()` -- Race on Connection State",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:9, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_shutdown\" \"net/tquic/tquic_socket.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-018",
    "title": "`tquic_varint_len()` Returns 0 for Invalid Values Without Error Propagation",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on severity: Severity disagreement across reports: S0, S1."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_varint_len\" \"net/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add explicit check: `if (len == 0) return -EOVERFLOW;` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_output.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-019",
    "title": "Adaptive Feedback Uses Path After list_for_each_entry Exit",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:7, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path\" \"net/tquic/multipath/tquic_scheduler.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/multipath/tquic_scheduler.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a separate flag variable to track whether the path was found, or use `list_for_each_entry_rcu()` with a found flag check. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/multipath/tquic_scheduler.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-020",
    "title": "ASN.1 Time Parsing Does Not Validate Character Ranges",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Validate each character is an ASCII digit before arithmetic. Validate month (1-12), day (1-31), hour (0-23), minute (0-59), second (0-59). Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-021",
    "title": "Authentication Bypass in QUIC-Aware Proxy",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_quic_proxy_register_conn\" \"net/tquic/masque/quic_proxy.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Set `require_auth = true` by default. Implement mandatory authentication (PSK, certificate, or token-based) in `tquic_quic_proxy_register_conn()` before processing any registration. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/quic_proxy.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-022",
    "title": "BLEST Inconsistent Locking -- 3 of 6 Callbacks Lack Lock",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:5, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"blest_get_path\" \"net/tquic/multipath/sched_blest.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/multipath/sched_blest.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `spin_lock_irqsave(&sd->lock, flags)` to `blest_path_removed()`, `blest_ack_received()`, and `blest_loss_detected()`.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/multipath/sched_blest.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-025",
    "title": "Complete SSRF in CONNECT-UDP -- No Address Validation",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:11, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"resolve_target\" \"net/tquic/masque/connect_udp.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add address validation after `in4_pton`/`in6_pton` succeeds. Block at minimum: `ipv4_is_loopback()`, `ipv4_is_multicast()`, `ipv4_is_lbcast()`, `ipv4_is_zeronet()`, `ipv4_is_private_10()`, `ipv4_is_private_172()`, `ipv4_is_private_192()`, link-local (169.254.0.0/16), and the IPv6 equivalents. Pro... Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/connect_udp.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-026",
    "title": "ECF Scheduler Declares Lock But Never Uses It",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"spin_lock_irqsave\" \"net/tquic/multipath/sched_ecf.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/multipath/sched_ecf.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Wrap all accesses to `sd->paths[]` and `sd->current_path_id` in `spin_lock_irqsave(&sd->lock, flags)` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/multipath/sched_ecf.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-027",
    "title": "ECN CE Count Processing Does Not Track Deltas",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cong_on_ecn\" \"net/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Store the previous ECN counts per path (in `struct tquic_ecn_tracking`) and only call `tquic_cong_on_ecn()` with the delta when `ecn_ce > path->ecn.ce_count`. Update the stored count after processing. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_input.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-031",
    "title": "Hard-Fail Revocation Mode Does Not Actually Fail",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "The function must return `-EKEYREVOKED` or a similar error when `TQUIC_REVOKE_HARD_FAIL` is set and revocation status cannot be determined.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-032",
    "title": "Hardcoded init_net Namespace Bypass in Socket Creation",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:2, sym:2, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_tunnel\" \"net/tquic/masque/connect_udp.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Store a reference to the correct network namespace (`struct net *`) at connection establishment time (via `sock_net(sk)` from the original QUIC socket) and use that namespace for all subsequent socket creation.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/connect_udp.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-035",
    "title": "Load Balancer Plaintext Mode Exposes Server ID",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"pr_warn_once\" \"net/tquic/lb/quic_lb.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/lb/quic_lb.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Log a `pr_warn_once()` when plaintext mode is selected. Consider requiring `CAP_NET_ADMIN` to create plaintext configs, or removing plaintext mode entirely. At minimum, add a prominent `IS THIS REALLY WHAT YOU WANT` style warning. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/lb/quic_lb.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-036",
    "title": "Missing RFC 1918 / Private Network Filtering in IPv4 SSRF Checks",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:5, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"ipv4_is_linklocal_169\" \"net/tquic/tquic_tunnel.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_tunnel.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add checks for `ipv4_is_private_10()`, `ipv4_is_private_172()`, `ipv4_is_private_192()`, `ipv4_is_linklocal_169()`, and other reserved ranges per RFC 5737 (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24). Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-039",
    "title": "Netfilter Hooks Registered Only in init_net",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_nf\" \"net/tquic/tquic_nf.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Register hooks via `pernet_operations` so each namespace gets its own hooks, or verify this is intentionally init_net-only and document the limitation.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_nf.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-040",
    "title": "No Address Validation in CONNECT-IP Packet Injection",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:5, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"netif_rx\" \"net/tquic/masque/connect_ip.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add source and destination address validation in `connect_ip_validate_ip_header()` or a new function called before `netif_rx()`. Block loopback, multicast, broadcast, link-local, RFC1918, and IPv4-mapped-IPv6 addresses. Set `skb->dev` to the tunnel's virtual network device so netfilter rules appl... Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/connect_ip.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-041",
    "title": "No Privilege Check for TQUIC Socket Creation",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_proto\" \"net/tquic/tquic_proto.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Consider requiring `CAP_NET_ADMIN` for bonding/multipath features, or at minimum for creating tunnels and MASQUE proxies.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_proto.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-042",
    "title": "No Privilege Checks for Security-Sensitive Socket Options",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:2, lines:5",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_socket\" \"net/tquic/tquic_socket.c\"",
      "sed -n '771,771p' net/tquic/tquic_socket.c",
      "sed -n '780,780p' net/tquic/tquic_socket.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN)` checks for privileged options.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-049",
    "title": "QPACK Decoder Stack Buffer Overflow via Large Headers",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"qpack_decoder\" \"net/quic/tquic/http3/qpack_decoder.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/http3/qpack_decoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Replace stack buffers with heap allocation (kmalloc with GFP_ATOMIC). The value_buf alone at 8192 bytes is dangerously large for kernel stack. Alternatively, reduce QPACK_MAX_HEADER_VALUE_LEN and allocate from a slab cache.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/qpack_decoder.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-052",
    "title": "Retry Token Address Validation Uses Non-Constant-Time Comparison",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"crypto_memneq\" \"net/tquic/core/connection.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `crypto_memneq()` for the hash comparison, or accept the current design as adequate given AEAD authentication. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-057",
    "title": "SSRF via IPv4-Mapped IPv6 Addresses Bypasses Address Filtering",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"ipv6_addr_v4mapped\" \"net/tquic/tquic_tunnel.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add checks for `ipv6_addr_v4mapped()`, `ipv6_addr_is_isatap()`, private RFC 1918 ranges within mapped addresses, and the unspecified address (`::` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-062",
    "title": "tquic_conn_server_accept() -- overrides actual error code with -EINVAL",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_conn_server_accept\" \"net/quic/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Change to `return ret;` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-063",
    "title": "tquic_send_connection_close() -- SKB leak and unencrypted packet on header failure",
    "category": "build",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: build, other."
    ],
    "key_evidence_present": "file:1, sym:4, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_send_connection_close\" \"net/quic/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `if (header_len < 0) { kfree_skb(skb); kfree(buf); return header_len; }` before the `skb_put_data` calls.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_output.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-064",
    "title": "tquic_stream_sendmsg Writes to Stream Without Connection Refcount on Stream",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_sendmsg\" \"net/quic/tquic/tquic_stream.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/tquic_stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Stream objects need reference counting. The stream_sock should hold a reference to the stream. Only when both the tree reference and the socket reference are dropped should the stream be freed.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_stream.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-066",
    "title": "Tunnel Uses init_net -- Namespace Escape",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use the network namespace from the QUIC connection's socket (`sock_net(conn->sk)`) instead of `&init_net`. Pass the correct `struct net *` through the client and tunnel structures. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-067",
    "title": "Unbounded Memory Allocation from Attacker-Controlled Capsule Length",
    "category": "perf",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, perf."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"capsule_alloc\" \"net/tquic/masque/capsule.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Validate `parser->header.length <= CAPSULE_MAX_PAYLOAD_SIZE` immediately after header decode succeeds, before calling `capsule_alloc()`. Additionally, add the same check inside `capsule_alloc()` as defense-in-depth.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/capsule.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-070",
    "title": "WebTransport Close Capsule Large Stack Allocation",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/http3/webtransport.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use heap allocation (kmalloc/kzalloc) for this buffer.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/webtransport.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-071",
    "title": "AF_XDP Socket and Device Lookup Use init_net",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:3, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_xsk_create\" \"net/tquic/af_xdp.c\"",
      "sed -n '367,367p' net/tquic/af_xdp.c",
      "sed -n '1096,1096p' net/tquic/af_xdp.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-072",
    "title": "conn->sk Accessed Without Lock After Stateless Reset",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_connection\" \"net/tquic/tquic_input.c\"",
      "sed -n '397,407p' net/tquic/tquic_input.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Hold a reference to the socket (`sock_hold(sk)`) under the lock, then call `sk_state_change`, then release the reference (`sock_put(sk)`). Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-073",
    "title": "Integer Overflow in bytes_acked Calculation",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cong_on_ack\" \"net/quic/tquic/tquic_input.c\"",
      "sed -n '737,737p' net/quic/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-074",
    "title": "Missing Lock in `tquic_sock_bind()` -- Race with `tquic_connect()`",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:11, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"copies\" \"net/tquic/tquic_socket.c\"",
      "sed -n '246,246p' net/tquic/tquic_socket.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-075",
    "title": "Missing Upper Bound on Coalesced Packet Count",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Sources disagree on severity: Severity disagreement across reports: S0, S2.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:7, lines:6, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_udp_recv\" \"net/quic/tquic/tquic_input.c\"",
      "sed -n '3079,3079p' net/quic/tquic/tquic_input.c",
      "sed -n '2080,2080p' net/quic/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-076",
    "title": "Packet Number Length Extracted Before Header Unprotection",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:3, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_remove_header_protection\" \"net/tquic/tquic_input.c\"",
      "sed -n '2529,2529p' net/tquic/tquic_input.c",
      "sed -n '2545,2545p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Move the `pkt_num_len` extraction to AFTER `tquic_remove_header_protection()`:\n```c\nret = tquic_remove_header_protection(conn, data, ctx.offset, ...);\nif (ret < 0) return ret;\npkt_num_len = (data[0] & 0x03) + 1;  // Now reads unprotected bits\nif (ctx.offset + pkt_num_len > len) return -EINVAL;\n``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-077",
    "title": "QUIC-over-TCP Client and Server Sockets Use init_net",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"quic_over_tcp\" \"net/tquic/transport/quic_over_tcp.c\"",
      "sed -n '1225,1225p' net/tquic/transport/quic_over_tcp.c",
      "sed -n '1446,1446p' net/tquic/transport/quic_over_tcp.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-078",
    "title": "Refcount Underflow in Netlink Path Creation",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:5, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_netlink\" \"net/tquic/tquic_netlink.c\"",
      "sed -n '427,427p' net/tquic/tquic_netlink.c",
      "sed -n '439,439p' net/tquic/tquic_netlink.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_netlink.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-079",
    "title": "Stale skb->len Read After ip_local_out",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"ip_local_out\" \"net/tquic/tquic_output.c\"",
      "sed -n '1730,1736p' net/tquic/tquic_output.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Save `skb->len` in a local variable before calling `ip_local_out()`:\n```c\nu32 pkt_len = skb->len;\nret = ip_local_out(&init_net, NULL, skb);\nif (ret >= 0) {\n    path->stats.tx_bytes += pkt_len;\n``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-080",
    "title": "State Machine Type Confusion via `conn->state_machine` Void Pointer",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on severity: Severity disagreement across reports: S0, S1."
    ],
    "key_evidence_present": "file:1, sym:11, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"could\" \"net/tquic/tquic_migration.c\"",
      "sed -n '1098,1098p' net/tquic/tquic_migration.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-081",
    "title": "Stream Lookup Returns Pointer Without Refcount -- Use-After-Free",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:4, sym:4, lines:4, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream\" \"net/quic/tquic/core/priority.c\"",
      "sed -n '497,524p' net/quic/tquic/core/priority.c",
      "sed -n '1461,1489p' net/quic/tquic/core/priority.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/core/priority.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-082",
    "title": "TOCTOU Race in Failover Hysteresis",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, lines:4, snippet:3",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"atomic_set\" \"net/quic/tquic/bond/tquic_failover.c\"",
      "sed -n '198,229p' net/quic/tquic/bond/tquic_failover.c",
      "sed -n '207,207p' net/quic/tquic/bond/tquic_failover.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/bond/tquic_failover.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Either protect these operations with a per-path spinlock, or use `atomic_inc_return()` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-083",
    "title": "TQUIC_NEW_STREAM Missing Reserved Field Zeroing Check",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_conn_get\" \"net/quic/tquic/tquic_stream.c\"",
      "sed -n '680,680p' net/quic/tquic/tquic_stream.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/tquic_stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-084",
    "title": "UAF-P1-01: - SmartNIC tquic_nic_find() returns pointer without reference",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:7, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_offload_key_install\" \"net/tquic/offload/smartnic.c\"",
      "sed -n '264,264p' net/tquic/offload/smartnic.c",
      "sed -n '300,300p' net/tquic/offload/smartnic.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/offload/smartnic.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-085",
    "title": "Use-After-Free in Connect",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, lines:5, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"sock\" \"net/tquic/tquic_socket.c\"",
      "sed -n '230,230p' net/tquic/tquic_socket.c",
      "sed -n '285,285p' net/tquic/tquic_socket.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-086",
    "title": "Wrong Network Namespace in ip_local_out",
    "category": "security",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:2, snippet:2",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "sed -n '1730,1730p' net/tquic/tquic_output.c",
      "sed -n '1681,1681p' net/tquic/tquic_output.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `sock_net(conn->sk)` instead of `&init_net`. The correct network namespace was already computed at line 1681 in the `rt` lookup:\n```c\nret = ip_local_out(net, conn->sk, skb);\n``` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-043",
    "title": "No security_socket_* Hook Invocations",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "high",
    "priority_score": 10.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "sym:10",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_sock_bind\" net/tquic/",
      "rg -rn \"spin_lock\\|mutex_lock\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Invoke appropriate `security_socket_*` hooks in TQUIC socket operations. At minimum:\n- `security_socket_create()` in `tquic_sock_create()`\n- `security_socket_connect()` in `tquic_connect_socket()`\n- `security_socket_bind()` in `tquic_sock_bind()` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-136",
    "title": "`ext->final_size = -1` Uses Signed Overflow",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Define `#define TQUIC_STREAM_SIZE_UNKNOWN U64_MAX` and use it consistently. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/stream.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-137",
    "title": "Constant-Time CID Validation Has Branching on Lengths",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: build, memory, other, security."
    ],
    "key_evidence_present": "file:1, sym:4, lines:1, snippet:4",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_ct_memcmp\" \"net/tquic/security/quic_exfil.c\"",
      "sed -n '394,394p' net/tquic/security/quic_exfil.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/security/quic_exfil.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-138",
    "title": "Custom ASN.1 Parser - High Attack Surface",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:4",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"decoder\" \"net/tquic/crypto/cert_verify.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Consider using the kernel's built-in ASN.1 decoder (`lib/asn1_decoder.c`) and the x509 certificate parser (`crypto/asymmetric_keys/x509_cert_parser.c`) which have been battle-tested. If the custom parser must be retained, add fuzzing tests targeting all parsing entry points. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-139",
    "title": "Function Pointer Stored in skb->cb Without Validation",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Sources disagree on category: Category disagreement across reports: correctness, other, security."
    ],
    "key_evidence_present": "file:1, sym:5, lines:2, snippet:3",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"corrupted\" \"net/tquic/security/quic_exfil.c\"",
      "sed -n '71,71p' net/tquic/security/quic_exfil.c",
      "sed -n '533,533p' net/tquic/security/quic_exfil.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-140",
    "title": "HTTP/3 Request: TOCTOU Between State Check and Send",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"h3_request_send_headers\" \"net/tquic/http3/http3_request.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/http3/http3_request.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Either hold the lock during the entire send operation, or re-validate state after acquiring any needed resources. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/http3_request.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-141",
    "title": "HTTP/3 Settings Frame Length Truncation",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other, security."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"h3_connection_send_settings\" \"net/tquic/http3/http3_stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use proper QUIC variable-length integer encoding for the frame length, or validate that `settings_len <= 255` before the cast and return an error if exceeded. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/http3_stream.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-142",
    "title": "Load Balancer Encryption Key Not Zeroized on Destroy",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "file:1, sym:5, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"crypto_free_sync_skcipher\" \"net/tquic/lb/quic_lb.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/lb/quic_lb.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-143",
    "title": "No CAP_NET_ADMIN Check for Tunnel Creation",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:8, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"capable\" \"net/tquic/tquic_tunnel.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-144",
    "title": "Path Metrics Netlink: Missing CAP_NET_ADMIN Permission Check",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:5",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"export\" \"net/tquic/diag/path_metrics.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `.policy` with `GENL_ADMIN_PERM` flag or explicit `CAP_NET_ADMIN` check in each handler. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/diag/path_metrics.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-145",
    "title": "Per-Call crypto_aead_setkey in Encrypt/Decrypt Hot Path",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:4",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"changes\" \"net/tquic/crypto/tls.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Set the key once when it changes (at key installation time), not on every packet. Store the AEAD transform with the key pre-set in `tquic_key_generation`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/tls.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-146",
    "title": "Per-Call crypto_alloc_aead in 0-RTT Encrypt/Decrypt",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: perf, security."
    ],
    "key_evidence_present": "file:1, sym:6",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"crypto_alloc_aead\" \"net/tquic/crypto/zero_rtt.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Pre-allocate the AEAD transform during `tquic_zero_rtt_init()` or `tquic_zero_rtt_attempt()` and reuse it for the lifetime of the 0-RTT state. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-147",
    "title": "QPACK Decoder: Unbounded Blocked Stream Memory Exhaustion",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:5",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"blocks\" \"net/tquic/http3/qpack_decoder.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/http3/qpack_decoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Track total blocked stream memory and enforce a per-connection limit (e.g., 1MB total blocked stream data). Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/qpack_decoder.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-148",
    "title": "QPACK Encoder: Insert Count Increment Overflow",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory, other."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"qpack_encoder\" \"net/tquic/http3/qpack_encoder.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/http3/qpack_encoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Validate that `known_received_count + value <= insert_count` (the total entries ever inserted) and that the addition does not overflow. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/qpack_encoder.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-149",
    "title": "Race Condition in Key Update Secret Installation",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:4",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"derivation\" \"net/tquic/crypto/key_update.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/crypto/key_update.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a state flag (e.g., `keys_installing`) that prevents concurrent use during the derivation window. Set the flag under the first lock acquisition, derive keys, then clear it under the second lock acquisition. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/key_update.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-150",
    "title": "RSA-PSS Hash Algorithm Hardcoded to SHA-256",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"verification\" \"net/tquic/crypto/cert_verify.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Parse the RSA-PSS AlgorithmIdentifier parameters to extract the actual hash algorithm. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-151",
    "title": "Secrets not zeroized on error paths in key derivation functions",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Sources disagree on category: Category disagreement across reports: correctness, other, security.",
      "Sources disagree on severity: Severity disagreement across reports: S1, S2."
    ],
    "key_evidence_present": "file:1, sym:4, lines:5, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"consumed\" \"net/tquic/crypto/handshake.c\"",
      "sed -n '995,1045p' net/tquic/crypto/handshake.c",
      "sed -n '1050,1071p' net/tquic/crypto/handshake.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Zeroize these secrets using `memzero_explicit()` as soon as they have been consumed (after key derivation and ticket issuance). Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-152",
    "title": "Stream State Machine Allows Unexpected Transitions from OPEN",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:6, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"data_sent\" \"net/tquic/core/stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add TQUIC_STREAM_SEND and TQUIC_STREAM_RECV as valid transitions from OPEN. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/stream.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-153",
    "title": "Timing Normalization Can Block in Packet Processing Path",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:9, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"context\" \"net/tquic/security/quic_exfil.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/security/quic_exfil.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-154",
    "title": "Unbounded Connection Creation via Netlink",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:5, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"connections\" \"net/tquic/tquic_netlink.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-155",
    "title": "WebTransport Context Destroy: Lock Drop During Iteration",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"context_destroy\" \"net/tquic/http3/webtransport.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/http3/webtransport.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a safe iteration pattern: move items to a local list under the lock, release the lock, then process the local list. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/webtransport.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-156",
    "title": "WebTransport: Unbounded Capsule Buffer Growth",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"capsule\" \"net/tquic/http3/webtransport.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Enforce a maximum capsule buffer size (e.g., 64KB or configurable via socket option) and reject connections that exceed it with `H3_EXCESSIVE_LOAD`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/webtransport.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-157",
    "title": "`quic_offload.c` Version Field Shift Without Cast",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:2, sym:1, lines:2, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"quic_offload\" \"net/quic/tquic/quic_offload.c\"",
      "sed -n '429,429p' net/quic/tquic/quic_offload.c",
      "sed -n '474,475p' net/quic/tquic/quic_offload.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Cast to `u32` before shift:\n```c\nversion = ((u32)data[1] << 24) | ((u32)data[2] << 16) |\n          ((u32)data[3] << 8) | data[4];\n``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-160",
    "title": "`tquic_hs_build_ch_extensions` -- ALPN extension length written as 2-byte but can overflow u16",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_set_alpn\" \"net/tquic/crypto/handshake.c\"",
      "sed -n '2964,2964p' net/tquic/crypto/handshake.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Validate ALPN total length fits in u16 in `tquic_hs_set_alpn()`.\nAdd a reasonable cap on `alpn_count`.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-163",
    "title": "`tquic_hs_hkdf_expand_label` -- `context_len` truncated to u8",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_hkdf_expand_label\" \"net/tquic/crypto/handshake.c\"",
      "sed -n '762,762p' net/tquic/crypto/handshake.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "```c\nif (context_len > 255)\n    return -EINVAL;\n```\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-165",
    "title": "`tquic_hs_process_new_session_ticket` -- memory leak of old ticket data on re-entry",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: other, security.",
      "Sources disagree on severity: Severity disagreement across reports: S1, S2."
    ],
    "key_evidence_present": "file:1, sym:3, lines:2, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_process_new_session_ticket\" \"net/tquic/crypto/handshake.c\"",
      "sed -n '2609,2609p' net/tquic/crypto/handshake.c",
      "sed -n '2610,2610p' net/tquic/crypto/handshake.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Track whether `hs->session_ticket` is owned or borrowed. Only free\nowned tickets. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-166",
    "title": "`tquic_hs_process_server_hello` -- session ID comparison not fully bounds-safe",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: other, security.",
      "Sources disagree on severity: Severity disagreement across reports: S1, S2."
    ],
    "key_evidence_present": "file:1, sym:1, lines:4, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_process_server_hello\" \"net/tquic/crypto/handshake.c\"",
      "sed -n '1423,1423p' net/tquic/crypto/handshake.c",
      "sed -n '1426,1426p' net/tquic/crypto/handshake.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `if (p >= end) return -EINVAL;` before `session_id_len = *p++;`.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-169",
    "title": "accept() Uses spin_lock_bh on sk_lock.slock While lock_sock() Is Held",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on severity: Severity disagreement across reports: S1, S2."
    ],
    "key_evidence_present": "file:2, sym:5, lines:4, snippet:3",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"lock_sock\" \"net/quic/tquic/tquic_socket.c\"",
      "sed -n '95,95p' net/quic/tquic/tquic_socket.c",
      "sed -n '2841,2854p' net/quic/tquic/tquic_socket.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Remove the inner `spin_lock_bh(&sk->sk_lock.slock)` calls in `tquic_accept()`. The `lock_sock()` already provides sufficient serialization. If the accept queue needs to be accessed from softirq context, use a dedicated spinlock instead of the socket's backing slock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-173",
    "title": "Bloom Filter Has High False Positive Rate at Scale",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:1, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '913,916p' net/tquic/crypto/zero_rtt.h",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Increase `TQUIC_REPLAY_BLOOM_BITS` to at least `(1 << 20)` (1M bits = 128KB) for production use, or make it configurable via sysctl.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-174",
    "title": "Bonding State Machine Drop-Relock Without Re-validation",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_bonding_destroy\" \"net/quic/tquic/bond/tquic_bonding.c\"",
      "sed -n '174,174p' net/quic/tquic/bond/tquic_bonding.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/bond/tquic_bonding.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a \"destroying\" flag to `bc` checked after relock, or use refcounting on `bc`. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-177",
    "title": "conn->lock held during path selection on every TX packet",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:8, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"read_once\" \"net/tquic/tquic_output.c\"",
      "sed -n '1121,1132p' net/tquic/tquic_output.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "For the single-path fast path, use `READ_ONCE(conn->active_path)` without the lock. Only take the lock when a scheduler is configured. Consider RCU protection for the path list. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-178",
    "title": "conn->lock released and reacquired during output flush stream iteration",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:7, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"operations\" \"net/tquic/tquic_output.c\"",
      "sed -n '2058,2072p' net/tquic/tquic_output.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Merge the two critical sections into one: check flow control credit and begin stream iteration under the same `conn->lock` hold. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-179",
    "title": "conn->paths_lock in RX path for every packet",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, memory."
    ],
    "key_evidence_present": "file:2, sym:7, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"first\" \"net/tquic/tquic_input.c\"",
      "sed -n '251,258p' net/tquic/tquic_input.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a hash table (rhashtable) for path-by-address lookup. For single-path connections, cache the last-used path and check it first (fast-path optimization). Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-180",
    "title": "CONNECTION_CLOSE uses kmalloc for small buffer",
    "category": "perf",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, perf."
    ],
    "key_evidence_present": "file:2, sym:3, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"does\" \"net/tquic/tquic_output.c\"",
      "sed -n '1950,1951p' net/tquic/tquic_output.c",
      "sed -n '1877,1877p' net/tquic/tquic_output.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a stack buffer like `tquic_send_ack()` does (line 1877: `u8 buf_stack[128]`). A 256-byte stack allocation is safe in kernel context. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-183",
    "title": "ECN Counter Values Passed Directly to TQUIC_ADD_STATS Without Overflow Check",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, lines:3, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_input\" \"net/tquic/tquic_input.c\"",
      "sed -n '702,707p' net/tquic/tquic_input.c",
      "sed -n '764,764p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Validate that ECN counts are monotonically increasing from previous values. Store previous ECN counts per-path and only react to the *increase*, not the absolute value (as RFC 9002 Section 7.1 requires). The comment at line 759-763 acknowledges this is missing. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-184",
    "title": "EKU Derives Keys Using KU hash_tfm Without KU Lock",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:1, lines:3, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"eku_hkdf_extract\" \"net/tquic/crypto/extended_key_update.c\"",
      "sed -n '821,821p' net/tquic/crypto/extended_key_update.c",
      "sed -n '829,829p' net/tquic/crypto/extended_key_update.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/crypto/extended_key_update.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Either (a) hold the KU lock around `hash_tfm` access, or (b) copy\n`hash_tfm` under the KU lock and use the copy (though crypto transforms are\nnot reference-counted, so this requires ensuring the transform outlives usage).\nFor the PSK, copy it under the EKU lock before releasing.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-190",
    "title": "getsockopt PSK Identity - Missing Length Validation",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory.",
      "Sources disagree on severity: Severity disagreement across reports: S1, S2."
    ],
    "key_evidence_present": "file:1, sym:1, lines:2, snippet:3",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_socket\" \"net/quic/tquic/tquic_socket.c\"",
      "sed -n '1317,1317p' net/quic/tquic/tquic_socket.c",
      "sed -n '1334,1334p' net/quic/tquic/tquic_socket.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `if (identity_len > len) return -EINVAL;` before\nthe copy_to_user call.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-191",
    "title": "GRO Coalesce Uses Hardcoded 8-byte CID Comparison",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_input\" \"net/tquic/tquic_input.c\"",
      "sed -n '2249,2253p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "The GRO coalesce function needs to know the actual CID length. Pass it via skb metadata or look it up from connection state. Also add length checks:\n```c\nif (skb1->len < 1 + cid_len || skb2->len < 1 + cid_len)\n    return false;\n``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-192",
    "title": "GRO Flush Unlock-Relock Loop Without Re-validation",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:2, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_gro_receive_internal\" \"net/quic/tquic/tquic_input.c\"",
      "sed -n '2306,2306p' net/quic/tquic/tquic_input.c",
      "sed -n '2309,2309p' net/quic/tquic/tquic_input.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "After the loop, set `gro->held_count = skb_queue_len(&gro->hold_queue)` instead of hard-coding 0. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-195",
    "title": "HIGH: GRO stats use global atomic64 on every packet",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: api, concurrency, correctness, perf.",
      "Sources disagree on severity: Severity disagreement across reports: S1, S2, S3."
    ],
    "key_evidence_present": "file:4, sym:8, lines:3, snippet:3",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"atomic64_inc\" \"net/tquic/tquic_offload.c\"",
      "sed -n '235,253p' net/tquic/tquic_offload.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use per-CPU counters for GRO statistics, aggregate on read. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-200",
    "title": "Infinite retry loop on EMSGSIZE/EEXIST",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, correctness."
    ],
    "key_evidence_present": "file:2, sym:4, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_skb_zerocopy_iter_stream\" \"net/tquic/tquic_zerocopy.c\"",
      "sed -n '315,318p' net/tquic/tquic_zerocopy.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_zerocopy.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a retry counter (e.g., max 3 retries) and return an error after exhausting retries. Alternatively, adjust the chunk size downward on EMSGSIZE before retrying. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-202",
    "title": "io_uring buffer ring spinlock per get/put operation",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on severity: Severity disagreement across reports: S1, S2."
    ],
    "key_evidence_present": "file:3, sym:8, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"acquisitions\" \"net/tquic/io_uring.c\"",
      "sed -n '804,838p' net/tquic/io_uring.c",
      "sed -n '799,838p' net/tquic/io_uring.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/io_uring.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "If get/put are guaranteed to be called from different contexts (producer vs consumer), replace the spinlock with a lockless SPSC ring using `smp_store_release`/`smp_load_acquire` on head/tail. If multi-producer or multi-consumer, consider per-CPU rings or batch get/put APIs. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-205",
    "title": "memset Instead of memzero_explicit for Old Key Material",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:3, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"memzero_explicit\" \"net/tquic/crypto/key_update.c\"",
      "sed -n '435,435p' net/tquic/crypto/key_update.c",
      "sed -n '627,628p' net/tquic/crypto/key_update.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Replace all `memset(..., 0, ...)` clearing key material with\n`memzero_explicit()`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-206",
    "title": "Missing kfree_sensitive for key material in crypto/handshake.c extensions buffer",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"kfree_sensitive\" \"net/quic/tquic/crypto/handshake.c\"",
      "sed -n '1280,1280p' net/quic/tquic/crypto/handshake.c",
      "sed -n '3260,3260p' net/quic/tquic/crypto/handshake.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-211",
    "title": "payload_len Subtraction Underflow in Long Header Parsing",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:2, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '590,601p' net/tquic/core/packet.c",
      "sed -n '619,619p' net/tquic/core/packet.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `if (hdr->payload_len < hdr->pn_len) return -EPROTO;` before the subtraction. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-213",
    "title": "Procfs trusted_cas Writable Without Privilege Check",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on severity: Severity disagreement across reports: S1, S2."
    ],
    "key_evidence_present": "file:1, sym:1, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"current_cred\" \"net/tquic/crypto/cert_verify.c\"",
      "sed -n '2772,2808p' net/tquic/crypto/cert_verify.c",
      "sed -n '2615,2615p' net/tquic/crypto/cert_verify.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `capable(CAP_NET_ADMIN)` check in the write handler. Consider using 0600 permissions. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-217",
    "title": "Redundant triple-counting of statistics",
    "category": "api",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: api, concurrency.",
      "Sources disagree on severity: Severity disagreement across reports: S1, S2."
    ],
    "key_evidence_present": "file:4, sym:11, lines:7, snippet:4",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"atomic64_add\" \"net/tquic/napi.c\"",
      "sed -n '307,308p' net/tquic/napi.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Remove the `tquic_napi_global_stats` atomic counters entirely. Use `tquic_napi_aggregate_pcpu_stats()` (already implemented at line 75) when global totals are needed for /proc display. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-218",
    "title": "reed_solomon.c -- four-allocation group without individual NULL checks",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, lines:1, snippet:3",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '590,590p' net/quic/tquic/fec/reed_solomon.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-220",
    "title": "Retry Packet Stack Buffer Overflow",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, lines:2, snippet:2",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '1379,1379p' net/tquic/core/connection.c",
      "sed -n '1401,1401p' net/tquic/core/connection.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Allocate `packet`, `token`, and `pseudo_packet` on the heap using `kmalloc`.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-225",
    "title": "Security Hardening Pre-HS Atomic TOCTOU",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"atomic_inc_return\" \"net/quic/tquic/security_hardening.c\"",
      "sed -n '280,280p' net/quic/tquic/security_hardening.c",
      "sed -n '289,289p' net/quic/tquic/security_hardening.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/security_hardening.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `atomic_inc_return()` and check the result instead of separate read + increment. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-226",
    "title": "Session Ticket Decode Missing Bounds Check on PSK Copy",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "file:1, lines:3, snippet:2",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '1160,1160p' net/tquic/crypto/zero_rtt.c",
      "sed -n '1143,1143p' net/tquic/crypto/zero_rtt.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/zero_rtt.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-231",
    "title": "tquic_process_stream_frame Allocates skb Based on Attacker-Controlled length",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:4, lines:4, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"alloc_skb\" \"net/tquic/tquic_input.c\"",
      "sed -n '944,944p' net/tquic/tquic_input.c",
      "sed -n '909,909p' net/tquic/tquic_input.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Move the `sk_rmem_alloc` check BEFORE the `alloc_skb()` call to avoid the allocation entirely when the buffer is full. Also consider a global receive buffer cap. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-233",
    "title": "tquic_stream_recv_data Potential Integer Overflow in Flow Control Check",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_recv_data\" \"net/quic/tquic/core/stream.c\"",
      "sed -n '697,699p' net/quic/tquic/core/stream.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add overflow check before the addition: `if (skb->len > U64_MAX - offset) return -EOVERFLOW;`\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-236",
    "title": "tquic_stream_socket_create Double-Free on fd Failure",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:4, lines:4, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_socket_create\" \"net/quic/tquic/tquic_stream.c\"",
      "sed -n '213,231p' net/quic/tquic/tquic_stream.c",
      "sed -n '219,219p' net/quic/tquic/tquic_stream.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/tquic_stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Set `sk_user_data` to NULL before calling `tquic_sock_map_fd`, or set it only after successful fd allocation. Fix the `sock_alloc_file` failure path to release the socket.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-237",
    "title": "tquic_zerocopy_sendmsg -- uarg leak on partial send",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_zerocopy_sendmsg\" \"net/quic/tquic/tquic_zerocopy.c\"",
      "sed -n '360,360p' net/quic/tquic/tquic_zerocopy.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "On the error path, dequeue and free all SKBs added during\nthis call, or commit the partial send as successful (return `copied` instead\nof error if `copied > 0`).\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-240",
    "title": "Zero-RTT Session Ticket Deserialization Trusts Length Fields",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:1, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '1140,1160p' net/quic/tquic/crypto/zero_rtt.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/crypto/zero_rtt.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-089",
    "title": "ACK Range Failover Can Iterate Over Unbounded Packet Number Range",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_failover_ctx\" \"net/tquic/bond/tquic_failover.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/tquic_failover.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-092",
    "title": "CID demux/lookup appears non-functional: the RX path uses one table, while connection creation populates different tables",
    "category": "security",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "A"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source A); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:4, sym:6, lines:4",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cid_hash_add\" \"net/tquic/core/connection.c\"",
      "sed -n '2696,2696p' net/tquic/core/connection.c",
      "sed -n '463,463p' net/tquic/core/quic_connection.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "- Pick exactly one authoritative CID demux table for RX and ensure connection creation inserts the SCID/DCIDs into it.\n- Delete or hard-disable the unused tables (or clearly fence them behind config/ifdef) to reduce attack surface and confusion. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-095",
    "title": "Connection State Transition Not Fully Atomic",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:5, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_conn_set_state\" \"net/tquic/core/connection.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-096",
    "title": "Connection State Transition Not Fully Atomic",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_conn_set_state\" \"net/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "All state transitions MUST go through `tquic_conn_set_state()`, and the function should assert/acquire `conn->lock` internally. Fix `tquic_handle_stateless_reset()` to use the state machine. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_input.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-097",
    "title": "Excessive Stack Usage in RS Recovery",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"attempt_rs_recovery\" \"net/tquic/fec/fec_decoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/fec/fec_decoder.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-098",
    "title": "Global connection hashtable (`tquic_conn_table`) is initialized and removed-from, but never inserted-into",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "A"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source A); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4, lines:2",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"hashtable\" \"net/tquic/tquic_main.c\"",
      "sed -n '145,145p' net/tquic/tquic_main.c",
      "sed -n '796,796p' net/tquic/tquic_main.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "- Either wire up insertion consistently at connection establishment, or delete `tquic_conn_table` and all iteration users in favor of the per-netns list already used by `tquic_conn_lookup_by_token()`. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-099",
    "title": "Header protection outputs are ignored; packet-number length + key phase are derived from protected header",
    "category": "security",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "A"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source A); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:3",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hp_unprotect\" \"net/tquic/tquic_input.c\"",
      "sed -n '2528,2528p' net/tquic/tquic_input.c",
      "sed -n '2539,2539p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "- Treat `tquic_hp_unprotect()` as authoritative for `pn_len` and (short header) `key_phase`.\n- After HP removal, recompute any fields derived from the masked bits (pn length, key phase, reserved bits validation).\n- In short header parsing: do not interpret spin/key-phase/pn-len prior to unprotect. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-100",
    "title": "Huffman Decoder O(n*256) Algorithmic Complexity DoS",
    "category": "security",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/qpack.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-101",
    "title": "Integer Overflow in Coupled CC Increase Calculation",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"coupled_cc_increase\" \"net/tquic/bond/cong_coupled.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/cong_coupled.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-102",
    "title": "IPv4/IPv6 Address Discovery Enumerates Host Interfaces",
    "category": "security",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:2, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_ipv6.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-104",
    "title": "List Iterator Invalidation in BPM Netdev Notifier",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:5, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"rcu_read_unlock\" \"net/quic/tquic/bond/tquic_bpm.c\"",
      "sed -n '1876,1898p' net/quic/tquic/bond/tquic_bpm.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/bond/tquic_bpm.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `list_for_each_entry_safe()` is NOT sufficient here since the iteration continues after relock. Instead, collect paths to process into a separate list under the lock, then process them after releasing the lock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-106",
    "title": "MASQUE CONNECT-UDP Proxy Creates Sockets in init_net",
    "category": "security",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/connect_udp.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-110",
    "title": "Packet number reconstruction always uses `largest_pn = 0`",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "A"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source A); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_decode_pkt_num\" \"net/tquic/tquic_input.c\"",
      "sed -n '2572,2572p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "- Track `largest_pn` per PN space (Initial/Handshake/Application) and pass it into `tquic_decode_pkt_num()`. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-112",
    "title": "QPACK Dynamic Table Duplicate TOCTOU Race",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"qpack_dynamic\" \"net/quic/tquic/http3/qpack_dynamic.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/http3/qpack_dynamic.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/qpack_dynamic.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-113",
    "title": "QUIC-Exfil mitigation code uses `skb->cb` as a function-pointer slot and gates on `skb->cb[0]`",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "A"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, line range.",
      "Single-source finding (source A); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:2",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "sed -n '1090,1090p' net/tquic/security/quic_exfil.c",
      "sed -n '270,270p' net/tquic/security/quic_exfil.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "- Never store function pointers in `skb->cb`.\n- Use a wrapper object (`struct { struct sk_buff *skb; void (*send_fn)(...); }`) in a dedicated queue, or at least define a strict `struct` overlay for `skb->cb` and always set a sentinel + zero the rest. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-115",
    "title": "Rate Calculation Integer Overflow",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:2, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/rate_limit.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-118",
    "title": "Redundant Scheduler Deduplication Uses Only 8-bit Sequence Hash -- Trivial Collision",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on severity: Severity disagreement across reports: S0, S3."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_connection\" \"net/tquic/multipath/tquic_scheduler.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/multipath/tquic_scheduler.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-119",
    "title": "Reference counting/RCU lifetime is not actually enforced; direct `tquic_conn_destroy()` calls can free live connections",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "A"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source A); no independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:4, sym:10, lines:4",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"assertions\" \"Users/justinadams/Downloads/tquic-kernel/include/net/tquic.h\"",
      "sed -n '1965,1965p' Users/justinadams/Downloads/tquic-kernel/include/net/tquic.h",
      "sed -n '1981,1981p' Users/justinadams/Downloads/tquic-kernel/include/net/tquic.h",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"Users/justinadams/Downloads/tquic-kernel/include/net/tquic.h\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "- Make `tquic_conn_destroy()` private/internal (not a general-purpose public API). Enforce that all external callers use `tquic_conn_put()` and that the destructor only runs on the refcount-to-zero edge.\n- Add debug assertions (at least under `CONFIG_DEBUG_KERNEL`) to catch direct destruction wit... Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-120",
    "title": "rhashtable/RCU lifetime issues (use-after-free risk) in CID tables",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "A"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source A); no independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:6, lines:2",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"call_rcu\" \"net/tquic/core/quic_connection.c\"",
      "sed -n '355,355p' net/tquic/tquic_cid.c",
      "sed -n '537,537p' net/tquic/tquic_cid.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/core/quic_connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "- Decide on a correct concurrency model:\n  - Option A: Use rhashtable in the intended RCU mode.\n    - Lookups under `rcu_read_lock()`.\n    - Deletions free via `kfree_rcu()` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-122",
    "title": "Same Overflow in OLIA Increase Path",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"olia_cc_increase\" \"net/tquic/bond/cong_coupled.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/cong_coupled.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-125",
    "title": "Tunnel Socket Creation Uses init_net",
    "category": "security",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"should\" \"net/tquic/tquic_tunnel.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-127",
    "title": "UAF-P2-01: - SKB accessed after udp_tunnel_xmit_skb",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"udp_tunnel_xmit_skb\" \"net/tquic/tquic_udp.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_udp.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_udp.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-128",
    "title": "UAF-P3-01: - retransmit_work_fn accesses ts->conn without connection reference",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:8, lines:2",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"cancel_work_sync\" \"net/tquic/tquic_timer.c\"",
      "sed -n '848,848p' net/tquic/tquic_timer.c",
      "sed -n '1422,1422p' net/tquic/tquic_timer.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_timer.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-129",
    "title": "UAF-P3-02: - path_work_fn accesses ts->conn without reference",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_timer_state\" \"net/tquic/tquic_timer.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_timer.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_timer.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-131",
    "title": "Use-After-Free in `tquic_migrate_explicit()` -- Path Used Without Reference",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:5, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path_find_by_addr\" \"net/tquic/tquic_migration.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-132",
    "title": "Use-After-Free in Algorithm Name Return",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cong_get_default_name\" \"net/tquic/cong/tquic_cong.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/cong/tquic_cong.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/cong/tquic_cong.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-134",
    "title": "Widespread allocator mismatches (kmem_cache vs kzalloc/kfree) for core objects (conn/path/stream)",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "A"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source A); no independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:6, sym:18, lines:9",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"evidence\" \"net/tquic/Makefile\"",
      "sed -n '18,18p' net/tquic/Makefile",
      "sed -n '428,428p' net/tquic/core/quic_connection.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/Makefile\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "- Pick exactly one allocator strategy per object type (`tquic_connection`, `tquic_path`, `tquic_stream`) and enforce it via dedicated wrappers:\n  - `tquic_conn_alloc()/tquic_conn_free()`\n  - `tquic_path_alloc()/tquic_path_free()`\n  - `tquic_stream_alloc()/tquic_stream_free()`\n- Remove or fence an... Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-158",
    "title": "`tquic_cid_pool_destroy()` Removes from rhashtable Under BH spinlock",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:7, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"kfree_rcu\" \"net/tquic/tquic_cid.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_cid.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_cid.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-159",
    "title": "`tquic_conn_retire_cid()` Does Not Remove CID from Lookup Hash Table",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_conn_retire_cid\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Call `rhashtable_remove_fast()` when retiring a local CID. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-161",
    "title": "`tquic_hs_cleanup` -- potential double-free of session ticket",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_setup_psk\" \"net/tquic/crypto/handshake.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Either document clearly that `tquic_hs_setup_psk` takes ownership\n(and the caller must not free), or make `tquic_hs_setup_psk` copy the ticket data.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-162",
    "title": "`tquic_hs_generate_client_hello` -- output buffer `buf` not validated for minimum size",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_generate_client_hello\" \"net/tquic/crypto/handshake.c\"",
      "sed -n '1320,1320p' net/tquic/crypto/handshake.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Validate `buf_len` against the minimum required size at function entry.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-164",
    "title": "`tquic_hs_process_encrypted_extensions` -- ALPN validation insufficient",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_process_encrypted_extensions\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "```c\nif (ext_data_len >= 3 && proto_len > 0 && 3 + proto_len <= ext_data_len) {\n```\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-167",
    "title": "`tquic_hs_setup_psk` -- integer overflow in ticket age calculation",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_setup_psk\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `u64` for `age` and validate the time difference before\nmultiplication. Also validate `lifetime` against RFC 8446 maximum of 604800 (7 days).\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-168",
    "title": "`tquic_recvmsg()` Same Issue as HIGH-07",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_recvmsg\" \"net/tquic/tquic_socket.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-170",
    "title": "Anti-Amplification Integer Overflow",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `check_add_overflow` and `check_mul_overflow` for safe arithmetic.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-171",
    "title": "atomic_sub on sk_rmem_alloc Incompatible with refcount_t",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"skb_set_owner_r\" \"net/quic/tquic/core/stream.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/core/stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `skb_set_owner_r()` for receive buffers and let the destructor handle accounting, consistent with the tquic_stream.c approach.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-172",
    "title": "BBRv2 Inflight Calculation Truncation",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Return `u64` or `u32` with saturation:\n```c\nreturn (u32)min_t(u64, inflight, U32_MAX);\n```\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/cong/bbrv2.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-175",
    "title": "CID Lookup Returns Connection Without Reference Count",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:5, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"kfree_rcu\" \"net/tquic/tquic_cid.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_cid.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "The caller should be in an RCU read-side section, and connections should be freed via `kfree_rcu()`. Alternatively, take a refcount on the connection before returning. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_cid.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-176",
    "title": "Coalesced Packet Splitting Assumes v1 Packet Type Encoding",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_decode_packet_type\" \"net/tquic/core/packet.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Read the version field (bytes 1-4) and use `tquic_decode_packet_type()` for version-aware type detection.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/packet.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-181",
    "title": "const-Correctness Violation in Proxy Packet Decode",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"quic_proxy_capsules\" \"net/tquic/masque/quic_proxy_capsules.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/masque/quic_proxy_capsules.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Either copy the packet data into a separately allocated buffer, or declare `capsule->packet` as `const u8 *` and ensure all consumers respect const correctness.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/quic_proxy_capsules.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-182",
    "title": "copy_from_user with User-Controlled Size in Socket Options",
    "category": "api",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: api, memory."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_socket\" \"net/quic/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_socket.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-185",
    "title": "EKU Semantic Mismatch: get_current_keys Returns Key, Not Secret",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_key_update_get_current_keys\" \"net/tquic/crypto/extended_key_update.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add and use a function to retrieve the current traffic secret (not the\nderived key) from `tquic_key_update_state`. Derive `secret_len` from the\ncipher suite.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/extended_key_update.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-186",
    "title": "FEC decoder recovery -- partial recovery leaks on kzalloc failure",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/fec/fec_decoder.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-187",
    "title": "FEC encoder repair symbol generation -- partial resource leak on kzalloc failure",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "After the loop, iterate remaining entries and free any\n`repair_bufs[i]` that were not successfully adopted by a `repair_sym`.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/fec/fec_encoder.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-188",
    "title": "FEC Repair Count Computation: `block_size * target_fec_rate` Truncation",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Validate `target_fec_rate <= 100` before this calculation.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/fec/fec_scheduler.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-189",
    "title": "FEC Scheduler Loss Rate Overflow",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "```c\nnew_rate = (u32)((u64)sched->loss_count * 1000 Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/fec/fec_scheduler.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-193",
    "title": "h3_control_recv_frame Does Not Parse Frame Payloads",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"h3_control_recv_frame\" \"net/quic/tquic/http3/http3_request.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Implement actual parsing and processing for each frame type in this handler.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_request.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-194",
    "title": "HIGH: atomic64_inc_return for packet number on every TX",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (A, B) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"atomic64_inc_return\" \"net/tquic/tquic_output.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "If the TX path is always serialized by `conn->lock`, replace with a plain `u64` increment. If not always locked, document which paths require the atomic and consider whether a per-path packet number counter with a regular lock would be more appropriate. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_output.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-196",
    "title": "HIGH: Kernel address stored as u64 in buffer ring entries",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:2, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"userspace\" \"net/tquic/io_uring.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use buffer IDs (indices) rather than raw kernel addresses. Store the base address separately in a kernel-only structure and compute the buffer address from `base + bid * size` at use time, never exposing the kernel address in shared structures. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/io_uring.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-197",
    "title": "HIGH: kmalloc(path->mtu) per datagram send",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (A, B) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:6, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"buffer\" \"net/tquic/tquic_output.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a per-connection pre-allocated scratch buffer (protected by `conn->lock` which is already held in the send path), or use a stack allocation since `path->mtu` is bounded and small (typically <= 1500 bytes; 1500 bytes on stack is acceptable in kernel context). Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_output.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-198",
    "title": "http3_stream.c Uses spin_lock Without _bh",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"spin_lock\" \"net/quic/tquic/http3/http3_stream.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/http3/http3_stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `spin_lock_bh` consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_stream.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-199",
    "title": "Incomplete SSRF Protection in TCP-over-QUIC Tunnel",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:6, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"ipv6_addr_v4mapped\" \"net/tquic/tquic_tunnel.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_tunnel.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add checks for all private ranges. Use `ipv4_is_private_10()`, `ipv4_is_private_172()`, `ipv4_is_private_192()` (or the unified `ipv4_is_private()` if available in the kernel version). Add link-local check. For IPv6, add check for IPv4-mapped addresses: `ipv6_addr_v4mapped()` and then validate th... Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-201",
    "title": "Integer Overflow in iovec Total Length Calculation",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"check_add_overflow\" \"net/tquic/masque/connect_udp.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/masque/connect_udp.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `check_add_overflow()` or manually check for overflow: `if (total_len + iov[i].iov_len < total_len) return -EOVERFLOW;` within the accumulation loop.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/connect_udp.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-203",
    "title": "Load Balancer Has No Privilege Checks",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"quic_lb\" \"net/tquic/lb/quic_lb.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "All LB configuration interfaces should require `CAP_NET_ADMIN`.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/lb/quic_lb.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-207",
    "title": "Missing Validation of `first_ack_range` Against `largest_ack`",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:2, sym:1, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_input\" \"net/tquic/core/frame.c\"",
      "sed -n '358,364p' net/tquic/core/frame.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add validation: `if (first_ack_range > largest_ack) return -EPROTO;` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-208",
    "title": "Missing Validation of `TQUIC_MIGRATE` sockopt Address",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:5, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path_find_by_addr\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-209",
    "title": "Netfilter Short Header DCID Parsing Uses Arbitrary Length",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_nf\" \"net/quic/tquic/tquic_nf.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/tquic_nf.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_nf.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-210",
    "title": "Packet Forwarding Has No Privilege Checks",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_forward\" \"net/tquic/tquic_forward.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Require `CAP_NET_ADMIN` to enable packet forwarding.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_forward.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-212",
    "title": "Prague Congestion Control: `ecn_ce_count * mss` Overflow",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Clamp `ecn_ce_count` to a reasonable maximum before multiplication:\n```c\necn_ce_count = min_t(u64, ecn_ce_count, U32_MAX);\nce_bytes = ecn_ce_count * mss;\n```\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/cong/prague.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-214",
    "title": "PTO Duration Exponential Shift Overflow",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_timer\" \"net/quic/tquic/tquic_timer.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "```c\nu32 shift = min_t(u32, rs->pto_count, 30);\npto_duration *= (1ULL << shift);\n```\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_timer.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-215",
    "title": "qlog TOCTOU Race Between Length Check and copy_to_user",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, memory."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/diag/qlog.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-216",
    "title": "Race Condition in Idle Timer Connection Processing",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"proxied_conn_put\" \"net/tquic/masque/quic_proxy.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/masque/quic_proxy.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Hold a reference count on each connection while it is in the `to_remove` list (which appears to be partially done via `proxied_conn_put`). Ensure CID hash removal happens atomically with the list removal under the proxy lock, so no new lookups can find the connection after it is selected for remo... Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/quic_proxy.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-221",
    "title": "Retry Packet Version Encoding Is Hardcoded for v1",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_encode_packet_type\" \"net/tquic/core/connection.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `tquic_encode_packet_type()` for the header byte and `cpu_to_be32(conn->version)` for the version field. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-222",
    "title": "Retry Token AEAD Key Set Under Non-IRQ-Safe Spinlock",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, correctness."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a mutex instead of a spinlock, or use `spin_lock_bh`. Better yet, allocate a per-connection AEAD instance to avoid global locking entirely.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-223",
    "title": "Return Pointer to Stack/Lock-Protected Data in tquic_conn_get_active_cid",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, correctness."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cid\" \"net/tquic/core/connection.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Copy the CID data into a caller-provided buffer while holding the lock, rather than returning a pointer to shared data.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-224",
    "title": "RSA Signature Algorithm Hardcoded to SHA-256 Regardless of Certificate",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Construct the algorithm name dynamically from `cert->signature.hash_algo`, e.g., `\"pkcs1pad(rsa,sha384)\"` or `\"pkcs1pad(rsa,sha512)\"`.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-227",
    "title": "smartnic.c Uses spin_lock Without _bh",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"spin_lock\" \"net/quic/tquic/offload/smartnic.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/offload/smartnic.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Audit all call sites. If any are reachable from softirq context, change to `spin_lock_bh`. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/offload/smartnic.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-228",
    "title": "struct tquic_napi mixes hot and cold fields",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on severity: Severity disagreement across reports: S1, S2."
    ],
    "key_evidence_present": "file:2, sym:10, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"cpus\" \"net/tquic/napi.h\"",
      "sed -n '112,143p' net/tquic/napi.h",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/napi.h\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `____cacheline_aligned_in_smp` between the RX-side fields (`rx_queue`, `rx_queue_len`, `lock`) and the poll-side fields (`stats`, `coalesce`) to separate them onto different cache lines. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-229",
    "title": "Ticket Store Free-After-Remove Race Condition",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_zero_rtt_ticket\" \"net/tquic/crypto/zero_rtt.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/zero_rtt.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "`ticket_store_remove_locked` should only remove from the tree/list. The actual free should happen via `tquic_zero_rtt_put_ticket` (refcount-based). Change `ticket_free(old)` to `tquic_zero_rtt_put_ticket(old)`.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-230",
    "title": "TPROXY Capability Check Logic Inversion",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:4, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_tunnel\" \"net/tquic/tquic_tunnel.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Check `capable(CAP_NET_ADMIN)` first. If the caller lacks the capability, return `-EPERM` immediately rather than silently degrading. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-232",
    "title": "tquic_stream_count_by_type O(n) Scan for Critical Stream Enforcement",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_count_by_type\" \"net/quic/tquic/tquic_stream.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Maintain per-type counters in the connection structure, incrementing/decrementing on stream creation/destruction. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_stream.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-234",
    "title": "tquic_stream_send_allowed Missing Underflow Check",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_send_allowed\" \"net/quic/tquic/core/stream.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/core/stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add underflow guards:\n```c\nif (stream->send_offset >= stream->max_send_data) { blocked; return 0; }\nstream_limit = stream->max_send_data - stream->send_offset;\n```\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-235",
    "title": "tquic_stream_sendfile Reads Only Into First Page",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_sendfile\" \"net/quic/tquic/core/stream.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/core/stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Read into each page individually, or allocate a contiguous buffer. The current code only works correctly when `chunk <= PAGE_SIZE`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-238",
    "title": "Version Negotiation Packet Missing Randomized First Byte",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Snippet(s) contain only comments, not actual vulnerable code.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_input\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `get_random_bytes(&first_byte, 1); first_byte |= 0x80;` similar to the function in `tquic_input.c:523`. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-239",
    "title": "Weak CID Hash Function Enables Hash Flooding",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"quic_proxy\" \"net/tquic/masque/quic_proxy.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `jhash()` or `siphash()` with a per-proxy random key initialized at proxy creation time. SipHash is specifically designed to be resistant to hash-flooding attacks.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/quic_proxy.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-241",
    "title": "`tquic_connect()` Stores Error in `sk->sk_err` as Positive Value Wrongly",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_connect\" \"net/tquic/tquic_socket.c\"",
      "sed -n '260,274p' net/tquic/tquic_socket.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-242",
    "title": "ACK Frame bytes_acked Calculation Can Overflow",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cong_on_ack\" \"net/tquic/tquic_input.c\"",
      "sed -n '736,738p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Cap `first_ack_range` to a reasonable value (e.g., the maximum number of packets in flight) before the multiplication. Alternatively, cap `bytes_acked` to the actual bytes in flight. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-243",
    "title": "ACK Range Processing Without Semantic Validation",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, security.",
      "Sources disagree on severity: Severity disagreement across reports: S1, S2."
    ],
    "key_evidence_present": "file:1, sym:4, lines:4, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_input\" \"net/quic/tquic/tquic_input.c\"",
      "sed -n '642,642p' net/quic/tquic/tquic_input.c",
      "sed -n '2631,2631p' net/quic/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Limit ACK frames per packet to 1 (which RFC 9000 already expects) Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-244",
    "title": "Connection Close Reason Phrase Skipped Without Content Validation",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:1, lines:3, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_output_packet\" \"net/tquic/tquic_output.c\"",
      "sed -n '1248,1250p' net/tquic/tquic_output.c",
      "sed -n '1252,1252p' net/tquic/tquic_output.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Save `skb->len` before calling `tquic_output_packet()`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-245",
    "title": "Data Race in Server Migration Check",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_migration\" \"net/tquic/tquic_migration.c\"",
      "sed -n '1261,1261p' net/tquic/tquic_migration.c",
      "sed -n '1270,1270p' net/tquic/tquic_migration.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-246",
    "title": "Internal Round-Robin Scheduler Missing Bounds Check",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_weighted_select_path\" \"net/tquic/multipath/tquic_scheduler.c\"",
      "sed -n '817,817p' net/tquic/multipath/tquic_scheduler.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/multipath/tquic_scheduler.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-247",
    "title": "Multipath Frame Processing Lacks Encryption Level Validation",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_process_mp_new_connection_id_frame\" \"net/tquic/tquic_input.c\"",
      "sed -n '2027,2038p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add encryption level checks for all multipath frame types. They should only be accepted in 1-RTT packets (and possibly 0-RTT):\n```c\n} else if (frame_type == 0x40) {\n    if (is_initial || is_handshake) {\n        conn->error_code = EQUIC_FRAME_ENCODING;\n        return -EPROTO;\n    }\n    ret = tquic... Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-248",
    "title": "Race Condition on path->last_activity",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, lines:3, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_process_packet\" \"net/quic/tquic/tquic_input.c\"",
      "sed -n '723,723p' net/quic/tquic/tquic_input.c",
      "sed -n '2687,2687p' net/quic/tquic/tquic_input.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-249",
    "title": "Retire Prior To Not Validated Against Sequence Number",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Sources disagree on severity: Severity disagreement across reports: S1, S2.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:5, lines:7, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_process_retire_connection_id_frame\" \"net/quic/tquic/tquic_input.c\"",
      "sed -n '1045,1045p' net/quic/tquic/tquic_input.c",
      "sed -n '1126,1138p' net/quic/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-250",
    "title": "Route Lookup Fallback to init_net",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:2, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_output\" \"net/tquic/tquic_output.c\"",
      "sed -n '1681,1681p' net/tquic/tquic_output.c",
      "sed -n '1714,1714p' net/tquic/tquic_output.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-251",
    "title": "tquic_output_packet Passes NULL conn to ip_local_out",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:5, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_output_packet\" \"net/tquic/tquic_output.c\"",
      "sed -n '1413,1413p' net/tquic/tquic_output.c",
      "sed -n '1662,1663p' net/tquic/tquic_output.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Store a reference to `conn` in `tquic_pacing_state` and pass it through. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-252",
    "title": "Type Shadowing Creates Memory Corruption Risk",
    "category": "api",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:5, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_mp_sched_notify_sent\" \"net/tquic/multipath/tquic_scheduler.c\"",
      "sed -n '2158,2164p' net/tquic/multipath/tquic_scheduler.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-253",
    "title": "UAF-P1-02: - tquic_diag.c accesses conn->sk without reference",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_net_close_connection\" \"net/tquic/tquic_diag.c\"",
      "sed -n '153,153p' net/tquic/tquic_diag.c",
      "sed -n '1019,1019p' net/tquic/tquic_diag.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_diag.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-254",
    "title": "UAF-P3-03: - Tunnel close races with connect_work and forward_work",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4, lines:4, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"cancel_work_sync\" \"net/tquic/tquic_tunnel.c\"",
      "sed -n '469,469p' net/tquic/tquic_tunnel.c",
      "sed -n '429,429p' net/tquic/tquic_tunnel.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_tunnel.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-255",
    "title": "UAF-P3-04: - Path validation timer callback accesses path after potential free",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:8, lines:3, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path\" \"net/tquic/tquic_timer.c\"",
      "sed -n '483,483p' net/tquic/tquic_timer.c",
      "sed -n '1345,1345p' net/tquic/tquic_timer.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_timer.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-256",
    "title": "UAF-P6-01: - SmartNIC ops dereference after device could be freed",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:4, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_nic_unregister\" \"net/tquic/offload/smartnic.c\"",
      "sed -n '253,253p' net/tquic/offload/smartnic.c",
      "sed -n '256,256p' net/tquic/offload/smartnic.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/offload/smartnic.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-257",
    "title": "Unlocked Connection Access in IOCTL",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"socket\" \"net/tquic/tquic_socket.c\"",
      "sed -n '660,660p' net/tquic/tquic_socket.c",
      "sed -n '672,672p' net/tquic/tquic_socket.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-087",
    "title": "(actual): `tquic_hs_process_server_hello` -- missing check before cipher suite read",
    "category": "other",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_hs_process_server_hello\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `if (p + 2 > end) return -EINVAL;` before the cipher suite read.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-088",
    "title": "(Revised): tquic_process_packet Does Not Validate pkt_num_len Against Remaining Data (tquic_input.c, lines 2528-2529, 2572-2574)",
    "category": "other",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, snippet:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_process_packet\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a bounds check before decoding the packet number:\n```c\nif (ctx.offset + pkt_num_len > len)\n    return -EINVAL;\n```\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-090",
    "title": "AF_XDP Socket and Device Lookup Use init_net (Container Escape)",
    "category": "other",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"ns_capable\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Replace `&init_net` with `current->nsproxy->net_ns` consistently, and use `ns_capable()` instead of `capable()` to check capabilities relative to the correct namespace.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-091",
    "title": "Attacker-Controlled Allocation Sizes",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "lines:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-093",
    "title": "Client Certificate Verification Uses Server Logic (EKU Bypass)",
    "category": "security",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_hs_verify_client_cert\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "`tquic_hs_verify_client_cert` must call `verify_chain(ctx, false)` instead of delegating to the server verification function.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-094",
    "title": "conn->sk Accessed Without Lock After Stateless Reset (tquic_input.c, lines 397-407)",
    "category": "other",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_input\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Hold a reference to the socket (`sock_hold(sk)`) under the lock, then call `sk_state_change`, then release the reference (`sock_put(sk)`).\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-103",
    "title": "IPv4/IPv6 Address Discovery Enumerates Host Interfaces (Container Escape / Info Leak)",
    "category": "other",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "snippet:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `sock_net(conn->sk)` to enumerate only devices visible in the connection's namespace.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-105",
    "title": "List Iterator Invalidation in BPM Netdev Notifier (Drop-Relock Pattern)",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_bpm_path_set_state\" net/tquic/",
      "rg -rn \"spin_lock\\|mutex_lock\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `list_for_each_entry_safe()` is NOT sufficient here since the iteration continues after relock. Instead, collect paths to process into a separate list under the lock, then process them after releasing the lock.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-107",
    "title": "MASQUE CONNECT-UDP Proxy Creates Sockets in init_net (Container Escape)",
    "category": "other",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "The tunnel must inherit the network namespace from the QUIC connection's socket: `sock_net(tunnel->conn->sk)`.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-108",
    "title": "Missing Bounds Check Before Frame Type Read",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "lines:2, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-109",
    "title": "Packet Number Length Extracted Before Header Unprotection (tquic_input.c, lines 2529, 2545 vs 2565)",
    "category": "other",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, snippet:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_remove_header_protection\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Move the `pkt_num_len` extraction to AFTER `tquic_remove_header_protection()`:\n```c\nret = tquic_remove_header_protection(conn, data, ctx.offset, ...);\nif (ret < 0) return ret;\npkt_num_len = (data[0] & 0x03) + 1;  // Now reads unprotected bits\nif (ctx.offset + pkt_num_len > len) return -EINVAL;\n``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-111",
    "title": "Potential Integer Overflow in CRYPTO Frame on 32-bit",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "lines:1, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-114",
    "title": "QUIC-over-TCP Client and Server Sockets Use init_net (Container Escape)",
    "category": "other",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"quic_conn\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Propagate `sock_net(quic_conn->sk)` to the TCP socket creation.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-116",
    "title": "Rate Calculation Integer Overflow (`count * 1000`)",
    "category": "other",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "snippet:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Cast to `u64` before multiplication:\n```c\nrate = (u64)count * 1000 Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-117",
    "title": "Reason Length Underflow on 32-bit",
    "category": "correctness",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "lines:1, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-121",
    "title": "RX parsing/decryption assumes contiguous skb data (non-linear skb / GRO risk)",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "A"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source A); no independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "FP-risk: Single-source S0 finding with no line ranges or snippets -- severity may be inflated.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"skb_copy_bits\" \"net/tquic/tquic_input.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "- Linearize the skb before any parsing/decryption that assumes contiguity, or use `skb_copy_bits()` into a contiguous buffer for header+payload.\n- Do this *before* using `data[offset]` patterns. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_input.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-123",
    "title": "Stale skb->len Read After ip_local_out (tquic_output.c, lines 1730-1736)",
    "category": "other",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, snippet:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"ip_local_out\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Save `skb->len` in a local variable before calling `ip_local_out()`:\n```c\nu32 pkt_len = skb->len;\nret = ip_local_out(&init_net, NULL, skb);\nif (ret >= 0) {\n    path->stats.tx_bytes += pkt_len;\n```\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-124",
    "title": "TOCTOU Race in Failover Hysteresis (Atomic Read-Modify-Write)",
    "category": "concurrency",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, snippet:3",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"atomic_inc_return\" net/tquic/",
      "rg -rn \"spin_lock\\|mutex_lock\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Either protect these operations with a per-path spinlock, or use `atomic_inc_return()` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-126",
    "title": "Tunnel Socket Creation Uses init_net (Container Escape)",
    "category": "other",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Must use `sock_net(conn->sk)` or propagate the caller's namespace. The tunnel struct should store a `struct net *` reference obtained from the originating socket.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-130",
    "title": "Use-After-Free in `tquic_migrate_auto()` -- RCU-Protected Path Used After RCU Unlock",
    "category": "memory",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "FP-risk: Single-source S0 finding with no line ranges or snippets -- severity may be inflated.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:6",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_migrate_auto\" \"net/tquic/tquic_migration.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-133",
    "title": "Use-After-Free in Path Lookup (tquic_input.c, lines 245-261)",
    "category": "other",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:3, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_path_put\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Implement reference counting on `tquic_path` objects. The lookup function should atomically increment the refcount under `paths_lock` before returning. Callers must call `tquic_path_put()` when done.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-135",
    "title": "Wrong Network Namespace in ip_local_out (tquic_output.c, line 1730)",
    "category": "other",
    "severity": "S0",
    "original_confidence": "medium",
    "priority_score": 7.0,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1, snippet:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_output\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `sock_net(conn->sk)` instead of `&init_net`. The correct network namespace was already computed at line 1681 in the `rt` lookup:\n```c\nret = ip_local_out(net, conn->sk, skb);\n```\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-204",
    "title": "MASQUE Proxy Has No Access Control",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Require `CAP_NET_ADMIN` to enable MASQUE proxy functionality.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/connect_udp.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-219",
    "title": "Retry Integrity Tag Uses Wrong Key/Nonce for QUIC v2",
    "category": "security",
    "severity": "S1",
    "original_confidence": "high",
    "priority_score": 7.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Select retry integrity key/nonce based on `conn->version`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-262",
    "title": "`tquic_nl_cmd_path_remove()` Double Put on Path",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:8, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"kfree_rcu\" \"net/tquic/tquic_netlink.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_netlink.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-265",
    "title": "Bonding State Machine Missing Lock on State Transition Checks",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_bonding_ctx\" \"net/tquic/bond/tquic_bonding.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/bond/tquic_bonding.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/tquic_bonding.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-266",
    "title": "BPM Path Manager Falls Back to init_net",
    "category": "security",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_bpm\" \"net/tquic/bond/tquic_bpm.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/tquic_bpm.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-267",
    "title": "CPU-5: All hash tables use `jhash` with a **fixed seed of 0**.",
    "category": "security",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=symbol, line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1, lines:1, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_nf\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `siphash` with a per-boot random key (from `net_get_random_once`) instead of `jhash` with seed 0. This is the standard kernel approach since Linux 4.1. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-268",
    "title": "Double `tquic_nl_path_put()` in `tquic_path_remove_and_free()` Assumes refcnt==2",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:8, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path_remove_and_free\" \"net/tquic/tquic_netlink.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_netlink.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-269",
    "title": "Expensive Operation in Loss Path",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_bonding_on_loss_detected\" \"net/tquic/bond/tquic_bonding.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/tquic_bonding.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-270",
    "title": "Failover Retransmit Queue Can Exceed Memory Limits",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_failover\" \"net/tquic/bond/tquic_failover.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/tquic_failover.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-271",
    "title": "FEC Scheme ID Not Validated From Wire",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/fec/fec_decoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/fec/fec_decoder.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-272",
    "title": "Global Congestion Data Cache Without Namespace Isolation",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cong_data_cache\" \"net/tquic/cong/cong_data.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/cong/cong_data.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/cong/cong_data.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-274",
    "title": "h3_stream_lookup_by_push_id Linear Scan Under Lock",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"h3_stream\" \"net/quic/tquic/http3/http3_request.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/http3/http3_request.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_request.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-276",
    "title": "Hysteresis Counters Use Non-Atomic READ_ONCE/WRITE_ONCE Without Lock",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_failover_timeout_work\" \"net/tquic/bond/tquic_failover.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/bond/tquic_failover.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/tquic_failover.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-279",
    "title": "Migration State Stores Raw Path Pointers Without Reference Counting",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:5, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_migration_state\" \"net/tquic/tquic_migration.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-280",
    "title": "Missing Address Family Validation in `tquic_path_create()`",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"sockaddr_in6\" \"net/tquic/tquic_migration.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-283",
    "title": "No ACK Frame Frequency Limit Per Packet",
    "category": "security",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, lines:4",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_process_frames\" \"net/quic/tquic/tquic_input.c\"",
      "sed -n '1900,1914p' net/quic/tquic/tquic_input.c",
      "sed -n '1871,2060p' net/quic/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-284",
    "title": "Path Manager Uses init_net Instead of Per-Connection Net Namespace",
    "category": "api",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_pm_discover_addresses\" \"net/tquic/pm/path_manager.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/pm/path_manager.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-285",
    "title": "Path Validation Timeout Accesses Path State Without Lock After Unlock",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path_handle_response\" \"net/tquic/pm/path_validation.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/pm/path_validation.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/pm/path_validation.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-286",
    "title": "qpack_encoder known_received_count Overflow via Insert Count Increment",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"qpack_encoder\" \"net/quic/tquic/http3/qpack_encoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/qpack_encoder.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-287",
    "title": "Repair Frame Field Truncation Without Validation",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_fec_decode_repair_frame\" \"net/tquic/fec/fec_decoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/fec/fec_decoder.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-289",
    "title": "sched/scheduler.c rr_select TOCTOU on num_paths",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/sched/scheduler.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-292",
    "title": "Stateless Reset Falls Back to init_net",
    "category": "security",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stateless_reset\" \"net/tquic/tquic_stateless_reset.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_stateless_reset.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-294",
    "title": "TOCTOU Race in Bonding State Transition",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_bonding_update_state\" \"net/tquic/bond/tquic_bonding.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/bond/tquic_bonding.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/tquic_bonding.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-295",
    "title": "TQUIC_MAX_PATHS Mismatch",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:2, lines:4",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_sched\" \"net/tquic/multipath/tquic_scheduler.c\"",
      "sed -n '40,40p' net/tquic/multipath/tquic_scheduler.c",
      "sed -n '46,46p' net/tquic/multipath/tquic_scheduler.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-297",
    "title": "tquic_stream_check_flow_control TOCTOU with sendmsg",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:2",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_check_flow_control\" \"net/quic/tquic/tquic_stream.c\"",
      "sed -n '690,690p' net/quic/tquic/tquic_stream.c",
      "sed -n '980,994p' net/quic/tquic/tquic_stream.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-298",
    "title": "tquic_stream_ext Uses GFP_ATOMIC for Large Allocation",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_ext\" \"net/quic/tquic/core/stream.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/core/stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-299",
    "title": "tquic_udp_recv Processes Stateless Reset Before Authenticating Packet",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_udp_recv\" \"net/tquic/tquic_input.c\"",
      "sed -n '2916,2932p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Only check for stateless reset AFTER regular decryption fails (RFC 9000 Section 10.3.1 recommends this order). The check should be a last resort, not a first check. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-301",
    "title": "UAF-P1-03: - conn->sk dereference in congestion control without locking",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"sock_net\" \"net/tquic/cong/tquic_cong.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/cong/tquic_cong.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/cong/tquic_cong.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-302",
    "title": "UAF-P4-01: - tquic_zc_entry uses atomic_t instead of refcount_t",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:5, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"refcount_set\" \"net/tquic/tquic_zerocopy.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_zerocopy.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_zerocopy.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-303",
    "title": "UAF-P4-02: - Paths lack reference counting entirely",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path\" \"net/tquic/tquic_migration.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-305",
    "title": "Unprotected Global Loss Tracker Array",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_loss_tracker\" \"net/tquic/cong/tquic_cong.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/cong/tquic_cong.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/cong/tquic_cong.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-306",
    "title": "Unvalidated `addr_len` Passed to `memcpy` in `tquic_connect()`",
    "category": "memory",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_connect\" \"net/tquic/tquic_socket.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-307",
    "title": "Weight Accumulation Without Overflow Check",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_select_weighted\" \"net/tquic/bond/bonding.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/bonding.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-258",
    "title": "(Revised): tquic_pacing_work Accesses skb->len After tquic_output_packet (tquic_output.c, lines 1413-1418)",
    "category": "other",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:3, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_output_packet\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Save `skb->len` before calling `tquic_output_packet()`.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-259",
    "title": "0-RTT Keys Derived With Empty Transcript",
    "category": "security",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Snippet(s) contain only comments, not actual vulnerable code.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-260",
    "title": "0-RTT Keys Derived With Empty Transcript (Not ClientHello Hash)",
    "category": "security",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: Snippet(s) contain only comments, not actual vulnerable code.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_zero_rtt_derive_secret\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "The ClientHello hash must be included in the key derivation. Use `tquic_zero_rtt_derive_secret` (which does accept `client_hello_hash`) instead of `tquic_zero_rtt_derive_keys` for actual connections.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-261",
    "title": "`setsockopt(SOL_TQUIC, ...)` forces `optlen >= sizeof(int)` even for string/binary options",
    "category": "api",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "A"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source A); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"copy_from_sockptr\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "- Move `copy_from_sockptr(&val, ...)` inside the integer-valued cases only. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-263",
    "title": "ACK Frame bytes_acked Calculation Can Overflow (tquic_input.c, lines 736-738)",
    "category": "other",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_input\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Cap `first_ack_range` to a reasonable value (e.g., the maximum number of packets in flight) before the multiplication. Alternatively, cap `bytes_acked` to the actual bytes in flight.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-264",
    "title": "Aggregate Scheduler Unfair Minimum Weight Floor",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/multipath/sched_aggregate.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-273",
    "title": "h3_request_send_headers State Check TOCTOU",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"h3_request_send_headers\" \"net/quic/tquic/http3/http3_request.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/http3/http3_request.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_request.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-275",
    "title": "HIGH: Multiple ktime_get() calls per packet",
    "category": "perf",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "A"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source A); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:3, sym:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"ktime_get\" \"net/tquic/napi.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Read the timestamp once at the start of packet processing and pass it through the context. The `tquic_rx_ctx` struct already exists and could carry a `ktime_t recv_time` field. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/napi.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-277",
    "title": "Large Stack Allocation in XOR Recovery",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"attempt_xor_recovery\" \"net/tquic/fec/fec_decoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/fec/fec_decoder.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-278",
    "title": "Memory Exhaustion via Unbounded QPACK Header Lists",
    "category": "security",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"qpack_header_list_add\" \"net/quic/tquic/http3/qpack.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/qpack.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-281",
    "title": "Multipath Frame Processing Lacks Encryption Level Validation (tquic_input.c, lines 2027-2038)",
    "category": "other",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, snippet:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_input\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add encryption level checks for all multipath frame types. They should only be accepted in 1-RTT packets (and possibly 0-RTT):\n```c\n} else if (frame_type == 0x40) {\n    if (is_initial || is_handshake) {\n        conn->error_code = EQUIC_FRAME_ENCODING;\n        return -EPROTO;\n    }\n    ret = tquic... Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-282",
    "title": "Multiple ktime_get() calls per packet",
    "category": "perf",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:3, sym:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"already\" \"net/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_output.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-288",
    "title": "Same Stack Issue in Encoder",
    "category": "perf",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"generate_rs_repair\" \"net/tquic/fec/fec_encoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/fec/fec_encoder.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-290",
    "title": "sched/scheduler.c wrr_select Stale total_weight",
    "category": "correctness",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/sched/scheduler.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-291",
    "title": "Stale Path Pointer Returned After rcu_read_unlock",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:4",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_path_remove\" net/tquic/",
      "rg -rn \"spin_lock\\|mutex_lock\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-293",
    "title": "TOCTOU in Round-Robin Path Count vs Selection",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/multipath/sched_minrtt.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-296",
    "title": "tquic_output_packet Passes NULL conn to ip_local_out (tquic_output.c, line 1413)",
    "category": "other",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:3, snippet:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_output_packet\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Store a reference to `conn` in `tquic_pacing_state` and pass it through. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-300",
    "title": "tquic_udp_recv Processes Stateless Reset Before Authenticating Packet (tquic_input.c, lines 2916-2932)",
    "category": "other",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_udp_recv\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Only check for stateless reset AFTER regular decryption fails (RFC 9000 Section 10.3.1 recommends this order). The check should be a last resort, not a first check.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-304",
    "title": "Unit tests model packet-number length as readable from the first byte without HP removal",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "A"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source A); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:5",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"plan\" \"net/tquic/test/packet_test.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/test/packet_test.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "- Add tests that build a packet with header protection applied, run HP unprotect, and then validate pn_len and key_phase. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/test/packet_test.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-308",
    "title": "Weighted Scheduler Has No Lock Protection",
    "category": "concurrency",
    "severity": "S1",
    "original_confidence": "medium",
    "priority_score": 4.9,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"weighted_get_path\" \"net/tquic/multipath/sched_weighted.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/multipath/sched_weighted.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/multipath/sched_weighted.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-309",
    "title": "Bloom Filter False Negatives Allow Replay",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"detected\" \"net/tquic/crypto/zero_rtt.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "This is an inherent limitation of bloom filters. Document this as a known limitation. Consider augmenting with a small exact-match cache for recent tickets (last N tickets stored exactly) to eliminate the rotation window for the most common case. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-310",
    "title": "Decoy Packet Size Calculation Can Underflow",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, sym:4, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"alloc_skb\" \"net/tquic/security/quic_exfil.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-311",
    "title": "EKU Request ID Increment Outside Lock",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:1, lines:2",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_eku_request\" \"net/tquic/crypto/extended_key_update.c\"",
      "sed -n '440,440p' net/tquic/crypto/extended_key_update.c",
      "sed -n '451,451p' net/tquic/crypto/extended_key_update.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/crypto/extended_key_update.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Keep the lock held through request allocation and insertion, or use an atomic increment for the request ID. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-312",
    "title": "HP Key Rotation Swaps Old Keys Without Zeroization",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"memzero_explicit\" \"net/tquic/crypto/header_protection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Ensure `memzero_explicit()` is called on the mask buffer in all return paths, including error paths. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/header_protection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-313",
    "title": "HTTP/3 Connection: O(n) Push Entry Counting",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"client\" \"net/tquic/http3/http3_conn.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Maintain a running counter of push entries instead of counting on demand. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/http3_conn.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-314",
    "title": "HTTP/3 Frame Parsing: 16MB Maximum Frame Payload",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, perf, security."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"frames\" \"net/tquic/http3/http3_frame.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Consider reducing the default limit to 1MB or making it configurable. Most HTTP/3 frames (HEADERS, SETTINGS, GOAWAY) should be much smaller. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/http3_frame.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-315",
    "title": "HTTP/3 Settings Parser: TOCTOU on Settings Count",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"processing\" \"net/tquic/http3/http3_frame.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/http3/http3_frame.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Ensure the input buffer is exclusively owned during parsing, or perform length validation inline during the single-pass parse. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/http3_frame.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-316",
    "title": "Missing Bounds Check on tbs Pointer in Signature Parse",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "file:1, sym:4",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"buffer\" \"net/tquic/crypto/cert_verify.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/cert_verify.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Validate that `cert->tbs + cert->tbs_len <= data + total_len` before computing `remaining`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-318",
    "title": "Path Score Computation Can Overflow in Migration Target Selection",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory, other."
    ],
    "key_evidence_present": "file:1, sym:4, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"bandwidth\" \"net/tquic/tquic_migration.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Reorder operations to divide before multiplying, or cap intermediate values. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-319",
    "title": "Per-Call crypto_alloc_shash in Stateless Reset Token Generation",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stateless_reset_generate_token\" \"net/tquic/tquic_stateless_reset.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Pre-allocate a per-CPU or global HMAC transform and reuse it. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_stateless_reset.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-320",
    "title": "QAT Encrypt Sets Key on Every Call",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: perf, security."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"crypto_aead_setkey\" \"net/tquic/crypto/hw_offload.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Set the key once during context initialization and only re-set on key update. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/hw_offload.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-321",
    "title": "Qlog Ring Buffer: Not Truly Lock-Free",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"buffer\" \"net/tquic/diag/qlog.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/diag/qlog.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Either implement a true lock-free ring buffer (using `smp_store_release`/`smp_load_acquire` pairs) or document the locking requirement clearly. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/diag/qlog.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-322",
    "title": "Qlog: JSON Strings Not Escaped",
    "category": "api",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: api, other."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"json\" \"net/tquic/diag/qlog.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Implement JSON string escaping for all string values emitted in qlog JSON output. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/diag/qlog.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-323",
    "title": "QPACK Encoder/Decoder: Excessive Stack Usage",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory, other."
    ],
    "key_evidence_present": "file:2, sym:5",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"chain\" \"net/tquic/http3/qpack_encoder.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/http3/qpack_encoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Allocate these buffers dynamically with `kmalloc(GFP_ATOMIC)` or use a pre-allocated per-connection buffer. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/qpack_encoder.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-324",
    "title": "QPACK Huffman Decoder: O(n*256) Complexity",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"decoder\" \"net/tquic/http3/qpack.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Replace with a 256-entry lookup table or state-machine-based decoder (standard approach for HPACK/QPACK Huffman). Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/qpack.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-325",
    "title": "QPACK Integer Decode: Shift Overflow",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory, other."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"behavior\" \"net/tquic/http3/qpack.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/http3/qpack.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a check: `if (shift > 62) return -H3_ERR_QPACK_DECOMPRESSION_FAILED;` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/qpack.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-326",
    "title": "Time Parsing Does Not Validate Digit Characters",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, sym:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"isdigit\" \"net/tquic/crypto/cert_verify.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `isdigit()` checks for all time component characters before conversion. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-327",
    "title": "Transcript Buffer Not Zeroized Before Free",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "file:1, sym:4",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"kfree\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `kfree_sensitive()` or call `memzero_explicit()` on the transcript buffer before freeing. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-328",
    "title": "Tunnel Port Allocation Unsigned Underflow",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"none\" \"net/tquic/tquic_tunnel.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_tunnel.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-348",
    "title": "`tquic_proc.c` Buffer Overflow in Hex CID Formatting",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:2, lines:3, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_proc\" \"net/quic/tquic/tquic_proc.c\"",
      "sed -n '414,414p' net/quic/tquic/tquic_proc.c",
      "sed -n '604,604p' net/quic/tquic/tquic_proc.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/tquic_proc.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-351",
    "title": "`tquic_sock_setsockopt()` Reads `int` for Some Options But Accepts `optlen >= sizeof(int)` Without Capping",
    "category": "api",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Sources disagree on category: Category disagreement across reports: api, other."
    ],
    "key_evidence_present": "file:1, sym:4, lines:5, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"definition\" \"net/tquic/tquic_socket.c\"",
      "sed -n '840,840p' net/tquic/tquic_socket.c",
      "sed -n '899,899p' net/tquic/tquic_socket.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-352",
    "title": "`transport_params.c` Memcpy with `count * sizeof(u32)` Without Overflow Check",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, lines:1, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '2513,2513p' net/quic/tquic/core/transport_params.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/core/transport_params.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-353",
    "title": "ACK Frame Range Count Uses u64 Loop Variable Against size_t max_ranges",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on severity: Severity disagreement across reports: S2, S3."
    ],
    "key_evidence_present": "file:1, lines:1, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '370,370p' net/tquic/core/frame.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-361",
    "title": "Certificate Chain Parsing Does Not Verify Issuer-Subject Linkage Before Trust Check",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:1, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '2319,2319p' net/tquic/crypto/cert_verify.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-362",
    "title": "CID Sequence Number Rollback on rhashtable Insert Failure",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, correctness."
    ],
    "key_evidence_present": "file:1, lines:1, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '502,502p' net/tquic/core/connection.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Perform the sequence number increment inside the spinlock, or use atomic operations.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-363",
    "title": "conn->streams_lock for RB-tree walk on every STREAM frame",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:4, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"spin_lock_bh\" \"net/tquic/tquic_input.c\"",
      "sed -n '917,934p' net/tquic/tquic_input.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Consider RCU-protected RB-tree for read-side lookups, or use a lockless hash table for the common case of looking up an already-existing stream. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-367",
    "title": "Coupled Congestion Control Division by Zero",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:2, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '897,897p' net/quic/tquic/bond/cong_coupled.c",
      "sed -n '949,949p' net/quic/tquic/bond/cong_coupled.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-370",
    "title": "Error Ring Uses Atomics Under Spinlock Unnecessarily",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_proc\" \"net/quic/tquic/tquic_proc.c\"",
      "sed -n '572,589p' net/quic/tquic/tquic_proc.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_proc.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-372",
    "title": "FEC encoder allocates per-symbol in GFP_ATOMIC",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, memory."
    ],
    "key_evidence_present": "file:2, lines:1, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '111,115p' net/tquic/fec/fec_encoder.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/fec/fec_encoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use slab caches for symbol structs and data buffers. Pre-allocate symbol arrays per block. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-373",
    "title": "FEC encoder double lock nesting",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:4, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"list_add_tail\" \"net/tquic/fec/fec_encoder.c\"",
      "sed -n '275,283p' net/tquic/fec/fec_encoder.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/fec/fec_encoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Remove `block->lock` when the block is only accessed under `enc->lock`, or redesign to avoid nesting. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-374",
    "title": "FEC Encoder Triple-Nested Locking",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:1, snippet:2",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '576,576p' net/quic/tquic/fec/fec_encoder.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-383",
    "title": "Key Material Not Zeroized on All Error Paths in tquic_zero_rtt_derive_keys",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_zero_rtt_derive_keys\" \"net/tquic/crypto/zero_rtt.c\"",
      "sed -n '662,662p' net/tquic/crypto/zero_rtt.c",
      "sed -n '698,698p' net/tquic/crypto/zero_rtt.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `if (ret) memzero_explicit(keys, sizeof(*keys));` before the `out:` label, or zeroize in the `out:` path when `ret != 0`.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-400",
    "title": "Pacing work function drops and reacquires lock per packet",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:5, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"__skb_dequeue\" \"net/tquic/tquic_output.c\"",
      "sed -n '1396,1421p' net/tquic/tquic_output.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Dequeue a batch of packets under a single lock hold, then send them all without the lock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-404",
    "title": "Per-Call skcipher_request Allocation in HP Mask Hot Path",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:1, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hp_key\" \"net/tquic/crypto/header_protection.c\"",
      "sed -n '164,164p' net/tquic/crypto/header_protection.c",
      "sed -n '211,211p' net/tquic/crypto/header_protection.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/crypto/header_protection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Pre-allocate the `skcipher_request` in the `tquic_hp_key` structure\nduring key setup. Use a per-CPU or per-connection pre-allocated request to\navoid hot-path allocations.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-405",
    "title": "Per-Packet kmalloc in Batch Encrypt/Decrypt",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, lines:2, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '708,708p' net/tquic/crypto/hw_offload.c",
      "sed -n '703,703p' net/tquic/crypto/hw_offload.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Allocate a single buffer sized for the largest packet in the batch, or\nuse a pre-allocated per-CPU bounce buffer. Alternatively, encrypt in-place if\nthe caller guarantees sufficient tail room (the `data_buf_len` check at line\n703 already validates this -- the temporary buffer is unnecessary).\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-409",
    "title": "PSK Identity Logged with `tquic_dbg()` -- Sensitive Data in Kernel Logs",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_dbg\" \"net/tquic/tquic_socket.c\"",
      "sed -n '1202,1202p' net/tquic/tquic_socket.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-410",
    "title": "rcu_dereference Outside Explicit RCU Section",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"sk_buff\" \"net/quic/tquic/tquic_udp.c\"",
      "sed -n '1303,1303p' net/quic/tquic/tquic_udp.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_udp.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-417",
    "title": "SmartNIC offload takes dev->lock for every key operation",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:3, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"add_key\" \"net/tquic/offload/smartnic.c\"",
      "sed -n '326,328p' net/tquic/offload/smartnic.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/offload/smartnic.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a per-connection lock or a mutex (key operations are not in the data path and can sleep). Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-421",
    "title": "Sysctl and Proc Entries Registered in init_net Only",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:4, sym:2, lines:3, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_sysctl\" \"net/tquic/transport/tcp_fallback.c\"",
      "sed -n '843,843p' net/tquic/transport/tcp_fallback.c",
      "sed -n '272,272p' net/tquic/transport/tcp_fallback.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-427",
    "title": "tquic_conn_create -- loss_detection_init failure doesn't clean up timers",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:2, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_conn_create\" \"net/quic/tquic/core/quic_connection.c\"",
      "sed -n '495,501p' net/quic/tquic/core/quic_connection.c",
      "sed -n '504,506p' net/quic/tquic/core/quic_connection.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-438",
    "title": "Zerocopy entry refcount uses atomic_t",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (A, B) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:4, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"atomic_t\" \"net/tquic/tquic_zerocopy.c\"",
      "sed -n '58,59p' net/tquic/tquic_zerocopy.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_zerocopy.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Change to `refcount_t` and use `refcount_inc()` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-317",
    "title": "Path Metrics Subscription: Timer/Connection Lifetime Race",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"del_timer_sync\" \"net/tquic/diag/path_metrics.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/diag/path_metrics.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `del_timer_sync()` in `tquic_metrics_unsubscribe_conn()` to ensure the timer callback has completed before freeing the connection, or hold a connection reference in the subscription. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/diag/path_metrics.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-330",
    "title": "`additional_addr_add()` Has TOCTOU Between Duplicate Check and Insert",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, correctness."
    ],
    "key_evidence_present": "file:1, sym:2, lines:2",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"additional_addr_add\" \"net/tquic/core/additional_addresses.c\"",
      "sed -n '188,188p' net/tquic/core/additional_addresses.c",
      "sed -n '191,191p' net/tquic/core/additional_addresses.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/core/additional_addresses.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Keep the lock held across the check-and-insert operation, or use a two-phase approach with lock re-check after allocation. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-331",
    "title": "`bbrv3.c` CE Ratio Potential Division by Zero",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Check denominator and use u64 for multiplication.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/cong/bbrv3.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-332",
    "title": "`hs_varint_encode` -- no bounds check on output buffer",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a `u32 buf_len` parameter or document the 8-byte minimum requirement.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-333",
    "title": "`http3_frame.c` Settings Frame Parser: No Bounds on `count`",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_frame.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-334",
    "title": "`kmem_cache_create()` Per Stream Manager Risks Name Collision",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"kmem_cache_create\" \"net/tquic/core/stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a global slab cache shared across all stream managers, or include a unique identifier in the cache name. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/stream.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-335",
    "title": "`ring_index()` Uses Unbounded While Loop",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"ring_index\" \"net/tquic/core/receive_timestamps.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a guard: `if (size == 0) return 0;` and use modular arithmetic: `return ((idx % (s32)size) + size) % size;` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/receive_timestamps.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-336",
    "title": "`tquic_accept()` Holding `sk_lock.slock` Improperly",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, correctness."
    ],
    "key_evidence_present": "file:1, sym:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"lock_sock\" \"net/tquic/tquic_socket.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Access the accept queue under `lock_sock()` alone without the additional spinlock. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-337",
    "title": "`tquic_cong.c` ECN Byte Calculation Overflow",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cong\" \"net/quic/tquic/cong/tquic_cong.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Clamp `ecn_ce_count` to a realistic maximum before multiplication.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/cong/tquic_cong.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-338",
    "title": "`tquic_fc_conn_data_sent()` Race Between Check and Update",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, correctness."
    ],
    "key_evidence_present": "file:1, sym:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_fc_conn_data_sent\" \"net/tquic/core/flow_control.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/core/flow_control.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Provide a combined `tquic_fc_conn_try_send()` that atomically checks and commits. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/flow_control.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-339",
    "title": "`tquic_hs_derive_early_secrets` -- `memzero_explicit` called before error check",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_derive_early_secrets\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Move `memzero_explicit` after the binder key is no longer needed,\nor into an error/cleanup path.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-340",
    "title": "`tquic_hs_generate_client_hello` -- `hkdf_label` stack buffer on sensitive crypto path",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_generate_client_hello\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `memzero_explicit(hkdf_label, sizeof(hkdf_label));` before return.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-341",
    "title": "`tquic_hs_process_certificate_verify` -- `content[200]` stack buffer could overflow with large hash",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_process_certificate_verify\" \"net/tquic/crypto/handshake.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Compute the required size dynamically: `content_size = 64 + 33 + 1 + hash_len`\nand validate it fits, or allocate dynamically.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-342",
    "title": "`tquic_hs_process_certificate` -- unbounded certificate allocation",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_process_certificate\" \"net/tquic/crypto/handshake.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "```c\nif (cert_len > TLS_CERT_MAX_LEN)\n    return -EINVAL;\n```\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-343",
    "title": "`tquic_hs_process_server_hello` -- `static const` inside function body",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_process_server_hello\" \"net/tquic/crypto/handshake.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Move to file scope alongside the other static const arrays (like\n`tls12_downgrade_sentinel`). Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-344",
    "title": "`tquic_migrate_validate_all_additional()` Lock Drop/Reacquire Pattern",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_migrate_validate_all_additional\" \"net/tquic/tquic_migration.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-345",
    "title": "`tquic_nl_cmd_path_dump()` Incorrect Cast of `cb->ctx`",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:4, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_dump_ctx\" \"net/tquic/tquic_netlink.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-346",
    "title": "`tquic_path_compute_score()` Integer Overflow in Score Calculation",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path_compute_score\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-347",
    "title": "`tquic_path_is_degraded()` Division by Zero Possible",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path_is_degraded\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-349",
    "title": "`tquic_process_stream_frame()` Does Not Check Final Size Consistency",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_process_stream_frame\" \"net/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "When FIN is received, record `stream->final_size = offset + length`. On subsequent data, verify `offset + length <= stream->final_size` and that any new FIN matches the recorded value. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_input.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-350",
    "title": "`tquic_sendmsg_datagram()` Allocates Kernel Buffer Sized by User-Controlled `len`",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_sendmsg_datagram\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-355",
    "title": "atomic_inc/dec for rx_queue_len on every enqueue/dequeue",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:2, sym:4",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"count\" \"net/tquic/napi.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/napi.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Remove `rx_queue_len` atomic. Use `skb_queue_len(&tn->rx_queue)` when the length is needed (it reads `qlen` from the queue head, which is maintained by `__skb_queue_tail`/`__skb_dequeue` already under the queue's lock). Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/napi.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-356",
    "title": "Benchmark write() Handler - Stack Buffer for User Input",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/bench/benchmark.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-357",
    "title": "Bloom Filter Seeds Never Rotated",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use 64-bit seeds (siphash instead of jhash) and rotate seeds during bucket rotation, hashing any remaining entries into the new bucket with new seeds.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-358",
    "title": "BPM Path Manager Uses Workqueue Without Connection Lifetime Guard",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:5, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"delayed_work\" \"net/tquic/bond/tquic_bpm.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a `struct tquic_connection *conn` reference with proper refcounting, and verify all work items are cancelled during teardown. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/tquic_bpm.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-359",
    "title": "cert_verify.c - kmalloc(count + 1) Integer Overflow",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/crypto/cert_verify.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-360",
    "title": "cert_verify.c parse_san_extension -- error code not propagated",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/crypto/cert_verify.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-364",
    "title": "connect_ip.c Datagram Buffer Allocation from Attacker Data",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, memory."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/masque/connect_ip.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-365",
    "title": "connect_udp.c URL Encoding Can Exceed Buffer",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/masque/connect_udp.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-366",
    "title": "Connection State Not Checked in tquic_conn_handle_close",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_connection\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Check `conn->state` and early-return for DRAINING/CLOSED states. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-368",
    "title": "Decoy Traffic Uses Easily Fingerprinted All-Zero Padding",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"quic_exfil\" \"net/tquic/security/quic_exfil.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fill decoy packets with cryptographically random data, or better yet, use the same encryption layer as real packets so decoy traffic is indistinguishable at the wire level.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-369",
    "title": "Diag/Tracepoints Initialize in init_net",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/diag/tracepoints.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-371",
    "title": "Exfil Context set_level Destroys and Reinitializes Without Lock",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_exfil_ctx_set_level\" \"net/tquic/security/quic_exfil.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/security/quic_exfil.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Acquire `ctx->lock` around the destroy/init sequence, or use RCU to swap in a new configuration atomically. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-375",
    "title": "Gaussian Random Approximation Produces Biased Distribution",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"gaussian_random\" \"net/tquic/security/quic_exfil.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "If Gaussian jitter is required, use a proper implementation. For kernel context where floating-point is unavailable, consider using the Ziggurat method with integer arithmetic, or use a larger sum of uniform random variables for better CLT approximation (sum of 12 uniform randoms is a common choi... Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-376",
    "title": "h3_stream_recv_data frame_hdr Buffer Partial Read",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"h3_stream_recv_data\" \"net/quic/tquic/http3/http3_request.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Validate that `ret >= 2` (minimum varint frame header) before calling the parser, or zero-initialize `frame_hdr`.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_request.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-377",
    "title": "h3_stream_recv_headers Does Not Validate payload_len Against H3_MAX_FRAME_PAYLOAD_SIZE",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"h3_stream_recv_headers\" \"net/quic/tquic/http3/http3_request.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add: `if (payload_len > H3_MAX_FRAME_PAYLOAD_SIZE) return -EMSGSIZE;`\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_request.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-378",
    "title": "Hardcoded 8-Byte CID in Short Header Unprotect",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Snippet(s) contain only comments, not actual vulnerable code.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"quic_crypto\" \"net/tquic/core/quic_crypto.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Pass the known local CID length to the unprotection function. The\nreceiver knows the length of its own CIDs.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/quic_crypto.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-379",
    "title": "HMAC Transform Allocated Per-Token in `tquic_stateless_reset_generate_token()`",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:4",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"get_random_bytes\" \"net/tquic/tquic_stateless_reset.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_stateless_reset.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_stateless_reset.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-380",
    "title": "Hostname Wildcard Matching Allows Wildcards in Non-Leftmost Position",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-381",
    "title": "http3_priority.c snprintf Priority Field Truncation",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_priority.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-384",
    "title": "kmem_cache Names Not Unique Per Connection",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `KMEM_CACHE` macro or create caches at module init time (shared across all connections), not per-connection. Or use unique names with connection ID suffix.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-385",
    "title": "Load Balancer Feistel Network Half-Length Overlap",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/lb/quic_lb.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a separate byte position for the round number that does not conflict with data, or XOR the round number rather than overwriting. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/lb/quic_lb.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-386",
    "title": "Load Balancer Nonce Counter Wraps Without Re-keying",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Detect counter wrap and refuse to generate nonces, or use a larger state that combines counter with additional randomness. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/lb/quic_lb.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-387",
    "title": "MEDIUM: BBRv3 uses ktime_get_ns() for every bandwidth sample",
    "category": "perf",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (A, B) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"bbrv3_update_bw\" \"net/tquic/cong/bbrv3.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Pass the timestamp from the caller rather than calling `ktime_get_ns()` again. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/cong/bbrv3.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-388",
    "title": "MEDIUM: kzalloc per io_uring async request",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory, perf."
    ],
    "key_evidence_present": "file:2, sym:4, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"area\" \"net/tquic/io_uring.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `io_alloc_async_data()` or embed the async data in the `io_kiocb` command data area (the `io_kiocb_to_cmd()` pattern already used for send/recv). Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/io_uring.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-389",
    "title": "MEDIUM: Per-chunk skb allocation in zerocopy path",
    "category": "api",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: api, perf."
    ],
    "key_evidence_present": "file:2, sym:6, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"alloc_skb\" \"net/tquic/tquic_zerocopy.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Batch skb allocation using `alloc_skb_with_frags()` or `napi_alloc_skb()` for bulk allocation. Use the path MTU instead of hardcoded 1200. Consider using GSO to coalesce multiple chunks into fewer skbs. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_zerocopy.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-390",
    "title": "MEDIUM: Zerocopy sendmsg chunks at 1200 bytes",
    "category": "perf",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: api, correctness, perf."
    ],
    "key_evidence_present": "file:2, sym:6, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"chunks\" \"net/tquic/tquic_zerocopy.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use larger chunks (up to GSO segment size) and coalesce page fragments into fewer skbs. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_zerocopy.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-391",
    "title": "MIB counter updates on every packet in RX/TX paths",
    "category": "perf",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=symbol, line range, snippet.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "sym:8, lines:2, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_add_stats\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Acceptable overhead if using per-CPU counters. Verify the macro implementation uses `this_cpu_add` rather than atomics. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-392",
    "title": "Missing Bounds Check on tquic_hyst_state_names Array Access",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hyst_state_names\" \"net/tquic/bond/tquic_failover.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/bond/tquic_failover.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `ARRAY_SIZE(tquic_hyst_state_names)` bounds check before indexing. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/tquic_failover.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-393",
    "title": "Missing skb->dev Assignment in Packet Injection",
    "category": "api",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: api, other."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_connect_ip_inject_packet\" \"net/tquic/masque/connect_ip.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Set `skb->dev` to the tunnel's virtual network device (`iface->net_device` from the tunnel's interface structure).\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/connect_ip.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-394",
    "title": "Multiple atomic operations in NAPI enqueue path",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:2, sym:4",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"line\" \"net/tquic/napi.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/napi.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Remove the redundant `rx_queue_len` atomic (as noted above). This reduces to the minimum of one lock acquisition per enqueue. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/napi.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-395",
    "title": "NAT Keepalive Config Pointer Not Protected Against Concurrent Free",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"rcu_assign_pointer\" \"net/tquic/pm/nat_keepalive.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/pm/nat_keepalive.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Access `state->config` under `state->lock`, or use `rcu_dereference()`/`rcu_assign_pointer()` for RCU-protected access. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/pm/nat_keepalive.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-396",
    "title": "Netlink Path Dump Reads conn_id on Every Iteration",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_nl_cmd_path_dump\" \"net/tquic/tquic_netlink.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_netlink.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-397",
    "title": "Netlink PM Commands Missing CAP_NET_ADMIN Checks",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_pm_nl_add_path\" \"net/tquic/pm/pm_netlink.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Ensure all PM netlink ops have `.flags = GENL_ADMIN_PERM` in the `genl_ops` array, or add explicit `capable(CAP_NET_ADMIN)` checks in each handler. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/pm/pm_netlink.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-398",
    "title": "No Flow Count Limit in HTTP Datagram Manager",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"http_datagram_flow\" \"net/tquic/masque/http_datagram.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a configurable `max_flows` limit to the manager and reject new flow creation when the limit is reached.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/http_datagram.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-399",
    "title": "No Token Replay Protection Beyond Timestamp",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_token\" \"net/tquic/tquic_token.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Implement a token replay cache (e.g., a bloom filter or hash set of\nrecently seen token nonces) similar to the 0-RTT anti-replay mechanism already\ndefined in `zero_rtt.h`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_token.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-401",
    "title": "Packet Number Decode Returns 0 on Invalid Input",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Return a sentinel value or use an error pointer pattern (pass pn by reference, return error code).\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/packet.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-402",
    "title": "Path Length Constraint Check Off-By-One",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-403",
    "title": "Path Manager netdev_event Shadows Variable 'i'",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Rename the inner loop variable. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/pm/path_manager.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-407",
    "title": "poll() Accesses Connection/Stream Without Any Lock",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_socket\" \"net/quic/tquic/tquic_socket.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `READ_ONCE(tsk->accept_queue_len)`. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_socket.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-408",
    "title": "Proc Entries Hardcoded to init_net.proc_net",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:3, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-411",
    "title": "Request ID Truncation from u64 to int",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_connect_ip_request_address\" \"net/tquic/masque/connect_ip.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Change the return type to `s64` or return 0 for success and pass the request_id through an output pointer parameter.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/masque/connect_ip.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-412",
    "title": "Retry Token Address Validation Uses Weak Hash",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `siphash` instead of `jhash` for address validation hashing.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-413",
    "title": "SAN DNS Names Not Validated for Embedded NUL Characters",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/crypto/cert_verify.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Reject SAN DNS names containing NUL bytes (0x00). Add: `if (memchr(p + 1 + hdr_len, 0, content_len)) continue;`\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-414",
    "title": "Scheduler Change Race Between State Check and Modification",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_scheduler\" \"net/tquic/multipath/tquic_scheduler.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/multipath/tquic_scheduler.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Move the state check inside the spinlock-protected region. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/multipath/tquic_scheduler.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-415",
    "title": "Security Hardening MIB Stats Always Go to init_net",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Pass the connection's `sock_net(conn->sk)` to the security event reporting function.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/security_hardening.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-416",
    "title": "Signed/Unsigned Mismatch in Scheduler Queue Delay",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/sched/scheduler.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-418",
    "title": "smartnic.c - kmalloc_array with Attacker-Influenced Count",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, memory."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/offload/smartnic.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-419",
    "title": "snprintf Return Value Not Checked in qlog.c",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `scnprintf` consistently (returns actual bytes\nwritten, not hypothetical) or check `if (len >= buflen) return;` after\neach snprintf.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/diag/qlog.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-420",
    "title": "Stateless Reset Static Key Accessible via `tquic_stateless_reset_get_static_key()` Export",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stateless_reset_get_static_key\" \"net/tquic/tquic_stateless_reset.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_stateless_reset.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-422",
    "title": "Sysctl Permissions Are Overly Permissive",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_sysctl\" \"net/tquic/tquic_sysctl.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_sysctl.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-423",
    "title": "Sysctl Variables Lack Range Validation",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Register a proper sysctl table with `proc_dointvec_minmax` handlers and range limits, or add range validation in the accessor functions. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-424",
    "title": "Token Hash Comparison Not Constant-Time",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `crypto_memneq` for the comparison.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-425",
    "title": "Token Key Rotation Does Not Zeroize Old Key",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"memzero_explicit\" \"net/tquic/tquic_token.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Zeroize `old_key->key` with `memzero_explicit()` and set\n`old_key->valid = false` inside this function, making the API self-cleaning.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_token.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-426",
    "title": "tquic_cid_pool_init -- timer initialized but not cancelled on later failure",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:6, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"init_work\" \"net/quic/tquic/tquic_cid.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Call `del_timer_sync(&pool->rotation_timer)` before `kfree(pool)`.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_cid.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-428",
    "title": "tquic_fc_reserve_credit Does Not Actually Reserve",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_fc_reserve_credit\" \"net/quic/tquic/core/flow_control.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Implement actual atomic reservation by deducting credit in reserve and adding back in release.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/core/flow_control.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-429",
    "title": "tquic_handshake.c tquic_start_handshake -- hs freed with memzero_explicit but no kfree_sensitive",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"kfree_sensitive\" \"net/quic/tquic/tquic_handshake.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_handshake.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-430",
    "title": "tquic_output_flush -- spin_unlock_bh after acquiring spin_lock_bh, but lock dropped mid-loop",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_output_flush\" \"net/quic/tquic/tquic_output.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_output.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-431",
    "title": "tquic_retry.c -- integrity_aead_lock held across AEAD operations",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_retry\" \"net/quic/tquic/tquic_retry.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_retry.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_retry.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-432",
    "title": "tquic_stream_memory_pressure Frees Without ext Cleanup",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_memory_pressure\" \"net/quic/tquic/core/stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `tquic_stream_ext_free(mgr, stream->ext);` before `kfree(stream);`.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-433",
    "title": "tquic_stream_trigger_output Inflight Underflow",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_trigger_output\" \"net/quic/tquic/tquic_stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add underflow guard: `inflight = (path->stats.tx_bytes > path->stats.acked_bytes) ? path->stats.tx_bytes - path->stats.acked_bytes : 0;`\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_stream.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-434",
    "title": "tquic_stream_write Holds mgr->lock for Entire Copy Loop",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_write\" \"net/quic/tquic/core/stream.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/core/stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Copy data to a pre-allocated buffer outside the lock, then enqueue under the lock. Or use a mutex instead of spinlock for the write path.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-435",
    "title": "Unbounded Pending Path Challenges",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, correctness."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path\" \"net/tquic/core/connection.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Limit pending challenges to a reasonable maximum (e.g., 10).\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-436",
    "title": "Version Negotiation Packet Not Authenticated",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Check that the VN version list does NOT contain the version the client originally tried.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-439",
    "title": "AMP-1: The anti-amplification check uses `atomic64` operations for `bytes_received` and `bytes_sent`, but the check-then-add pattern is not atomic as a whole:",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:1, snippet:3",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "sed -n '271,271p' net/quic/tquic/tquic_migration.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `atomic64_add_return` to atomically check-and-add, or serialize under a spinlock Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-440",
    "title": "asn1_get_length Does Not Handle Length 0x84+",
    "category": "security",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:2, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "sed -n '186,186p' net/tquic/crypto/cert_verify.c",
      "sed -n '155,155p' net/tquic/crypto/cert_verify.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-441",
    "title": "Coalesced Packet Processing Silently Truncates on Overflow",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:1, snippet:2",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "sed -n '3172,3173p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Instead of silently truncating, reject the coalesced packet entirely when the claimed length exceeds remaining data:\n```c\nif (offset + pkt_len > total_len)\n    break;  /* Malformed coalesced packet -- stop */\n``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-442",
    "title": "conn->data_sent Underflow on Error Path",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:4, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "sed -n '1008,1015p' net/quic/tquic/tquic_netlink.c",
      "sed -n '993,993p' net/quic/tquic/tquic_netlink.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-443",
    "title": "CPU-2: FEC decoder block search is a linear list walk.",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:1, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "sed -n '285,285p' net/quic/tquic/fec/fec_decoder.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a bitmap or hash set for symbol ID dedup within blocks Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-444",
    "title": "EDF Scheduler edf_select_path Called Without Lock",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:3, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"edf_select_path\" \"net/tquic/sched/deadline_scheduler.c\"",
      "sed -n '591,591p' net/tquic/sched/deadline_scheduler.c",
      "sed -n '594,594p' net/tquic/sched/deadline_scheduler.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/sched/deadline_scheduler.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-445",
    "title": "ktime_get_ts64 Written to skb->cb May Exceed cb Size",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"timespec64\" \"net/tquic/tquic_input.c\"",
      "sed -n '1471,1471p' net/tquic/tquic_input.c",
      "sed -n '951,951p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a typed union or dedicated struct for `skb->cb` usage, documented per frame type. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-446",
    "title": "MP Frame Type Range Check Too Broad",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:4, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "sed -n '1623,1623p' net/quic/tquic/tquic_input.c",
      "sed -n '1652,1652p' net/quic/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-447",
    "title": "tquic_fc_stream_can_send Missing Overflow Check",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_fc_stream_can_send\" \"net/quic/tquic/core/flow_control.c\"",
      "sed -n '291,292p' net/quic/tquic/core/flow_control.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-448",
    "title": "TQUIC_IDLE_TIMEOUT Missing Range Validation",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:1, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "sed -n '768,768p' net/quic/tquic/tquic_socket.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-449",
    "title": "TQUIC_PSK_IDENTITY Off-by-One Potential",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:2, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "sed -n '942,942p' net/quic/tquic/tquic_socket.c",
      "sed -n '942,951p' net/quic/tquic/tquic_socket.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-450",
    "title": "tquic_recv_datagram Can Loop Forever Under Signal Pressure",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_recv_datagram\" \"net/tquic/tquic_output.c\"",
      "sed -n '2706,2743p' net/tquic/tquic_output.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a retry counter to prevent excessive looping:\n```c\nint retries = 0;\n...\nretry:\n    if (++retries > 3) return -EAGAIN;\n``` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-451",
    "title": "TQUIC_SCHEDULER Race on tquic_sched_find",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:6, lines:4, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_sched_ops\" \"net/quic/tquic/tquic_socket.c\"",
      "sed -n '848,848p' net/quic/tquic/tquic_socket.c",
      "sed -n '848,872p' net/quic/tquic/tquic_socket.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-452",
    "title": "UAF-P5-02: - Path list uses RCU but active_path does not",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"rcu_assign_pointer\" \"net/tquic/tquic_migration.c\"",
      "sed -n '848,848p' net/tquic/tquic_migration.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-453",
    "title": "Version Negotiation Versions Logged Without Rate Limiting",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_dbg\" \"net/tquic/tquic_input.c\"",
      "sed -n '473,477p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Either remove the per-version debug line or cap the number of logged versions. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-329",
    "title": "WebTransport: TOCTOU in Datagram Queue Push",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Perform the size check and push atomically under a lock, or use an atomic counter with compare-and-swap. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/webtransport.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-354",
    "title": "Anti-Replay Hash Table Cleanup Iterates All Buckets Under spinlock",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, correctness."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a separate periodic cleanup timer rather than inline cleanup, or maintain a time-ordered list for efficient expiration. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/early_data.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-382",
    "title": "Interop Framework - Same Pattern",
    "category": "tests",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, tests."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/test/interop/interop_framework.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-406",
    "title": "Per-path stats updated from both RX and TX",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, perf."
    ],
    "key_evidence_present": "sym:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_input\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Split path stats into `____cacheline_aligned` RX and TX sections, or use per-CPU counters for path stats. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-437",
    "title": "WebTransport Session Refcount Not Checked After Accept",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "high",
    "priority_score": 4.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, other."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/http3/webtransport.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Audit all callers of session-returning functions and ensure every get has a matching put.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/webtransport.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-455",
    "title": "0-RTT Encrypt Allocates AEAD Per-Packet",
    "category": "security",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-458",
    "title": "Alpha Precision Loss in Coupled CC",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"mul_u64_u64_div\" \"net/tquic/bond/cong_coupled.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/cong_coupled.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-460",
    "title": "AMP-3: The MASQUE CONNECT-UDP tunnel implementation in `masque/connect_udp.c` creates UDP sockets to forward proxied traffic. There is **no visible limit on the number of tunnels per connection or per",
    "category": "security",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "sed -n '374,374p' net/quic/tquic/masque/connect_udp.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add per-connection and per-client tunnel limits (e.g., max 16 tunnels per connection) Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-461",
    "title": "Anti-Amplification Check Has TOCTOU Race",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path_anti_amplification_sent\" \"net/tquic/tquic_migration.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-464",
    "title": "Deadline Scheduler in_flight Underflow",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "sed -n '299,299p' net/tquic/sched/deadline_aware.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-465",
    "title": "Division Safety in Congestion Data Validation",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cong_data_on_ack\" \"net/tquic/cong/cong_data.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/cong/cong_data.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/cong/cong_data.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-468",
    "title": "h3_parse_settings_frame u64 to Pointer Cast",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"h3_parse_settings_frame\" \"net/quic/tquic/http3/http3_frame.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_frame.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-470",
    "title": "HMAC Stack Buffer Size",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cong_data_compute_hmac\" \"net/tquic/cong/cong_data.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/cong/cong_data.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/cong/cong_data.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-471",
    "title": "In-Flight Calculation Signed Arithmetic",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_calc_path_quality\" \"net/tquic/bond/bonding.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/bonding.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-474",
    "title": "Loss Rate Cast Overflow",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"update_loss_rate\" \"net/tquic/fec/fec_scheduler.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/fec/fec_scheduler.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-475",
    "title": "MEM-1: `tquic_handshake.c` lines 605 and 1136 allocate skbs based on computed handshake message lengths (`ch_len`, `resp_len`). While these are internally computed (not directly from network), a malfo",
    "category": "security",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:5",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_handshake\" \"net/quic/tquic/tquic_handshake.c\"",
      "sed -n '605,605p' net/quic/tquic/tquic_handshake.c",
      "sed -n '963,963p' net/quic/tquic/tquic_handshake.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Enforce a hard cap on `ch_len` and `resp_len` (e.g., 16KB max for any single handshake message) Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-476",
    "title": "Nested Locking in Repair Reception",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_fec_receive_repair\" \"net/tquic/fec/fec_decoder.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/fec/fec_decoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/fec/fec_decoder.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-477",
    "title": "Path Creation Uses static atomic_t for path_id -- Not Per-Connection",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_migration\" \"net/tquic/tquic_migration.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-481",
    "title": "Reorder Buffer Sequence in skb->cb Alignment",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:5, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"put_unaligned\" \"net/tquic/bond/bonding.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/bonding.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-482",
    "title": "sched/scheduler.c Debug Logging Leaks Kernel Pointers",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_sched_default\" \"net/tquic/sched/scheduler.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/sched/scheduler.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-484",
    "title": "Sort Modifies Caller's Lost Packets Array",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_lost_packet\" \"net/tquic/cong/persistent_cong.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/cong/persistent_cong.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-487",
    "title": "tquic_main.c init/exit -- conditional cleanup mismatch for NAPI/io_uring",
    "category": "api",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:6, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_napi_subsys_exit\" \"net/quic/tquic/tquic_main.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_main.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-491",
    "title": "UAF-ADD-01: - tquic_tunnel_close does not cancel forward_work for tproxy tunnels",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_tunnel_create_tproxy\" \"net/tquic/tquic_tunnel.c\"",
      "sed -n '592,592p' net/tquic/tquic_tunnel.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_tunnel.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-492",
    "title": "UAF-P3-05: - GRO flush_timer can fire after kfree",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"hrtimer_cancel\" \"net/tquic/tquic_input.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_input.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-493",
    "title": "UAF-P4-03: - Double destruction path for connections",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:6, lines:3",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_net_close_all_connections\" \"net/tquic/tquic_proto.c\"",
      "sed -n '171,171p' net/tquic/tquic_proto.c",
      "sed -n '1082,1160p' net/tquic/tquic_proto.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_proto.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-494",
    "title": "UAF-P5-01: - Correct RCU usage in tquic_nf.c",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:5, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"call_rcu\" \"net/tquic/tquic_nf.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_nf.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_nf.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-495",
    "title": "UAF-P6-02: - tquic_zerocopy_complete callback chain",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:4, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"sk_buff\" \"net/tquic/tquic_zerocopy.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_zerocopy.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_zerocopy.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-499",
    "title": "XDP Uses capable",
    "category": "security",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/af_xdp.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-456",
    "title": "0-RTT Encrypt Allocates AEAD Per-Packet (Performance / Side Channel)",
    "category": "security",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_zero_rtt_keys\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Allocate the AEAD transform once during key derivation and store it in `tquic_zero_rtt_keys`. Reuse for all packets.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-457",
    "title": "All MP Scheduler init() Functions Silently Fail on OOM",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:8",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"aggregate_init\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-459",
    "title": "AMP-2: The `tquic_path_handle_challenge` function in `pm/path_validation.c:249` does not check anti-amplification limits before queuing the PATH_RESPONSE. Per RFC 9000 Section 8.1, data sent on unvali",
    "category": "security",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path_handle_challenge\" \"net/quic/tquic/pm/path_validation.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Check `tquic_path_anti_amplification_check` before queuing response; charge response bytes to `bytes_sent` Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/pm/path_validation.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-462",
    "title": "asn1_get_length Does Not Handle Length 0x84+ (4+ byte lengths)",
    "category": "security",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-463",
    "title": "Coalesced Packet Processing Silently Truncates on Overflow (tquic_input.c, lines 3172-3173)",
    "category": "other",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1, snippet:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_input\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Instead of silently truncating, reject the coalesced packet entirely when the claimed length exceeds remaining data:\n```c\nif (offset + pkt_len > total_len)\n    break;  /* Malformed coalesced packet -- stop */\n``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-466",
    "title": "Duplicate ECF Path State Allocation Race",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/multipath/sched_ecf.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-467",
    "title": "ECN State Tracking Per-Round Limitation",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on severity: Severity disagreement across reports: S2, S3."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cong\" \"net/tquic/cong/tquic_cong.h\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/cong/tquic_cong.h where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-469",
    "title": "h3_parser_advance Missing Bounds Check",
    "category": "memory",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"h3_parser_advance\" \"net/quic/tquic/http3/http3_frame.h\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/http3/http3_frame.h\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_frame.h where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-472",
    "title": "ktime_get_ts64 Written to skb->cb May Exceed cb Size (tquic_input.c, line 1471)",
    "category": "other",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_input\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a typed union or dedicated struct for `skb->cb` usage, documented per frame type.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-473",
    "title": "Lock Ordering Between Encoder and Scheduler",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_fec_should_send_repair\" \"net/tquic/fec/fec_scheduler.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/fec/fec_scheduler.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/fec/fec_scheduler.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-478",
    "title": "Path Manager discover_addresses Holds rtnl_lock While Accessing inet6_dev",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"rtnl_lock\" \"net/tquic/pm/path_manager.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/pm/path_manager.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/pm/path_manager.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-479",
    "title": "Priority State No Limit on stream_count",
    "category": "api",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_priority.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-480",
    "title": "Push Entry Count O(n) Iteration",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_conn.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-483",
    "title": "sched/scheduler.c ECF Loss Rate Division by Zero",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/sched/scheduler.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-485",
    "title": "STATE-1: The transition to \"attack mode\" (TQUIC_RL_COOKIE_REQUIRED) appears to be reactive -- it triggers when rate limits are exceeded. During the ramp-up period before attack mode activates, an atta",
    "category": "security",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Consider proactive cookie validation when pre-handshake memory exceeds 50% of budget, independent of rate limit triggers Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/rate_limit.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-486",
    "title": "tquic_gro_flush Drops and Re-acquires Lock Per Packet (tquic_input.c, lines 2303-2310)",
    "category": "other",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_gro_flush\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "After the loop, set `held_count = skb_queue_len(&gro->hold_queue)`.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-488",
    "title": "tquic_main.c init/exit -- conditional cleanup mismatch for NAPI/io_uring",
    "category": "other",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_main\" \"err_netlink:\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-489",
    "title": "tquic_recv_datagram Can Loop Forever Under Signal Pressure (tquic_output.c, lines 2706-2743)",
    "category": "other",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, snippet:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_recv_datagram\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a retry counter to prevent excessive looping:\n```c\nint retries = 0;\n... Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-490",
    "title": "Triplicated Varint Encode/Decode Implementations",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_frame.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-496",
    "title": "Version Negotiation Versions Logged Without Rate Limiting (tquic_input.c, lines 473-477)",
    "category": "other",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_input\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Either remove the per-version debug line or cap the number of logged versions.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-497",
    "title": "WebTransport Datagram Queue Double-Checked Locking Anti-Pattern",
    "category": "concurrency",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/webtransport.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-498",
    "title": "Weighted Scheduler Weight Not Validated",
    "category": "correctness",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/multipath/sched_weighted.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-500",
    "title": "XDP Uses capable() Instead of ns_capable()",
    "category": "other",
    "severity": "S2",
    "original_confidence": "medium",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-454",
    "title": "CROSS-1: The systematic use of `jhash` with seed 0 across 15+ call sites creates a coordinated attack vector. An attacker who can determine CID values and IP addresses can craft inputs that degrade:",
    "category": "security",
    "severity": "S1",
    "original_confidence": "low",
    "priority_score": 2.8,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "REJECTED",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "NONE",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-501",
    "title": "Batch Crypto Allocates Per-Packet Temporary Buffer",
    "category": "perf",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, perf, security."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_crypto_batch_encrypt\" \"net/tquic/crypto/hw_offload.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Perform in-place encryption if the caller's buffer has sufficient space (the `data_buf_len` check already exists), or pre-allocate a shared temporary buffer. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/hw_offload.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-502",
    "title": "Certificate Chain Length Limit Checked Late",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:17, sym:11",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"csprng\" \"net/tquic/crypto/cert_verify.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Move the chain length check to the beginning of the loop iteration. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-503",
    "title": "Duplicate MODULE_DESCRIPTION in quic_exfil.c",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: build, other, security."
    ],
    "key_evidence_present": "file:1, sym:6, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"module_author\" \"net/tquic/security/quic_exfil.c\"",
      "sed -n '1684,1686p' net/tquic/security/quic_exfil.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-504",
    "title": "Duplicate Static Functions: h3_varint_encode/decode",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:2, sym:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"h3_varint_decode\" \"net/tquic/http3/http3_request.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Move to a shared helper (e.g., in `http3_frame.c` or a common header as inline functions). Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/http3_request.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-506",
    "title": "Key Update Timeout Revert Could Race With Concurrent Update",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"inconsistent\" \"net/tquic/crypto/key_update.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/crypto/key_update.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a generation counter or sequence number to the key update so the timeout handler can detect if a response arrived between the timeout firing and the lock acquisition. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/key_update.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-507",
    "title": "Load Balancer Stack Buffers for Feistel Not Zeroized on Error",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, sym:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"memzero_explicit\" \"net/tquic/lb/quic_lb.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/lb/quic_lb.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-508",
    "title": "Module Parameters Expose Security Configuration",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cert_verify_mode\" \"net/tquic/crypto/cert_verify.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Log a prominent warning when verification mode is set to NONE. Consider requiring a special flag to disable verification in production builds. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-510",
    "title": "Netlink Family Exported as EXPORT_SYMBOL_GPL",
    "category": "memory",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory, security."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"export_symbol_gpl\" \"net/tquic/tquic_netlink.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_netlink.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-511",
    "title": "Per-CPU Stats Not Protected Against Torn Reads on 32-bit",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"read_once\" \"net/tquic/crypto/hw_offload.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `u64_stats_sync` infrastructure for proper 64-bit stats on 32-bit architectures. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/hw_offload.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-512",
    "title": "Procfs trusted_cas File Writable Without Capability Check",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:4",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"capable\" \"net/tquic/crypto/cert_verify.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `capable(CAP_NET_ADMIN)` check at the start of `tquic_proc_trusted_cas_write()`. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-513",
    "title": "Qlog: Lock Drop Around copy_to_user",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"behavior\" \"net/tquic/diag/qlog.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/diag/qlog.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Copy the entry to a local kernel buffer under the lock, then `copy_to_user` from the local buffer. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/diag/qlog.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-514",
    "title": "Unused HKDF-Expand Output in Extended Key Update",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_eku_derive_keys\" \"net/tquic/crypto/extended_key_update.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Actually use the `mixed_secret` as input to the subsequent key derivation rather than the standard derivation path. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/extended_key_update.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-515",
    "title": "Volatile Qualifiers in Constant-Time Functions May Be Insufficient",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"crypto_memneq\" \"net/tquic/security/quic_exfil.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-538",
    "title": "crypto_wait_req May Sleep in Encrypt/Decrypt Hot Path",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:2, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '637,637p' net/tquic/crypto/tls.c",
      "sed -n '694,694p' net/tquic/crypto/tls.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Ensure the encrypt/decrypt paths are only called from process context\n(e.g., in a workqueue), or use async completion callbacks instead of\n`crypto_wait_req`.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-551",
    "title": "Multipath Nonce Construction -- Potential Nonce Reuse Across Paths",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, lines:5, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_crypto_ctx_destroy\" \"net/tquic/crypto/tls.c\"",
      "sed -n '392,423p' net/tquic/crypto/tls.c",
      "sed -n '645,645p' net/tquic/crypto/tls.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Verify that path_id allocation is monotonically increasing per\nconnection and never reuses IDs within a key phase. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-553",
    "title": "Netlink Operations All Require GENL_ADMIN_PERM",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_netlink\" \"net/tquic/tquic_netlink.c\"",
      "sed -n '274,274p' net/tquic/tquic_netlink.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-558",
    "title": "Redundant Lock in tquic_bonding_get_state",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:2, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_bonding_get_state\" \"net/quic/tquic/bond/tquic_bonding.c\"",
      "sed -n '526,526p' net/quic/tquic/bond/tquic_bonding.c",
      "sed -n '899,899p' net/quic/tquic/bond/tquic_bonding.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/bond/tquic_bonding.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-564",
    "title": "Stream ID Right-Shift Comparison",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream\" \"net/quic/tquic/tquic_stream.c\"",
      "sed -n '1409,1410p' net/quic/tquic/tquic_stream.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-566",
    "title": "tquic_ipv6.c MTU Info getsockopt",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "CERTIFIED",
    "confidence_after_judging": "high",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, sym:2, lines:5, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"copies\" \"net/quic/tquic/tquic_ipv6.c\"",
      "sed -n '171,211p' net/quic/tquic/tquic_ipv6.c",
      "sed -n '226,227p' net/quic/tquic/tquic_ipv6.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-516",
    "title": "`established_time` Set Twice in Connection State Machine",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"ktime_get\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Only set it in CONNECTED, or rename the CONNECTING one to `handshake_start_time`. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-517",
    "title": "`sk->sk_err = -ret` Stores Negative Error Code",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_socket\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a comment: `/* ret is negative errno, sk_err needs positive */` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-518",
    "title": "`tquic_cid_compare()` Marked `__maybe_unused`",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cid_compare\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Remove if truly unused, or remove the `__maybe_unused` annotation. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-519",
    "title": "`tquic_cid_retire()` Sends RETIRE_CONNECTION_ID After Retirement",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:11, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"release_sock\" \"net/tquic/tquic_cid.c\"",
      "sed -n '516,516p' net/tquic/tquic_cid.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-520",
    "title": "`tquic_debug.c` CID Hex Loop Bound",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_debug\" \"net/quic/tquic/tquic_debug.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_debug.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-521",
    "title": "`tquic_hs_cleanup` -- does not zeroize exporter_secret and resumption_secret",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_cleanup\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `memzero_explicit` calls for all remaining sensitive fields.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-522",
    "title": "`tquic_hs_generate_client_hello` -- client random not checked for all-zero",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"get_random_bytes\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-523",
    "title": "`tquic_hs_get_handshake_secrets` and `tquic_hs_get_app_secrets` -- no output buffer size validation",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_get_handshake_secrets\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Document the minimum buffer size requirement or add a `buf_len` parameter.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-524",
    "title": "`tquic_hs_process_certificate_verify` hardcodes \"server CertificateVerify\" string",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hs_process_certificate_verify\" \"net/tquic/crypto/handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `hs->is_server ? \"TLS 1.3, client CertificateVerify\" : \"TLS 1.3, server CertificateVerify\"`.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/handshake.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-525",
    "title": "`tquic_hs_process_new_session_ticket` -- ignores extensions",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Snippet(s) contain only comments, not actual vulnerable code.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "file:1, sym:5, lines:5",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"crypto_memneq\" \"net/tquic/crypto/handshake.c\"",
      "sed -n '1076,1253p' net/tquic/crypto/handshake.c",
      "sed -n '735,809p' net/tquic/crypto/handshake.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-526",
    "title": "`tquic_server_check_path_recovery()` Uses `goto restart` Pattern",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:3",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path_start_validation\" \"net/tquic/tquic_migration.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_migration.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_migration.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-527",
    "title": "`tquic_store_session_ticket()` Does Not Store ALPN or Transport Parameters",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_store_session_ticket\" \"net/tquic/tquic_handshake.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Populate `plaintext.alpn` and `plaintext.transport_params` from the connection state when storing session tickets. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_handshake.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-528",
    "title": "`tquic_sysctl_prefer_v2()` Function Not Declared in Visible Header",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_sysctl_prefer_v2\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a proper declaration in a shared header file. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-529",
    "title": "AF_XDP frame pool uses spinlock for every frame alloc/free",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:2, sym:1, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"buffer\" \"net/tquic/af_xdp.c\"",
      "sed -n '222,238p' net/tquic/af_xdp.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/af_xdp.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a lockless ring buffer (SPSC or MPSC depending on usage pattern) for the free list, similar to how io_uring and XDP use lockless rings. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-530",
    "title": "bench/benchmark.c -- kvmalloc used correctly with kvfree",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:2, sym:2, lines:2",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"free\" \"net/quic/tquic/fec/fec_encoder.c\"",
      "sed -n '349,350p' net/quic/tquic/fec/fec_encoder.c",
      "sed -n '341,342p' net/quic/tquic/fec/fec_encoder.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-531",
    "title": "Benchmark Code: Userspace, Not Kernel",
    "category": "memory",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: build, memory."
    ],
    "key_evidence_present": "file:2, sym:12",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"apis\" \"net/tquic/bench/bench_common.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/bench/bench_common.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Consider moving benchmark code to a `tools/` or `tests/` directory to avoid confusion about its execution context. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bench/bench_common.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-532",
    "title": "CID Table Initialization Not Thread-Safe",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cid\" \"net/tquic/tquic_cid.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_cid.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_cid.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-533",
    "title": "close_work Repurposes drain_work for Retransmit Scheduling",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"work_struct\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use a separate delayed_work for close retransmission.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-535",
    "title": "Constant-Time Comparison Used for Integrity Tags",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_retry\" \"net/quic/tquic/tquic_retry.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_retry.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-536",
    "title": "Context Set Level Does Not Check init Return Values",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:7, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_exfil_ctx_set_level\" \"net/tquic/security/quic_exfil.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Check return values and either revert to the previous level or mark the context as failed.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-537",
    "title": "CRYPTO_TFM_REQ_MAY_BACKLOG in Atomic Context",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:3, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_hp_mask_aes\" \"net/tquic/crypto/header_protection.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/crypto/header_protection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Either (a) ensure callers never hold spinlocks when calling HP mask\ngeneration, or (b) use `CRYPTO_TFM_REQ_MAY_SLEEP` only when in process context\nand remove `MAY_BACKLOG` in atomic context, or (c) document the sleeping\nrequirement clearly.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/header_protection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-540",
    "title": "h3_varint_len Defined Multiple Times as Static",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"h3_varint_len\" \"net/quic/tquic/http3/http3_request.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_request.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-541",
    "title": "HMAC Output Not Zeroized on Fallback Path",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `memzero_explicit(hmac_out, sizeof(hmac_out));` before `goto fallback`.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-542",
    "title": "Inconsistent Error Return From verify_chain",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, line range.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "sed -n '2332,2332p' net/tquic/crypto/cert_verify.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-544",
    "title": "Lock Drop/Re-acquire Pattern in Key Derivation",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, security."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_ku_derive_next_generation\" \"net/tquic/crypto/key_update.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/crypto/key_update.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Pass `hash_tfm` as a separate parameter copied under the lock, rather\nthan passing the entire state.\n\n--- Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/key_update.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-545",
    "title": "LOW: pacing_calc_gap uses division",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, perf."
    ],
    "key_evidence_present": "file:2, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_output\" \"net/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Pre-compute `ns_per_byte = NSEC_PER_SEC Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_output.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-546",
    "title": "LOW: Prague RTT scaling division on every ACK",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "Sources disagree on category: Category disagreement across reports: correctness, perf."
    ],
    "key_evidence_present": "file:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Pre-compute a reciprocal multiplier for the RTT target to replace division with multiplication + shift. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/cong/prague.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-547",
    "title": "memzero_explicit Used Correctly for Key Material",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=symbol, line range.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: memory, security."
    ],
    "key_evidence_present": "sym:2, lines:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_retry\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-548",
    "title": "Minimal tracepoint overhead",
    "category": "memory",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:7",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"recommendations\" \"net/tquic/diag/trace.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/diag/trace.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/diag/trace.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-550",
    "title": "Missing lockdep Annotations",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "sym:3, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -rn \"lockdep_assert_held\" net/tquic/",
      "rg -rn \"spin_lock\\|mutex_lock\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `lockdep_assert_held(&conn->lock)` at the beginning of functions that require `conn->lock` to be held. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-554",
    "title": "nla_put Operations in Netlink Properly Handle Failure",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_netlink\" \"net/quic/tquic/tquic_netlink.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_netlink.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-555",
    "title": "parse_basic_constraints Hardcoded BOOLEAN Length",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-556",
    "title": "Path Validation Response Queue Uses Two Tracking Mechanisms",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"skb_queue_len\" \"net/tquic/pm/path_validation.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/pm/path_validation.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use only one mechanism. `skb_queue_len()` is already atomic and thread-safe. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/pm/path_validation.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-557",
    "title": "quic_exfil.c Decoy Packet Size Controlled by MTU",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"quic_exfil\" \"net/quic/tquic/security/quic_exfil.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/security/quic_exfil.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-559",
    "title": "Retry Integrity Tag Computed with Potentially-Failing AEAD",
    "category": "memory",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Return an error if the integrity tag cannot be computed rather than sending a tagless packet.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-560",
    "title": "SAN Parsing Capacity Limit Check Could Be Tighter",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Reduce limit to 1000 or add a total allocation size limit. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/cert_verify.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-561",
    "title": "Scheduler Lock Uses spin_lock Without _bh",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"spin_lock\" \"net/quic/tquic/sched/scheduler.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/sched/scheduler.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/sched/scheduler.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-562",
    "title": "server_ticket_key Is Static Global Without Rotation",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Implement periodic key rotation (e.g., every 24 hours) with support for decrypting tickets encrypted with the previous key.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-563",
    "title": "Slab Cache Names Are Not Module-Prefixed",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_ext\" \"net/tquic/core/stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use names like `\"tquic_core_stream_ext\"` for clarity. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/stream.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-565",
    "title": "tquic_conn_destroy -- thorough cleanup",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_conn_destroy\" \"net/quic/tquic/core/quic_connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/core/quic_connection.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-567",
    "title": "tquic_main.c init -- correct cascading cleanup",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_exit\" \"net/quic/tquic/tquic_main.c\"",
      "sed -n '1198,1198p' net/quic/tquic/tquic_main.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-568",
    "title": "tquic_output_flush Holds conn->lock While Calling GFP_ATOMIC Allocation",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:7, lines:5",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_encap_recv\" \"net/tquic/tquic_output.c\"",
      "sed -n '2071,2117p' net/tquic/tquic_output.c",
      "sed -n '2071,2071p' net/tquic/tquic_output.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Consider pre-allocating frame structures outside the lock, or batching frame preparation. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-569",
    "title": "tquic_pacing_cleanup -- correct ordering",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_pacing_cleanup\" \"net/quic/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_output.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-570",
    "title": "tquic_retry_rate_limit Potential Token Bucket Underflow",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_retry_rate_limit\" \"net/quic/tquic/tquic_retry.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_retry.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-571",
    "title": "tquic_stream_manager_destroy Does Not Free Extended State for All Streams",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:22, sym:4",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_manager_destroy\" \"net/quic/tquic/http3/http3_conn.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_conn.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-572",
    "title": "tquic_timer_state_alloc -- cleanup loop is correct",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_timer_state_alloc\" \"net/quic/tquic/tquic_timer.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_timer.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-573",
    "title": "tquic_timer_state_free -- thorough and correct",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: concurrency, other."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_timer_state_free\" \"net/quic/tquic/tquic_timer.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_timer.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_timer.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-574",
    "title": "Version Negotiation First Byte Missing Fixed Bit Randomization",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Snippet(s) contain only comments, not actual vulnerable code.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"get_random_u8\" \"net/tquic/core/connection.c\"",
      "sed -n '807,807p' net/tquic/core/connection.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-576",
    "title": "Version Negotiation Response - dcid/scid_len Not Capped",
    "category": "memory",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_input\" \"net/quic/tquic/tquic_input.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/tquic_input.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_input.c where the fault occurs.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-577",
    "title": "Workqueue Not Validated Before Use",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "file:1, sym:4",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"tquic_validate_target_address\" \"net/tquic/security/quic_exfil.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "If `exfil_wq` is NULL, either send the packet immediately (bypassing timing normalization) or return an error so the caller can handle it. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/security/quic_exfil.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-579",
    "title": "`bench_latency.c` Allocation Without Overflow Check",
    "category": "perf",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:1, lines:4, snippet:3",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_bench_latency\" \"net/quic/tquic/bench/tquic_bench_latency.c\"",
      "sed -n '980,980p' net/quic/tquic/bench/tquic_bench_latency.c",
      "sed -n '840,840p' net/quic/tquic/bench/tquic_bench_latency.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-580",
    "title": "CPU-3: CID pool active count enumeration.",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cid\" \"net/quic/tquic/tquic_cid.c\"",
      "sed -n '617,617p' net/quic/tquic/tquic_cid.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_cid.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Maintain running `active_count` counter to avoid list traversal Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-581",
    "title": "spin_lock",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:2, snippet:1",
    "whats_missing": [
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "sed -n '1015,1017p' net/tquic/tquic_input.c",
      "sed -n '251,251p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Change to `spin_lock_bh(&ctx->conn->lock)`. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-582",
    "title": "tquic_build_short_header_internal Writes pkt_num to buf+64 Scratch Space",
    "category": "build",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:4, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_build_short_header_internal\" \"net/tquic/tquic_output.c\"",
      "sed -n '818,818p' net/tquic/tquic_output.c",
      "sed -n '1915,1915p' net/tquic/tquic_output.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Allocate a separate scratch buffer or use a function-local buffer:\n```c\nu8 pn_scratch[4];\npkt_num_len = tquic_encode_pkt_num(pn_scratch, pkt_num, largest_acked);\n``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-583",
    "title": "tquic_gso_init Integer Overflow in Allocation Size",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:1, snippet:2",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_gso_init\" \"net/tquic/tquic_output.c\"",
      "sed -n '1489,1489p' net/tquic/tquic_output.c",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_output.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `size_t` arithmetic with overflow checking:\n```c\nsize_t alloc_size;\nif (check_mul_overflow((size_t)gso->gso_size, (size_t)max_segs, &alloc_size))\n    return -EINVAL;\n``` Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-584",
    "title": "UAF-ADD-02: - CID pool rotation_work vs pool destruction race window",
    "category": "memory",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 4/5: file path, symbol, line range, snippet, and/or log all present.",
      "Single-source finding (source B); no independent confirmation.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, lines:5, snippet:1",
    "whats_missing": [
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source"
    ],
    "minimal_verification": [
      "rg -n \"tquic_cid\" \"net/tquic/tquic_cid.c\"",
      "sed -n '980,1180p' net/tquic/tquic_cid.c",
      "sed -n '480,1170p' net/tquic/tquic_cid.c",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/tquic_cid.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-505",
    "title": "HTTP/3 Priority: push_buckets Not Initialized",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other, perf."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Explicitly initialize `push_buckets[]` in the priority init function for defensive coding. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/http3/http3_priority.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-509",
    "title": "Netlink Events Do Not Include Timestamp",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 3,
    "sources": [
      "A",
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "All 3 audit sources (A, B, C) independently flagged this issue.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, security."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-534",
    "title": "Consistent use of kfree_sensitive for key material -- GOOD",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: other, security."
    ],
    "key_evidence_present": "sym:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_server\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-539",
    "title": "Empty Hash Computed Without Algorithm Validation",
    "category": "security",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Zero-initialize `empty_hash` or use `memzero_explicit` after use.\n\n--- Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/crypto/zero_rtt.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-543",
    "title": "io_uring.c getsockopt Same len Validation Pattern",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/io_uring.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-549",
    "title": "Missing Error Check for init_net Reference",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, other."
    ],
    "key_evidence_present": "sym:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_tunnel\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Store the network namespace reference at module load time and add a helper function that returns the appropriate namespace.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-552",
    "title": "Multiple Redundant Varint Implementations",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "sym:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_input\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Consolidate to a single implementation in `varint.c`/`varint.h` and use it everywhere. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-575",
    "title": "Version Negotiation Packet Size Not Validated Against 256-Byte Buffer",
    "category": "memory",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "B",
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (B, C) agree; partial independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Sources disagree on category: Category disagreement across reports: correctness, memory."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/core/connection.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add a bounds check or use the `p - packet < sizeof(packet)` idiom. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/core/connection.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-578",
    "title": "XOR FEC encoding is efficient",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "high",
    "priority_score": 1.0,
    "source_count": 2,
    "sources": [
      "A",
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "2 of 3 sources (A, B) agree; partial independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "sym:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue"
    ],
    "minimal_verification": [
      "rg -rn \"scheme\" net/tquic/",
      "rg -rn \"spin_lock\\|mutex_lock\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Missing fix suggestion in source text. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-585",
    "title": "`bench_common.c` Variance Calculation",
    "category": "tests",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/bench/bench_common.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-589",
    "title": "`tquic_sock_listen()` Redundant `INIT_LIST_HEAD` Check",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_sock_listen\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-590",
    "title": "`tquic_stateless_reset_detect()` Iterates All Tokens Non-Constant-Time",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stateless_reset_detect\" \"net/tquic/tquic_stateless_reset.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_stateless_reset.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-593",
    "title": "BPM Path Metrics min_rtt Initialized to UINT_MAX",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_bpm\" \"net/tquic/bond/tquic_bpm.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/tquic_bpm.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-598",
    "title": "CPU-6: The QPACK decoder accepts a `max_table_capacity` parameter from the peer via SETTINGS. While the sysctl caps the local maximum at 1MB, the actual limit used should be `min(peer_requested, local",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_path\" \"net/quic/tquic/http3/qpack_decoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Audit SETTINGS parsing to confirm capacity is clamped Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/qpack_decoder.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-601",
    "title": "Failover Sent Packet Count Can Go Negative",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_failover\" \"net/tquic/bond/tquic_failover.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/bond/tquic_failover.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/tquic_failover.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-603",
    "title": "MEM-3: The NF connection tracking limit (65536) has no per-source-IP limit at the netfilter layer. While the TQUIC protocol layer has per-IP limits, the NF `tquic_nf_conn_alloc` at line 497 only check",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:3, lines:2",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_open_incoming\" \"net/quic/tquic/tquic_nf.c\"",
      "sed -n '497,497p' net/quic/tquic/tquic_nf.c",
      "sed -n '634,648p' net/quic/tquic/tquic_nf.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add per-IP NF tracking limit (e.g., 256 entries per source IP) Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-606",
    "title": "Multicast Group Only Requires CAP_NET_ADMIN",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=symbol, line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, lines:5, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_cid_security_check_new_cid\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-608",
    "title": "Multiple Varint Implementations",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:10, sym:2, lines:5",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_input\" \"net/quic/tquic/crypto/extended_key_update.c\"",
      "sed -n '171,171p' net/quic/tquic/crypto/extended_key_update.c",
      "sed -n '49,131p' net/quic/tquic/crypto/extended_key_update.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-609",
    "title": "Netlink Attribute Policy Does Not Use Strict Validation for Binary Addresses",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:6, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"nla_len\" \"net/tquic/tquic_netlink.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_netlink.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-612",
    "title": "Priority Extension Allocation Race",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 2/5: present=file, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/core/priority.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-622",
    "title": "Stream Creation Not Bounded in Input Path",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=symbol, line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, lines:2, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_stream_open_incoming\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-623",
    "title": "timer_setup with NULL Callback",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "sed -n '102,117p' net/tquic/sched/deadline_aware.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-626",
    "title": "tquic_encode_varint Does Not Validate val Range",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_encode_varint\" \"net/tquic/tquic_output.c\"",
      "sed -n '164,198p' net/tquic/tquic_output.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add validation: `if (val >= (1ULL << 62)) return -EINVAL;` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-629",
    "title": "tquic_process_ack_frame Does Not Validate largest_ack vs first_ack_range",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_process_ack_frame\" \"net/tquic/tquic_input.c\"",
      "sed -n '601,660p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add: `if (first_ack_range > largest_ack) return -EINVAL;` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-631",
    "title": "tquic_process_coalesced Missing Infinite Loop Guard",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:2",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_process_coalesced\" \"net/tquic/tquic_input.c\"",
      "sed -n '3079,3182p' net/tquic/tquic_input.c",
      "sed -n '3169,3169p' net/tquic/tquic_input.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `if (packets > 16) break;` to cap coalesced packets. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-635",
    "title": "tquic_stream_release Missing Error Return",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 3/5: present=file, symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, lines:1",
    "whats_missing": [
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_release\" \"net/quic/tquic/tquic_stream.c\"",
      "sed -n '643,643p' net/quic/tquic/tquic_stream.c",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-636",
    "title": "tquic_stream_set_priority Missing Lock Protection",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "PLAUSIBLE",
    "confidence_after_judging": "medium",
    "reason": [
      "Evidence score 3/5: present=file, symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2, snippet:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream\" \"net/quic/tquic/core/stream.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/core/stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/core/stream.c where the fault occurs.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-586",
    "title": "`bench_common.c` Variance Calculation (Userspace Code)",
    "category": "other",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-587",
    "title": "`bench_latency.c` Allocation Without Overflow Check (Userspace Code)",
    "category": "other",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "snippet:4",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Validate before truncation:\n```c\nif (val > U8_MAX)\n    return -EINVAL;\ndata->flags = (u8)val;\n``` Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-588",
    "title": "`tquic_accept()` Nested Locking Pattern",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_accept\" \"net/tquic/tquic_socket.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/tquic_socket.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/tquic_socket.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-591",
    "title": "Aggregate Scheduler Long Spinlock Hold",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"ktime_get\" \"net/tquic/multipath/sched_aggregate.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/multipath/sched_aggregate.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/multipath/sched_aggregate.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-592",
    "title": "Benchmark Code: Userspace, Not Kernel",
    "category": "other",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Consider moving benchmark code to a `tools/` or `tests/` directory to avoid confusion about its execution context. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bench/ where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-594",
    "title": "C99 Variable Declaration in Loop",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_xor_decode\" \"net/tquic/fec/xor_fec.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/fec/xor_fec.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/fec/xor_fec.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-595",
    "title": "Constant-Time Comparison",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"crypto_memneq\" \"net/tquic/cong/cong_data.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/cong/cong_data.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-596",
    "title": "Coupled CC Alpha Smoothing May Suppress Rapid Changes",
    "category": "api",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"crypto_memneq\" \"net/tquic/bond/cong_coupled.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/bond/cong_coupled.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-599",
    "title": "CROSS-2: Consider using the `tquic_rx_buf_cache` slab cache pattern (already used at `tquic_input.c:2586`) more broadly for hot-path allocations to reduce GFP_ATOMIC pressure.",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_rx_buf_cache\" \"net/quic/tquic/\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/ where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-600",
    "title": "Debug Logging of Packet Contents",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_dbg\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-602",
    "title": "INFO-1: Several `pr_debug`/`tquic_dbg` calls include connection state information. While these are compile-time optional, in debug builds they could leak timing information about connection state to a",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:3, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_dbg\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-604",
    "title": "MEM-4: While stream count is limited, each stream allocates both `send_buf` and `recv_buf` skb queues. An attacker opening `max_streams_bidi` streams and sending minimal data to each creates per-strea",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_main\" \"net/quic/tquic/tquic_main.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Consider lazy initialization of stream buffers Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_main.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-605",
    "title": "Missing Documentation on Lock Ordering",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "FP-risk: Snippet(s) contain only comments, not actual vulnerable code.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "file:2, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_bonding\" \"net/tquic/fec/\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/fec/\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/fec/ where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-607",
    "title": "Multiple Scheduler Registration Systems Coexist",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:4",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_scheduler\" net/tquic/",
      "rg -rn \"spin_lock\\|mutex_lock\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-610",
    "title": "No Per-Connection Frame Processing Budget",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_process_frames\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-611",
    "title": "Path Validation Timer del_timer vs del_timer_sync",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"del_timer_sync\" \"net/tquic/pm/path_validation.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/tquic/pm/path_validation.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/pm/path_validation.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-613",
    "title": "PROTO-1: The retire loop at `tquic_cid.c:667-674` iterates the entire remote CID list for each NEW_CONNECTION_ID frame, marking CIDs as retired. While bounded by `active_connection_id_limit`, repeated",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_cid\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-614",
    "title": "Repair Data Pointer Lifetime",
    "category": "memory",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:2, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_fec_get_pending_repair\" \"net/tquic/fec/fec_encoder.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/tquic/fec/fec_encoder.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/fec/fec_encoder.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-615",
    "title": "send_skb Variable Used After Potential NULL",
    "category": "other",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-616",
    "title": "Sensitive Key Cleanup",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"kfree_sensitive\" \"net/tquic/cong/cong_data.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/cong/cong_data.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-617",
    "title": "settings seen_mask Limited to 64 Settings",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/http3/http3_settings.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-618",
    "title": "spin_lock (Not spin_lock_bh) Used in tquic_process_max_data_frame (tquic_input.c, lines 1015-1017)",
    "category": "other",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_process_max_data_frame\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Change to `spin_lock_bh(&ctx->conn->lock)`.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-619",
    "title": "STATE-2: An attacker could open connections, complete the handshake (consuming 1 connection per client rate token), then keep them alive by sending a PING frame every 29 seconds. With default 100 conn",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Enforce a maximum concurrent connections per-IP limit (distinct from rate limit), e.g., 32 connections per source IP Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_sysctl.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-620",
    "title": "STATE-3: No visible limit on the number of paths per connection. If an attacker can trigger path creation (via connection migration or multipath signaling), each new path creates timers and state.",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=line range, snippet.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Title exceeds 150 chars -- may be a pasted description rather than a distilled finding.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "lines:2, snippet:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Enforce max paths per connection limit Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-621",
    "title": "Stateless Reset Token Comparison Timing",
    "category": "security",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, line range.",
      "Single-source finding (source B); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:5, lines:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"crypto_memneq\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-624",
    "title": "tquic_build_short_header_internal Writes pkt_num to buf+64 Scratch Space (tquic_output.c, line 818)",
    "category": "other",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:6, snippet:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_build_short_header_internal\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Allocate a separate scratch buffer or use a function-local buffer:\n```c\nu8 pn_scratch[4];\npkt_num_len = tquic_encode_pkt_num(pn_scratch, pkt_num, largest_acked);\n```\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-625",
    "title": "tquic_encap_recv Double UDP Header Strip",
    "category": "other",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:1",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_encap_recv\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-627",
    "title": "tquic_encode_varint Does Not Validate val Range (tquic_output.c, lines 164-198)",
    "category": "other",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:3",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_encode_varint\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add validation: `if (val >= (1ULL << 62)) return -EINVAL;`\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-628",
    "title": "tquic_gso_init Integer Overflow in Allocation Size (tquic_output.c, line 1489)",
    "category": "other",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=symbol, snippet.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2, snippet:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_gso_init\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Use `size_t` arithmetic with overflow checking:\n```c\nsize_t alloc_size;\nif (check_mul_overflow((size_t)gso->gso_size, (size_t)max_segs, &alloc_size))\n    return -EINVAL;\n```\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-630",
    "title": "tquic_process_ack_frame Does Not Validate largest_ack vs first_ack_range (tquic_input.c, lines 601-660)",
    "category": "other",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_process_ack_frame\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add: `if (first_ack_range > largest_ack) return -EINVAL;`\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-632",
    "title": "tquic_process_coalesced Missing Infinite Loop Guard (tquic_input.c, lines 3079-3182)",
    "category": "other",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "sym:2",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -rn \"tquic_process_coalesced\" net/tquic/",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add `if (packets > 16) break;` to cap coalesced packets.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-633",
    "title": "tquic_sched_release Frees ext Under Lock but kfree Can Sleep",
    "category": "memory",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_sched_release\" \"net/quic/tquic/core/priority.c\"",
      "rg -n \"kmalloc\\|kzalloc\\|alloc_skb\\|memcpy\" \"net/quic/tquic/core/priority.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/core/priority.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-634",
    "title": "tquic_stream_alloc Uses GFP_KERNEL in Potentially Atomic Context",
    "category": "concurrency",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 2/5: present=file, symbol.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Race/locking claim without code snippet showing shared state or lock acquisition -- common false positive pattern.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1, sym:2",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "rg -n \"tquic_stream_alloc\" \"net/quic/tquic/tquic_stream.c\"",
      "rg -n \"spin_lock\\|mutex_lock\\|lock_sock\" \"net/quic/tquic/tquic_stream.c\"",
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Establish one synchronization model for this code path and make all state transitions/lookup paths follow it consistently. Risk: Locking/ordering changes can cause deadlocks or throughput regressions if not validated under stress and teardown races.",
    "required_next_artifacts": [
      "Pin down exact line range in net/quic/tquic/tquic_stream.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-637",
    "title": "Weighted DRR Iterates Over Empty Slots",
    "category": "perf",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "SPECULATIVE",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 1/5: only one evidence type present -- weak.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "file:1",
    "whats_missing": [
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Pin down exact line range in net/tquic/multipath/sched_weighted.c where the fault occurs.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-597",
    "title": "Coupled CC Alpha Smoothing May Suppress Rapid Changes",
    "category": "other",
    "severity": "S3",
    "original_confidence": "medium",
    "priority_score": 0.7,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "REJECTED",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.",
      "Single-source finding (source C); no independent confirmation.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "NONE",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Consider faster convergence when path count changes. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-638",
    "title": "ACK Frequency Frame Type Inconsistency",
    "category": "other",
    "severity": "S3",
    "original_confidence": "low",
    "priority_score": 0.4,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "REJECTED",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "NONE",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Verify the frame type dispatch logic handles multi-byte frame types correctly. Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-639",
    "title": "copy_from_sockptr in setsockopt Always Uses sizeof(type)",
    "category": "memory",
    "severity": "S3",
    "original_confidence": "low",
    "priority_score": 0.4,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "REJECTED",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: Memory safety claim without code snippet showing the vulnerable buffer/allocation.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "NONE",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-640",
    "title": "Diagnostic Counter Wraps",
    "category": "correctness",
    "severity": "S3",
    "original_confidence": "low",
    "priority_score": 0.4,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "REJECTED",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "NONE",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Fix the protocol logic per the relevant RFC section; add an interop regression test covering the corrected state transition.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-641",
    "title": "Error Codes Leak Processing State",
    "category": "security",
    "severity": "S3",
    "original_confidence": "low",
    "priority_score": 0.4,
    "source_count": 1,
    "sources": [
      "B"
    ],
    "verdict": "REJECTED",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.",
      "Single-source finding (source B); no independent confirmation.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "NONE",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Add strict validation and bounds checks at parse boundaries, enforce lifetime/ownership rules, and fail closed on malformed input. Risk: Fixes in parser/crypto/lifetime code may alter packet acceptance logic. Watch for interoperability regressions and accidental behavior changes in fast-path RX handling.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-642",
    "title": "IMMEDIATE_ACK Frame Type Similar Issue",
    "category": "other",
    "severity": "S3",
    "original_confidence": "low",
    "priority_score": 0.4,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "REJECTED",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "NONE",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-643",
    "title": "Inconsistent Congestion State Layouts",
    "category": "other",
    "severity": "S3",
    "original_confidence": "low",
    "priority_score": 0.4,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "REJECTED",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "NONE",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-644",
    "title": "Multiple Varint Implementations (Code Duplication Risk)",
    "category": "other",
    "severity": "S3",
    "original_confidence": "low",
    "priority_score": 0.4,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "REJECTED",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced.",
      "Single-source finding -- no independent confirmation."
    ],
    "key_evidence_present": "NONE",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Consolidate to the single canonical implementation in `core/varint.c` and export symbols for all callers.\n\n--- Risk: Protocol correctness fixes can shift timing/state-machine behavior; verify against interop traces and existing retransmission/loss logic.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  },
  {
    "cid": "CF-645",
    "title": "Three Parallel Scheduler Frameworks",
    "category": "other",
    "severity": "S3",
    "original_confidence": "low",
    "priority_score": 0.4,
    "source_count": 1,
    "sources": [
      "C"
    ],
    "verdict": "REJECTED",
    "confidence_after_judging": "low",
    "reason": [
      "Evidence score 0/5: no concrete file, symbol, line range, snippet, or log provided.",
      "Single-source finding (source C); no independent confirmation.",
      "FP-risk: Recommended fix is generic/boilerplate -- the reporter may not have understood the code deeply enough to propose a real fix.",
      "FP-risk: No file path and no symbol identified -- finding is untethered to any specific code location.",
      "Highest severity retained but flagged as weakly evidenced."
    ],
    "key_evidence_present": "NONE",
    "whats_missing": [
      "Concrete source file path (e.g., net/tquic/...)",
      "Exact line range(s) where the fault manifests",
      "Code snippet proving the vulnerable pattern",
      "Function/struct symbol name at the fault site",
      "Kernel log / stack trace / error output demonstrating the issue",
      "Independent confirmation from a second audit source",
      "Minimal reproduction steps (expected vs. actual)"
    ],
    "minimal_verification": [
      "make M=net/tquic W=1",
      "make M=net/tquic C=1  # sparse static analysis"
    ],
    "safest_fix": "Apply minimal targeted fix; add regression test; verify with make M=net/tquic W=1 C=1 and lockdep/KASAN enabled.",
    "required_next_artifacts": [
      "Identify the exact source file (e.g., net/tquic/...) where the bug manifests.",
      "Provide a minimal code snippet from the source showing the vulnerable pattern.",
      "Obtain independent confirmation from a second auditor or a failing test case.",
      "Produce a kernel log / KASAN/lockdep report or stack trace demonstrating the issue.",
      "Create a targeted KUnit or kselftest that triggers the bug and fails before the fix."
    ]
  }
]